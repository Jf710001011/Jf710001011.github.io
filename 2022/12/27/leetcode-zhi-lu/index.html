<!DOCTYPE HTML>
<html lang="en">




<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Leetcode之旅, Hunter|Hacker|Coder|Artist">
    <meta name="description" content="信念与认知">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>


    <title>Leetcode之旅 | Jf71o0x1o1l</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Jf71o0x1o1l" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


    

                <body>
                    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Jf71o0x1o1l</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Jf71o0x1o1l</div>
        <div class="logo-desc">
            
            信念与认知
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

                        



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/17.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Leetcode之旅</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/C/">
                                <span class="chip bg-color">C++</span>
                            </a>
                        
                            <a href="/tags/Python/">
                                <span class="chip bg-color">Python</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Programming-Design/" class="post-category">
                                Programming Design
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2022-12-27
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>Update Date:&nbsp;&nbsp;
                    2023-12-05
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    11.8k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>Read Count:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="参考资料">参考资料</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/halfrost/LeetCode-Go">github</a></p>
<p><a target="_blank" rel="noopener" href="https://books.halfrost.com/leetcode/">books</a></p>
<h3 id="在2022-12-26日之前">在2022-12-26日之前</h3>
<ul>
<li>已完成</li>
</ul>
<figure>
<img src="https://s2.loli.net/2022/12/26/3xWKJkqlvZTAgm6.png"
alt="image-20221226234508236" />
<figcaption aria-hidden="true">image-20221226234508236</figcaption>
</figure>
<ul>
<li>北林OJ上的刷题</li>
</ul>
<figure>
<img src="https://s2.loli.net/2023/01/13/v8oiGFITWqMRYnd.png"
alt="image-20230113002007660" />
<figcaption aria-hidden="true">image-20230113002007660</figcaption>
</figure>
<hr />
<h3 id="完全平方数">2023-12-05 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/description/">279.
完全平方数</a></h3>
<h4 id="我思">我思</h4>
<ol type="1">
<li>找到与该数字x轴左侧最接近的平方数，从大到小试探，保证最数字数量最少</li>
</ol>
<h4 id="实现">实现</h4>
<ol type="1">
<li><p>dp</p>
<ol type="1">
<li><p>依据题目的要求写出状态表达式：f[i]
表示最少需要多少个数的平方来表示整数 i。</p>
<p>这些数必然落在区间 <span
class="math display">\[[1,\sqrt{n}]\]</span>。我们可以枚举这些数，假设当前枚举到
j，那么我们还需要取若干数的平方，构成
此时我们发现该子问题和原问题类似，只是规模变小了。这符合了动态规划的要求，于是我们可以写出状态转移方程。<img
src="https://cdn.jsdelivr.net/gh/Jf710001011/pictureBed@main/img/202312051136431.png"
alt="image-20231205113618306" /></p></li>
</ol></li>
<li><p>寻找问题的<strong>特殊性</strong>：如1的平方是1，则一个非常大的数，可以有好多个1相加而成</p></li>
<li><p>该提出的疑问：</p>
<ol type="1">
<li>是否所有数都必定符合由平方和</li>
<li>在满足1的情况下，这种组合有多少种，有没有一个范围</li>
</ol></li>
<li><p>Code</p>
<pre class="language-java" data-language="java"><code class="language-java">class Solution &#123;
   public:
    int numSquares(int n) &#123;
        vector&lt;int&gt; dp(n + 1);  &#x2F;&#x2F; 边界条件dp[0] &#x3D; 0
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
            dp[i] &#x3D; i;  &#x2F;&#x2F; 全是平方为1的和
            for (int j &#x3D; 1; j * j &lt;&#x3D; i; j++) &#123;
                &#x2F;&#x2F; 每一轮二次循环都要会更新dp[i]，因为每个数字有多种组合
                dp[i] &#x3D; min(dp[i], dp[i - j * j] + 1);  &#x2F;&#x2F; 转移方程
            &#125;
        &#125;
        return dp[n];
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="搜索二维矩阵-ii">2023-11-30 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/">240.
搜索二维矩阵 II</a></h3>
<h4 id="我思-1">我思</h4>
<ol type="1">
<li>想不到什么奇妙的方法</li>
</ol>
<h4 id="实现-1">实现</h4>
<ol type="1">
<li><p>特点：</p>
<ol type="1">
<li>行有序，列有序</li>
<li>二维数组</li>
<li>查找</li>
</ol></li>
<li><p>法<code>1</code>：暴力遍历</p></li>
<li><p>法<code>2</code>：二分查找</p>
<ol type="1">
<li>对每行二分查找</li>
</ol></li>
<li><p>法<code>3</code>：Z字形查找</p>
<ol type="1">
<li>如果我们从左往右，从上到下的顺序思考问题：
<ol type="1">
<li>如果此时<code>target</code> &gt;
<code>matrix(x,y)</code>,那么此时可能是<code>matrix(x+1,y)</code>,也可能是<code>matrix(x,y+1)</code></li>
</ol></li>
</ol>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;
        &#x2F;&#x2F; 而如果我们遍历的元素一直在遍历范围的右上角（x,y）
        &#x2F;&#x2F; 遍历的范围局限于以(x，y)为右上角的矩阵中
        &#x2F;&#x2F; 那么此刻我们保证了该元素是该范围中行最小，列最大的元素
        int rows &#x3D; matrix.size();
        int cols &#x3D; matrix[0].size();
        int i &#x3D; 0;
        int j &#x3D; cols - 1;

        while (i &lt; rows &amp;&amp; j &gt;&#x3D; 0) &#123;
            if (matrix[i][j] &gt; target) &#123;  &#x2F;&#x2F; 行中已是最大，只能列减小
                j--;
            &#125; else if (matrix[i][j] &#x3D;&#x3D; target) &#123;
                return true;
            &#125; else &#123;  &#x2F;&#x2F; 列中已是最小，只能行增加
                i++;
            &#125;
        &#125;
        return false;
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="除自身以外数组的乘积">2023-11-29 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/product-of-array-except-self/description/">238.
除自身以外数组的乘积</a></h3>
<h4 id="我思-2">我思</h4>
<ol type="1">
<li>除法是最容易想到的，但是 <strong>0</strong>时失效</li>
</ol>
<h4 id="实现-2">实现</h4>
<ol type="1">
<li><p>另一个角度是：该元素**左边所有的乘积*右边所有的乘积**</p></li>
<li><p>时间的优化必然是牺牲空间，那会牺牲在哪里呢</p></li>
<li><p>Code</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;
        int len &#x3D; nums.size();
        vector&lt;int&gt; ans(len);

        &#x2F;&#x2F; 记录每个元素的左侧乘积和右侧乘积
        ans[0] &#x3D; 1;
        for (int i &#x3D; 1; i &lt; len; i++) &#123;
            ans[i] &#x3D; ans[i - 1] * nums[i - 1];
        &#125;

        &#x2F;&#x2F; 题目设定：输出数组的空间不考虑
        &#x2F;&#x2F; 所以将一侧的乘积数组作为输出数组
        &#x2F;&#x2F; 而另一侧则只需要记住该元素相关的乘积，而不是乘积数组，因此只需要一个变量记录
        int right &#x3D; 1;  &#x2F;&#x2F; 该值右侧所有元素的乘积
        for (int i &#x3D; len - 1; i &gt;&#x3D; 0; i--) &#123;
            ans[i] &#x3D; ans[i] * right;
            right *&#x3D; nums[i];  &#x2F;&#x2F; 向左更新right
        &#125;
        return ans;
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="最大正方形">2023-11-28 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-square/description/">221.
最大正方形</a></h3>
<h4 id="我思-3">我思</h4>
<ol type="1">
<li>记录当时图形的<strong>四个顶角坐标</strong></li>
<li>为了保证<strong>正方形</strong>，我们需要王<strong>四个方向</strong>
<em>同时</em>扩充1列+1行
<ol type="1">
<li>检查扩充的那一列/行是否<strong>全是1</strong></li>
</ol></li>
<li></li>
</ol>
<h4 id="实现-3">实现</h4>
<ol type="1">
<li><p>法1：暴力</p></li>
<li><p>法2：dp</p>
<ol type="1">
<li><p>考虑<code>dp(i，j)</code>的含义：以<code>(i，j)</code>为右下角构成的正方形的最大边长</p>
<ol type="1">
<li>为什么不是左上角？假设代表左上角：则相邻的点的值还未知</li>
</ol></li>
<li><p>关键，<strong>转移方程</strong>：<code>dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1</code></p>
<ol type="1">
<li>当这相邻三个点的值最小值为0时，这个正方形都无法扩展</li>
<li>当...最小值为1时，这个正方形边长增量为1</li>
<li>当为2时，画图包裹区域法<img
src="https://s2.loli.net/2023/11/28/GEQScVDKLN3wkb6.png"
alt="image-20231128041105749" />
<ol type="1">
<li>只有保证最小值为2，才能使得边长为3的正方形区域完全被包裹</li>
</ol></li>
</ol></li>
<li><p>Code</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;
        int row &#x3D; matrix.size();
        int col &#x3D; matrix[0].size();

        if (row &#x3D;&#x3D; 0 || col &#x3D;&#x3D; 0) &#123;
            return 0;
        &#125;

        int ans &#x3D; 0;
        vector&lt;vector&lt;int&gt;&gt; dp(row, vector&lt;int&gt;(col));
        for (int i &#x3D; 0; i &lt; row; i++) &#123;
            for (int j &#x3D; 0; j &lt; col; j++) &#123;
                if (matrix[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;  &#x2F;&#x2F; 注意是char型
                    if (i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0) &#123;
                        dp[i][j] &#x3D; 1;
                    &#125; else &#123;
                        dp[i][j] &#x3D; min(min(dp[i - 1][j], dp[i - 1][j - 1]),
                                       dp[i][j - 1]) +
                                   1;
                    &#125;
                &#125;
                ans &#x3D; max(ans, dp[i][j]);
            &#125;
        &#125;
        int maxSquare &#x3D; ans * ans;
        return ans * ans;
    &#125;
&#125;;	</code></pre></li>
</ol></li>
</ol>
<h3 id="数组中的第k个最大元素">2023-11-21 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">215.
数组中的第K个最大元素</a></h3>
<h4 id="我思-4">我思</h4>
<ol type="1">
<li>要保证<code>O(n)</code>时间复杂度，肯定不能排序</li>
<li>思路：
<ol type="1">
<li>遍历所有元素，给出一个足够大的数组<code>a</code>，将值为<code>x</code>的元素放在<code>a[x]</code></li>
<li>再次遍历到 存在元素的第<code>k</code>个位置</li>
</ol></li>
</ol>
<h4 id="实现-4">实现</h4>
<ol type="1">
<li><p>复习一下<code>快排</code></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

void quickSort(std::vector&lt;int&gt;&amp; nums, int left, int right) &#123;
    if (left &lt; right) &#123;
        srand(time(nullptr));
        int random &#x3D; rand() % (right - left + 1) + left;
        int pivot &#x3D; nums[random];

        std::swap(nums[left], nums[random]);

        int j &#x3D; left;
        for (int i &#x3D; left + 1; i &lt; right; i++) &#123;
            if (nums[i] &gt;&#x3D; pivot) &#123;
                std::swap(nums[j + 1], nums[i]);
                j++;
            &#125;
        &#125;

        std::swap(nums[j], nums[left]);
        quickSort(nums, left, j);
        quickSort(nums, j + 1, right);
    &#125;
&#125;

void printVector(const std::vector&lt;int&gt;&amp; nums) &#123;
    for (int num : nums) &#123;
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    &#125;
    std::cout &lt;&lt; std::endl;
&#125;

int main() &#123;
    &#x2F;&#x2F; Test case 1: Empty vector
    std::vector&lt;int&gt; nums1;
    quickSort(nums1, 0, nums1.size());
    std::cout &lt;&lt; &quot;Test case 1: &quot;;
    printVector(nums1);

    &#x2F;&#x2F; Test case 2: Vector with one element
    std::vector&lt;int&gt; nums2 &#x3D; &#123;5&#125;;
    quickSort(nums2, 0, nums2.size());
    std::cout &lt;&lt; &quot;Test case 2: &quot;;
    printVector(nums2);

    &#x2F;&#x2F; Test case 3: Vector with multiple elements
    std::vector&lt;int&gt; nums3 &#x3D; &#123;9, 2, 7, 1, 5&#125;;
    quickSort(nums3, 0, nums3.size());
    std::cout &lt;&lt; &quot;Test case 3: &quot;;
    printVector(nums3);

    &#x2F;&#x2F; Test case 4: Vector with duplicate elements
    std::vector&lt;int&gt; nums4 &#x3D; &#123;3, 6, 2, 6, 1, 3&#125;;
    quickSort(nums4, 0, nums4.size());
    std::cout &lt;&lt; &quot;Test case 4: &quot;;
    printVector(nums4);

    return 0;
&#125;</code></pre></li>
<li><p>复习一下<code>堆排序</code></p>
<ol type="1">
<li><p><code>assert</code><img
src="https://s2.loli.net/2023/11/22/JrzsMOkHV7Gpc14.png"
alt="image-20231122011536779" /></p></li>
<li><p>code</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;

using namespace std;

&#x2F;&#x2F;  调整堆
void heapify(vector&lt;int&gt;&amp; nums, int n, int i) &#123;
    int indexLargest &#x3D; i;
    int left &#x3D; 2 * i + 1;
    int right &#x3D; 2 * i + 2;

    &#x2F;&#x2F; 如果左子节点大于根节点
    if (left &lt; n &amp;&amp; nums[left] &gt; nums[indexLargest]) &#123;
        indexLargest &#x3D; left;
    &#125;

    &#x2F;&#x2F; 如果右子节点大于根节点
    if (right &lt; n &amp;&amp; nums[right] &gt; nums[indexLargest]) &#123;
        indexLargest &#x3D; right;
    &#125;

    &#x2F;&#x2F; 调整以i为根节点的树
    if (i !&#x3D; indexLargest) &#123;  &#x2F;&#x2F; 最大节点不是根节点
        swap(nums[i], nums[indexLargest]);
        &#x2F;&#x2F; indexLargest：是与根节点产生交换的节点下标，以此为根节点的子树也可能需要调整
        heapify(nums, n, indexLargest);
    &#125;
&#125;

&#x2F;&#x2F; 堆排序
void heapSort(vector&lt;int&gt;&amp; nums) &#123;
    int n &#x3D; nums.size();

    &#x2F;&#x2F; 自底向上调整：构建大根堆,从最后一个非叶子节点开始
    for (int i &#x3D; n &#x2F; 2 - 1; i &gt;&#x3D; 0; i--) &#123;
        heapify(nums, n, i);
    &#125;

    &#x2F;&#x2F; 删除堆顶元素并向下重新调整
    for (int i &#x3D; n - 1; i &gt; 0; i--) &#123;
        swap(nums[0], nums[i]);
        &#x2F;&#x2F; 从根节点开始调整
        heapify(nums, i, 0);
    &#125;
&#125;

void testHeapSort() &#123;
    &#x2F;&#x2F; Test Case 1: Empty vector
    &#123;
        vector&lt;int&gt; nums;
        heapSort(nums);
        assert(nums.empty());
    &#125;

    &#x2F;&#x2F; Test Case 2: Vector with one element
    &#123;
        vector&lt;int&gt; nums &#x3D; &#123;5&#125;;
        heapSort(nums);
        assert(nums.size() &#x3D;&#x3D; 1);
        assert(nums[0] &#x3D;&#x3D; 5);
    &#125;

    &#x2F;&#x2F; Test Case 3: Vector with multiple elements in random order
    &#123;
        vector&lt;int&gt; nums &#x3D; &#123;9, 2, 7, 1, 5&#125;;
        heapSort(nums);
        assert(nums.size() &#x3D;&#x3D; 5);
        assert(nums[0] &#x3D;&#x3D; 1);
        assert(nums[1] &#x3D;&#x3D; 2);
        assert(nums[2] &#x3D;&#x3D; 5);
        assert(nums[3] &#x3D;&#x3D; 7);
        assert(nums[4] &#x3D;&#x3D; 9);
    &#125;

    &#x2F;&#x2F; Test Case 4: Vector with duplicate elements
    &#123;
        vector&lt;int&gt; nums &#x3D; &#123;3, 2, 5, 2, 1, 5&#125;;
        heapSort(nums);
        assert(nums.size() &#x3D;&#x3D; 6);
        assert(nums[0] &#x3D;&#x3D; 1);
        assert(nums[1] &#x3D;&#x3D; 2);
        assert(nums[2] &#x3D;&#x3D; 2);
        assert(nums[3] &#x3D;&#x3D; 3);
        assert(nums[4] &#x3D;&#x3D; 5);
        assert(nums[5] &#x3D;&#x3D; 5);
    &#125;

    &#x2F;&#x2F; Test Case 5: Vector already sorted in ascending order
    &#123;
        vector&lt;int&gt; nums &#x3D; &#123;1, 2, 3, 4, 5&#125;;
        heapSort(nums);
        assert(nums.size() &#x3D;&#x3D; 5);
        assert(nums[0] &#x3D;&#x3D; 1);
        assert(nums[1] &#x3D;&#x3D; 2);
        assert(nums[2] &#x3D;&#x3D; 3);
        assert(nums[3] &#x3D;&#x3D; 4);
        assert(nums[4] &#x3D;&#x3D; 5);
    &#125;

    &#x2F;&#x2F; Test Case 6: Vector already sorted in descending order
    &#123;
        vector&lt;int&gt; nums &#x3D; &#123;5, 4, 3, 2, 1&#125;;
        heapSort(nums);
        assert(nums.size() &#x3D;&#x3D; 5);
        assert(nums[0] &#x3D;&#x3D; 1);
        assert(nums[1] &#x3D;&#x3D; 2);
        assert(nums[2] &#x3D;&#x3D; 3);
        assert(nums[3] &#x3D;&#x3D; 4);
        assert(nums[4] &#x3D;&#x3D; 5);
    &#125;
&#125;

int main() &#123;
    testHeapSort();
    return 0;
&#125;
</code></pre></li>
</ol></li>
<li><p>快排是可以确定每一轮的pivot处于最终排序位置的，基于此寻找第k大;</p>
<ol type="1">
<li><p>Code</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    void quickSelectKth(vector&lt;int&gt;&amp; nums, int left, int right, int k) &#123;
        srand(time(nullptr));
        int pivot &#x3D; rand() % (right - left + 1) + left;
        swap(nums[left], nums[pivot]);

        int j &#x3D; left;

        for (int i &#x3D; left + 1; i &lt;&#x3D; right; i++) &#123;
            if (nums[i] &gt;&#x3D; nums[left]) &#123;
                swap(nums[j+1], nums[i]);
                &#x2F;&#x2F; j++ 之后的j &#x3D; 上一行的j+1;出循环后保证了j是&gt;&#x3D;nums[pivot]的最小值
                j++;
            &#125;
        &#125;

        &#x2F;&#x2F; 交换后，保证了nums[j]是在0-j序列中的最小值，因此如果k&lt;j,则nums[k]&gt;nums[j]
        &#x2F;&#x2F; 因此往左侧搜寻
        swap(nums[j], nums[left]);
        &#x2F;&#x2F; while循环结束，i&#x3D;j,此时的位置就是pivot排序的最终位置，也就确认了pivot是第几大

        &#x2F;&#x2F; 如果k&#x3D;j,则已经达到目的
        if (k &lt; j) &#123;
            quickSelectKth(nums, left, j - 1, k);
        &#125; else if (k &gt; j) &#123;
            quickSelectKth(nums, j + 1, right, k);
        &#125;
    &#125;

    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;
        &#x2F;&#x2F; 注意第k大的数在数组中排序是k-1
        quickSelectKth(nums, 0, nums.size() - 1, k - 1);
        return nums[k-1];
    &#125;
&#125;;</code></pre></li>
<li><p>逆天测试用例无法通过<img
src="https://s2.loli.net/2023/11/21/8iDzI9kldZjeJUQ.png"
alt="image-20231121091543725" /></p></li>
</ol></li>
<li><p>最好的划分：3组</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    int quickSearchKth(vector&lt;int&gt;&amp; nums, int k) &#123;
        srand(time(nullptr));
        int pivot &#x3D; nums[rand() % nums.size()];

        vector&lt;int&gt; big, equal, small;
        for (int num : nums) &#123;
            if (num &gt; pivot) &#123;
                big.push_back(num);
            &#125; else if (num &lt; pivot) &#123;
                small.push_back(num);
            &#125; else &#123;
                equal.push_back(num);
            &#125;
        &#125;

        if (k &lt;&#x3D; big.size()) &#123;
            return quickSearchKth(big, k);
        &#125; else if (nums.size() - small.size() &lt; k) &#123;
            &#x2F;&#x2F; 在全局中是第k大,而在samll中不是
            return quickSearchKth(small, k - big.size() - equal.size());
        &#125;

        return pivot;
    &#125;

    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;
        return quickSearchKth(nums, k);
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="岛屿数量">2023-11-15 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/description/">200.岛屿数量</a></h3>
<h4 id="我思-5">我思</h4>
<ol type="1">
<li>理解1座岛屿的<strong>概念</strong>：
<ol type="1">
<li>岛屿总是被水包围，</li>
<li>并且每座岛屿只能由<code>水平</code>方向和/或<code>竖直</code>方向上相邻的陆地连接形成<img
src="https://s2.loli.net/2023/11/15/CZ4SQAe9ROEtYoN.png"
alt="image-20231115024938652" /></li>
</ol></li>
<li>识别到<code>1</code>
<code>（i,j）</code>，那么就检测它的周围（<code>[i-1,j]</code>,<code>[i+1,j]</code>,<code>[i,j-1]</code>,<code>[i,j+1]</code>；<strong>注意</strong>：考虑到边界原因，这些坐标并不一定都存在）是否为<code>1</code>，
<ol type="1">
<li>如果是<code>1</code>，那么就是同一座岛屿，并把它标记为<strong>已处理</strong>
<ol type="1">
<li>1座岛屿面积确定的标志：所有<code>1</code>的上下左右均为<code>0</code>，否则加入新的<code>1</code>继续延伸</li>
</ol></li>
<li>如果为<code>0</code>，那么就是岛屿的一处边界</li>
</ol></li>
</ol>
<h4 id="实现-5">实现</h4>
<ol type="1">
<li><p>Code</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    &#x2F;&#x2F; dfs
    &#x2F;&#x2F; 进行dfs的次数便是岛屿的个数
    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int r, int c) &#123;
        &#x2F;&#x2F; 遍历到的1复位为0，避免重复处理
        grid[r][c] &#x3D; &#39;0&#39;;

        &#x2F;&#x2F; dfs 这个“1”的四周
        int rc &#x3D; grid.size();
        int cc &#x3D; grid[0].size();

        if (r - 1 &gt;&#x3D; 0 &amp;&amp; grid[r - 1][c] &#x3D;&#x3D; &#39;1&#39;)
            dfs(grid, r - 1, c);
        if (r + 1 &lt; rc &amp;&amp; grid[r + 1][c] &#x3D;&#x3D; &#39;1&#39;)
            dfs(grid, r + 1, c);
        if (c - 1 &gt;&#x3D; 0 &amp;&amp; grid[r][c - 1] &#x3D;&#x3D; &#39;1&#39;)
            dfs(grid, r, c - 1);
        if (c + 1 &lt; cc &amp;&amp; grid[r][c + 1] &#x3D;&#x3D; &#39;1&#39;)
            dfs(grid, r, c + 1);
    &#125;

    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;
        int rc &#x3D; grid.size();
        if (!rc)
            return 0;
        int cc &#x3D; grid[0].size();

        int nums_islands &#x3D; 0;
        for (int r &#x3D; 0; r &lt; rc; r++) &#123;
            for (int c &#x3D; 0; c &lt; cc; c++) &#123;
                if(grid[r][c] &#x3D;&#x3D; &#39;1&#39;) &#123;
                    nums_islands++;
                    dfs(grid,r,c);
                &#125;
            &#125;
        &#125;
        return nums_islands;
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="课程表">2023-11-19: <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/description/">207.
课程表</a></h3>
<h4 id="我思-6">我思</h4>
<ol type="1">
<li>示例是不是不够，应该还有很多情况没有列出来吧（但感觉也不太可能）</li>
</ol>
<h4 id="实现-6">实现</h4>
<ol type="1">
<li><p>每个课程表示为图中的一个顶点及其每门课程之间的关系构成了一个图</p></li>
<li><p>给定一个有向无环图，<code>拓扑排序</code>是将图中的顶点按顺序排列，使得对于图中任意一条有向边，其起点顶点在其终点顶点之前。</p></li>
<li><p>如果会互相依赖，实际则表现为成环，则不可能完成课程的学习</p></li>
<li><p>说明：</p>
<ol type="1">
<li><p>对于图中的任意一个节点，它在搜索的过程中有<strong>三种状态</strong>，即：</p>
<p>「<strong>未搜索</strong>」：我们还没有搜索到这个节点；</p>
<p>「<strong>搜索中</strong>」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p>
<p>「<strong>已完成</strong>」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p></li>
</ol></li>
<li><p>Code</p>
<pre class="language-java" data-language="java"><code class="language-java">class Solution &#123;
   private:
    vector&lt;vector&lt;int&gt;&gt; edges;
    vector&lt;int&gt; visit;
    bool finished &#x3D; true;

   public:
    void dfs(int u) &#123;
        &#x2F;&#x2F; 标记为已被访问
        visit[u] &#x3D; 1;

        &#x2F;&#x2F; 访问u的邻接点
        for (int v : edges[u]) &#123;
            &#x2F;&#x2F; 有环（即不能完成所有课程）
            if (!finished) &#123;
                return;
            &#125;

            if (visit[v] &#x3D;&#x3D; 0) &#123;
                &#x2F;&#x2F; 如果该邻接点未被访问过，则继续深度优先搜索
                dfs(v);
            &#125; else if (visit[v] &#x3D;&#x3D; 1) &#123;
                &#x2F;&#x2F; 如果该节点之前便处于搜索中，那么说明存在环
                finished &#x3D; false;
                return;
            &#125;
        &#125;
        &#x2F;&#x2F; 返回u,u及其邻接点搜索完成	
        visit[u] &#x3D; 2;
    &#125;
    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;
        edges.resize(numCourses);
        visit.resize(numCourses);

        for (const auto&amp; info : prerequisites) &#123;
            edges[info[1]].push_back(info[0]);
        &#125;

        for (int i &#x3D; 0; i &lt; numCourses &amp;&amp; finished; ++i) &#123;
            if (visit[i] &#x3D;&#x3D; 0) &#123;
                dfs(i);
            &#125;
        &#125;
        return finished;
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="编辑距离">2023-11-09：<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/description/">72.编辑距离</a></h3>
<h4 id="我思-7">我思</h4>
<ol type="1">
<li>充分利用相似的部分
<ol type="1">
<li>一样的字母</li>
<li>字母之间的相对顺序</li>
</ol></li>
<li>但是代码中如何实现以上特性呢
<ol type="1">
<li>操作的方式有3种，怎么确定这是最少的操作方式</li>
</ol></li>
</ol>
<h4 id="实现-7">实现</h4>
<ol type="1">
<li><p>定义dp是一个难点</p></li>
<li><p>状态转移关系同样是个难点</p></li>
<li><p>Code</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    int minDistance(string word1, string word2) &#123;
        &#x2F;&#x2F; 动态规划
        &#x2F;&#x2F; 定义 dp[i][j] : dp[i][j] 代表 word1 中前 i 个字符，变换到 word2 中前
        &#x2F;&#x2F; j 个字符，最短需要操作的次数:需要考虑 word1 或 word2
        &#x2F;&#x2F; 状态转移 :
        &#x2F;&#x2F; 增，dp[i][j] &#x3D; dp[i][j - 1] + 1
        &#x2F;&#x2F; 删，dp[i][j] &#x3D; dp[i - 1][j] + 1
        &#x2F;&#x2F; 改，dp[i][j] &#x3D; dp[i - 1][j - 1] + 1
        &#x2F;&#x2F; 按顺序计算，当计算 dp[i][j] 时，dp[i - 1][j] ， dp[i][j - 1] ， dp[i
        &#x2F;&#x2F; - 1][j - 1] 均已经确定了 配合增删改这三种操作，需要对应的 dp
        &#x2F;&#x2F; 把操作次数加一，取三种的最小 如果刚好这两个字母相同 word1[i - 1] &#x3D;

        &#x2F;&#x2F; vector 的初始化方法为 vector(size,value)
        vector&lt;vector&lt;int&gt;&gt; dp(word1.size() + 1,
                               vector&lt;int&gt;(word2.size() + 1, 0));

        &#x2F;&#x2F; 一个字母都没有，即全增加&#x2F;删除的情况，所以预留 dp[0][j] 和 dp[i][0]
        for (int i &#x3D; 0; i &lt; dp.size(); i++) &#123;
            dp[i][0] &#x3D; i;
        &#125;
        for (int j &#x3D; 0; j &lt; dp[0].size(); j++) &#123;
            dp[0][j] &#x3D; j;
        &#125;

        for (int i &#x3D; 1; i &lt; dp.size(); i++) &#123;
            for (int j &#x3D; 1; j &lt; dp[0].size(); j++) &#123;
                &#x2F;&#x2F; word2[j - 1] （下标0开始），那么可以直接参考 dp[i - 1][j - 1]
                &#x2F;&#x2F; ，操作不用加一
                dp[i][j] &#x3D;
                    min(dp[i][j - 1], min(dp[i - 1][j], dp[i - 1][j - 1])) + 1;

                &#x2F;&#x2F; 放在上句的后面是因为当两个单词当前字母相等时，放在后面才能确保dp[i][j]的正确性
                if (word1[i - 1] &#x3D;&#x3D; word2[j - 1]) &#123;
                    dp[i][j] &#x3D; dp[i - 1][j - 1];
                &#125;
            &#125;
        &#125;
        &#x2F;&#x2F; 最后一个行中的最后一个元素。
        return dp.back().back();
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="乘积最大子数组">2023-10-29-<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-subarray/description/">乘积最大子数组</a></h3>
<h4 id="我思-8">我思</h4>
<ol type="1">
<li>正数越多越好</li>
<li>有负数，偶数个负数</li>
<li>确定子序列起点；确定子序列长度</li>
</ol>
<h4 id="实现-8">实现</h4>
<ol type="1">
<li><p>由于正负性：当前位置的最优解未必是由前一个位置的最优解转移得到的。</p>
<ol type="1">
<li>如果当前位置是负数，那么最好前面负的越多越好</li>
<li>如果是正数，那么正的越多越好</li>
</ol></li>
<li><p>并不需要dp数组，只需要前一个位置的最大解或者最小解</p></li>
<li><p>Code</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;
        int maxF &#x3D; nums[0], minF &#x3D; nums[0], ans &#x3D; nums[0];
        for (int i &#x3D; 1; i &lt; nums.size(); i++) &#123;
            int mx &#x3D; maxF, mn &#x3D; minF;
            &#x2F;&#x2F; 要获得乘积最大，比较四个情况:nums[i];nums[i]*mx;nums[i]*mn;前一个位置的最大乘积
            maxF &#x3D; max(nums[i] * mx, max(nums[i] * mn, nums[i]));
            minF &#x3D; min(nums[i] * mx, min(nums[i] * mn, nums[i]));
            &#x2F;&#x2F; 第四个情况的比较
            ans &#x3D; max(maxF, ans);
        &#125;
        return ans;
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="lru-缓存">2023-10-25 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/description/">146.LRU
缓存</a></h3>
<h4 id="我思-9">我思</h4>
<ol type="1">
<li>关键是：对下一个被替换的键值对标记，方便随时替换</li>
</ol>
<h4 id="实现-9">实现</h4>
<ol type="1">
<li><p>从函数功能出发,更多的是数据结构的考量：</p>
<ol type="1">
<li><code>int get(int key)</code>
需要通过数字，找到这个页面，(key,value)-》map数据结构，</li>
<li>数组还是链表？
<ol type="1">
<li><code>void put(int key, int value)</code>主要是考虑置换哪个页面：
<ol type="1">
<li>如果是数组，则需要不断更新每个页面的标记（标记表示置换的优先级）</li>
<li>如果是链表：按从头到尾表示优先级即可（头插法），头部插入</li>
</ol></li>
</ol></li>
</ol></li>
<li><p>Code</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 为什么是双向链表（我认为数组也可以）
&#x2F;&#x2F; 但如果是链表，则双向可以更快确定插入位置&#x2F;删除位置的前后节点
struct DLinkedNode &#123;
    int key, value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode() : key(0), value(0), prev(nullptr), next(nullptr) &#123;&#125;
    DLinkedNode(int _key, int _value)
        : key(_key), value(_value), prev(nullptr), next(nullptr) &#123;&#125;
&#125;;

class LRUCache &#123;
   private:
    unordered_map&lt;int, DLinkedNode*&gt; cache;
    DLinkedNode* head;
    &#x2F;&#x2F; 移除尾部节点（被置换的节点）
    DLinkedNode* tail;
    &#x2F;&#x2F; 比较size和capacity确定是否需要置换
    int size;
    int capacity;

   public:
    LRUCache(int _capacity) : capacity(_capacity), size(0) &#123;
        head &#x3D; new DLinkedNode();
        tail &#x3D; new DLinkedNode();
        head-&gt;next &#x3D; tail;
        tail-&gt;prev &#x3D; head;
    &#125;

    int get(int key) &#123;
        if (!cache.count(key)) &#123;
            return -1;
        &#125;

        DLinkedNode* node &#x3D; cache[key];
        &#x2F;&#x2F; 刷到最新
        moveToHead(node);
        return node-&gt;value;
    &#125;

    void put(int key, int value) &#123;
        if (!cache.count(key)) &#123;
            DLinkedNode* node &#x3D; new DLinkedNode(key, value);
            cache[key] &#x3D; node;
            &#x2F;&#x2F; 刷新
            addToHead(node);
            ++size;

            &#x2F;&#x2F; 超出容量
            if (size &gt; capacity) &#123;
                DLinkedNode* removed &#x3D; removeTail();
                cache.erase(removed-&gt;key);
                delete removed;
                --size;
            &#125;
        &#125; else &#123;
            DLinkedNode* node &#x3D; cache[key];
            node-&gt;value &#x3D; value;
            moveToHead(node);
        &#125;
    &#125;

    void addToHead(DLinkedNode* node) &#123;
        node-&gt;prev &#x3D; head;
        node-&gt;next &#x3D; head-&gt;next;
        head-&gt;next &#x3D; node;
        node-&gt;next-&gt;prev &#x3D; node;
    &#125;

    void removeNode(DLinkedNode* node) &#123;
        node-&gt;prev-&gt;next &#x3D; node-&gt;next;
        node-&gt;next-&gt;prev &#x3D; node-&gt;prev;
    &#125;

    void moveToHead(DLinkedNode* node) &#123;
        removeNode(node);
        addToHead(node);
    &#125;

    DLinkedNode* removeTail() &#123;
        DLinkedNode* node &#x3D; tail-&gt;prev;
        removeNode(node);
        return node;
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="环形链表-ii">2023-10-24 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142.环形链表
II</a></h3>
<h4 id="我思-10">我思</h4>
<ol type="1">
<li>快慢指针法</li>
</ol>
<h4 id="实现-10">实现</h4>
<ol type="1">
<li><p><strong>法1</strong>：哈希表法，找到同一节点即为环的入口</p></li>
<li><p><strong>法2</strong>：快慢指针法</p>
<ol type="1">
<li>快指针能追上慢指针，仅能说明有环</li>
<li>而本题我们是要找出环的起点</li>
</ol></li>
<li><p>Code</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    ListNode* detectCycle(ListNode* head) &#123;
        &#x2F;&#x2F; 从头节点出发：
        &#x2F;&#x2F; 快指针走2步，慢指针走一步。
        &#x2F;&#x2F; 重合需要满足的要求：快指针追上慢指针（在环内），快指针刚好超过慢指针n圈环
        ListNode* fast &#x3D; head;
        ListNode* slow &#x3D; head;

        while (true) &#123;
            if (!fast || !(fast-&gt;next)) &#123;
                return nullptr;
            &#125;

            fast &#x3D; fast-&gt;next-&gt;next;
            slow &#x3D; slow-&gt;next;
            if (fast &#x3D;&#x3D; slow) &#123;
                &#x2F;&#x2F; f（快指针步数）；s(慢指针步数)；b(环的步数)
                &#x2F;&#x2F; 在第一次相遇时满足：
                &#x2F;&#x2F; 1. f &#x3D; 2s; (2倍速度)
                &#x2F;&#x2F; 2. f &#x3D; s+nb
                &#x2F;&#x2F; 由以上两式知s&#x3D;nb
                &#x2F;&#x2F; 画个示意图：假设快慢指针在环内的同一点即s+(n-1)b处，则再次相遇快指针要超过慢指针一圈
                break;
            &#125;
        &#125;
        &#x2F;&#x2F; a(链表头结点到环起点的步数)；x（从环起点到当前位置的步数）;k&lt;n(绕环的圈数)
        &#x2F;&#x2F; 1. s &#x3D; nb
        &#x2F;&#x2F; 2. s &#x3D; （n-1）b+a+x
        &#x2F;&#x2F; 因此慢指针在此时的位置（第一次相遇）再走a步必定在环的起始处，
        &#x2F;&#x2F; 如何确定走a步：让另一指针在头节点出发，该指针与慢指针相遇则确定是走了a步
        fast &#x3D; head;
        while (slow !&#x3D; fast) &#123;
            fast &#x3D; fast-&gt;next;
            slow &#x3D; slow-&gt;next;
        &#125;
        return slow;
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="单词拆分">2023-10-11 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/description/">139.单词拆分</a></h3>
<h4 id="我思-11">我思</h4>
<ol type="1">
<li>首字母一样</li>
<li>对每个单词进行字符匹配</li>
</ol>
<h4 id="实现-11">实现</h4>
<ol type="1">
<li><p>一个字符串切分单词的点：j</p></li>
<li><p>确定这是否是个字符串：哈希表</p></li>
<li><p>Code</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;
        &#x2F;&#x2F; 哈希表 方便查找单词是否存在
        unordered_set&lt;string&gt; wordDictSet;
        for (string s : wordDict) &#123;
            wordDictSet.insert(s);
        &#125;

        vector&lt;int&gt; dp(s.size() + 1, 0);
        dp[0] &#x3D; 1;  &#x2F;&#x2F; dp[i] 表示前i个字符能被拆分成现有的单词
        for (int i &#x3D; 1; i &lt;&#x3D; s.size(); i++) &#123;
            for (int j &#x3D; 0; j &lt; i; j++) &#123;  &#x2F;&#x2F; 单词划分点
                if (dp[j] &amp;&amp;
                    wordDictSet.find(s.substr(j, i - j)) !&#x3D; wordDictSet.end()) &#123;
                    dp[i] &#x3D; true;
                    break;
                &#125;
            &#125;
        &#125;
        return dp[s.size()];
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="最长连续序列">2023-10-10 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/description/">128.最长连续序列</a></h3>
<h4 id="我思-12">我思</h4>
<ol type="1">
<li>排序，但不满足O(n)</li>
<li>放在一个数组里，例如：100就放在a[100]，再次遍历找到最长连续序列</li>
</ol>
<h4 id="实现-12">实现</h4>
<ol type="1">
<li><p>Code</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;
        &#x2F;&#x2F; 哈希表
        unordered_set&lt;int&gt; nums_set;
        for (int num : nums) &#123;
            nums_set.insert(num);
        &#125;

        int longestSequence &#x3D; 0;

        for (int num : nums) &#123;
            if (!nums_set.count(num - 1)) &#123;  &#x2F;&#x2F; 确定当前数字为序列的最佳start

                int currentNum &#x3D; num;
                int currentLength &#x3D; 1;  &#x2F;&#x2F; 1而不是0
                while (nums_set.count(currentNum + 1)) &#123;  &#x2F;&#x2F; 为什么时间复杂度一定为O(n),因为两层循环之和才为n
                    currentNum++;
                    currentLength++;
                &#125;
                longestSequence &#x3D; max(longestSequence, currentLength);
            &#125;
        &#125;
        return longestSequence;
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="二叉树展开为链表">2023-10-03 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/">114.二叉树展开为链表</a></h3>
<h4 id="我思-13">我思</h4>
<ol type="1">
<li>递归</li>
<li>构建链表</li>
<li>判断是否为空</li>
</ol>
<h4 id="实现-13">实现</h4>
<ol type="1">
<li><p>法1：前序遍历，存入vector，创建链表</p></li>
<li><p>法2：<code>空间复杂度</code>O(1)。Code</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    void flatten(TreeNode* root) &#123;
        &#x2F;&#x2F; 寻找前驱节点
        TreeNode* cur &#x3D; root;
        
        while (cur) &#123;
            if (cur-&gt;left) &#123;
                TreeNode* curLeft  &#x3D; cur-&gt;left;
                TreeNode* pre &#x3D; curLeft;  &#x2F;&#x2F; 左子树的最右节点
                while (pre-&gt;right) &#123;
                    pre &#x3D; pre-&gt;right;
                &#125;
                pre-&gt;right &#x3D; cur-&gt;right;
                cur-&gt;left &#x3D; nullptr;
                cur-&gt;right &#x3D; curLeft;  
            &#125;
            &#x2F;&#x2F; cur &#x3D; curLeft;  &#x2F;&#x2F; ！x:需要考虑左子树为空，
            cur &#x3D; cur-&gt;right;
        &#125;
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="验证二叉搜索树">2023-10-02 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/description/">98.验证二叉搜索树</a></h3>
<h4 id="我思-14">我思</h4>
<ol type="1">
<li>递归判断
<ol type="1">
<li>左子树 &lt; 根节点 &lt; 右子树</li>
<li>边界情况
<ol type="1">
<li>无子树</li>
</ol></li>
</ol></li>
</ol>
<h4 id="实现-14">实现</h4>
<ol type="1">
<li><p>每一层的递归该实现什么</p>
<ol type="1">
<li>边界条件（递归结束的条件）和 进入下一层递归的代码</li>
<li>考虑参数、返回值</li>
</ol></li>
<li><p>Code</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    bool isValidBST(TreeNode* root) &#123;
        return helper(root, LONG_MIN, LONG_MAX);
    &#125;
    &#x2F;&#x2F; 设计递归
    bool helper(TreeNode* root, long long lower, long long upper) &#123;
        if (root &#x3D;&#x3D; nullptr)
            return true;
        if (root-&gt;val &lt;&#x3D; lower || root-&gt;val &gt;&#x3D; upper)
            return false;
        return helper(root-&gt;left, lower, root-&gt;val) &amp;&amp;
               helper(root-&gt;right, root-&gt;val, upper);
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="不同的二叉搜索树">2023-09-28 <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/description/">96.不同的二叉搜索树</a></h3>
<h4 id="我思-15">我思</h4>
<ol type="1">
<li>根节点确定，接下来的每个节点位置选择多样
<ol type="1">
<li>首先确定节点在树中的深度</li>
<li>确定作为哪个节点的子树</li>
<li>左子树还是右子树</li>
</ol></li>
</ol>
<h4 id="实现-15">实现</h4>
<ol type="1">
<li><p>code</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    int numTrees(int n) &#123;
        vector&lt;int&gt; dp(n + 1, 0);   &#x2F;&#x2F; 考虑n+1，因为dp[0]表示空树
        dp[0] &#x3D; 1;
        dp[1] &#x3D; 1;

        for (int i &#x3D; 2; i &lt; n + 1; i++) &#123;  &#x2F;&#x2F; 子序列长度为i的树的总数;包括n
            for (int j &#x3D; 1; j &lt;&#x3D; i; j++) &#123;  &#x2F;&#x2F; 以j为根节点;j不大于i
                &#x2F;&#x2F; +的原因：需要枚举所有根节点，总和才是总数
                dp[i] +&#x3D; dp[j - 1] * dp[i - j];
            &#125;
        &#125;
        return dp[n];
    &#125;
&#125;;</code></pre></li>
</ol>
<h4 id="单词搜索">2023-09-21：<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/description/">79.单词搜索</a></h4>
<h4 id="我思-16">我思</h4>
<ol type="1">
<li>首先是得定位到相应的首字母，然后相同的首字母可能有多个</li>
<li>其次是从该首字母出发，满足相邻条件的路径很多</li>
<li>感觉挺困难</li>
</ol>
<h4 id="实现-16">实现</h4>
<ol type="1">
<li><p>Code</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;
        int m &#x3D; board.size(), n &#x3D; board[0].size();
        &#x2F;&#x2F; 记录是否访问过
        vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));
        &#x2F;&#x2F; 遍历每个点
        for (int i &#x3D; 0; i &lt; m; ++i)
            for (int j &#x3D; 0; j &lt; n; ++j) &#123;
                &#x2F;&#x2F; 回溯
                if (backTracking(board, visited, word, 0, i, j))
                    return true;
            &#125;
        return false;
    &#125;

   private:
    &#x2F;&#x2F; 回溯
    bool backTracking(vector&lt;vector&lt;char&gt;&gt;&amp; board,
                      vector&lt;vector&lt;bool&gt;&gt;&amp; visited,
                      const string&amp; word,
                      int strCur,
                      int i,
                      int j) &#123;
        if (strCur &#x3D;&#x3D; word.size())
            return true;
        &#x2F;&#x2F; 越界、已访问(形成环状)、不匹配
        if (i &lt; 0 || i &gt;&#x3D; board.size() || j &lt; 0 || j &gt;&#x3D; board[0].size() || visited[i][j] ||
            board[i][j] !&#x3D; word[strCur])
            return false;
        visited[i][j] &#x3D; true;
        if (backTracking(board, visited, word, strCur + 1, i - 1, j) ||
            backTracking(board, visited, word, strCur + 1, i + 1, j) ||
            backTracking(board, visited, word, strCur + 1, i, j - 1) ||
            backTracking(board, visited, word, strCur + 1, i, j + 1))
            return true;
        visited[i][j] &#x3D; false;
        return false;
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="颜色分类">2023-09-20：<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/description/">75.
颜色分类</a></h3>
<h4 id="我思-17">我思</h4>
<ol type="1">
<li>双指针法，但我觉得这题得三指针法</li>
<li>确定两种元素的位置，剩下一种也就确认了</li>
</ol>
<h4 id="实现-17">实现</h4>
<ol type="1">
<li><p>Code:确定一头一尾</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    void sortColors(vector&lt;int&gt;&amp; nums) &#123;
        &#x2F;&#x2F; 双指针法
        int p0 &#x3D; 0, p2 &#x3D; nums.size() - 1;
        for (int i &#x3D; 0; i &lt;&#x3D; p2; i++) &#123;
            while (i &lt;&#x3D; p2 &amp;&amp; nums[i] &#x3D;&#x3D; 2) &#123;
                swap(nums[i], nums[p2--]);
            &#125;
            if (nums[i] &#x3D;&#x3D; 0) &#123;
                swap(nums[i], nums[p0++]);
            &#125;
        &#125;
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="最小路径和">2023-09-19：<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/description/">64.最小路径和</a></h3>
<h4 id="我思-18">我思</h4>
<ol type="1">
<li>dp 或者回溯，（回溯太久没接触，忘了）</li>
</ol>
<h4 id="实现-18">实现</h4>
<ol type="1">
<li><p>两层for循环都不会写了</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        &#x2F;&#x2F; dp；每次只能向右或者向下
        &#x2F;&#x2F; 误区：每次选最小路径去走，最终到右下角不一定是最小路径
        &#x2F;&#x2F; 但是此位置的最小路径
        &#x2F;&#x2F; 前一步一定是从上一步的更小路径走出来的，因此我们仍然是计算每个格子的最小
        &#x2F;&#x2F; 最后从右下角的相邻两位置 选择更小的那个

        if (grid.empty())
            return 0;
        int row &#x3D; grid.size(), column &#x3D; grid[0].size();
        vector&lt;vector&lt;int&gt;&gt; dp(row, vector&lt;int&gt;(column, 0));

        &#x2F;&#x2F; 初始化
        dp[0][0] &#x3D; grid[0][0];
        for (int i &#x3D; 1; i &lt; row; ++i)
            dp[i][0] &#x3D; dp[i - 1][0] + grid[i][0];
        for (int j &#x3D; 1; j &lt; column; ++j)
            dp[0][j] &#x3D; dp[0][j - 1] + grid[0][j];
        for (int i &#x3D; 1; i &lt; row; ++i)
            for (int j &#x3D; 1; j &lt; column; ++j)
                dp[i][j] &#x3D; min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        return dp[row - 1][column - 1];
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="不同路径">2023-09-14： <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/description/">62.
不同路径</a></h3>
<h4 id="我思-19">我思</h4>
<ol type="1">
<li>一个变量记录符合的路径数</li>
<li>需要保存前面走过的路径，而在每一步，接下来都有多个走法，一步步试探？</li>
</ol>
<h4 id="实现-19">实现</h4>
<ol type="1">
<li>认识和抓住问题</li>
<li>识破问题本质</li>
<li>观察、发现规律（共性）</li>
</ol>
<hr />
<ol type="1">
<li><p>排列组合（代码没懂）</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    int uniquePaths(int m, int n) &#123;
        &#x2F;&#x2F; 排列组合
        &#x2F;&#x2F; 从左上角到右下角，一共需要走 m+n-2 步，其中 m-1 步向下，n-1 步向右
        &#x2F;&#x2F; 一共有 C(m+n-2, m-1) 种走法
        &#x2F;&#x2F; 确定了哪些步数是向下的，自然就确定了路线

        &#x2F;&#x2F; 计算C(m+n-2, m-1) 
        &#x2F;&#x2F; 由于 m+n-2 和 m-1 都不大，所以可以直接计算
        &#x2F;&#x2F; 但是如果 m+n-2 和 m-1 很大，就会溢出

        long ans &#x3D; 1;
        for (int x &#x3D; n, y &#x3D; 1; y &lt; m; ++x, ++y) &#123;
            ans &#x3D; ans * x &#x2F; y;
        &#125;
        return ans;
    &#125;
&#125;;</code></pre></li>
<li><p>dp: 很好理解</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    int uniquePaths(int m, int n) &#123;
        &#x2F;&#x2F; 动态规划
        &#x2F;&#x2F; dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]
        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));
        &#x2F;&#x2F; 初始化
        for (int i &#x3D; 0; i &lt; m; i++) &#123;
            dp[i][0] &#x3D; 1;
        &#125;
        &#x2F;&#x2F; 初始化
        for (int j &#x3D; 0; j &lt; n; j++) &#123;
            dp[0][j] &#x3D; 1;
        &#125;
        &#x2F;&#x2F; 递推
        for (int i &#x3D; 1; i &lt; m; i++) &#123;
            for (int j &#x3D; 1; j &lt; n;j++)&#123;
                dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1];
            &#125;
        &#125;
        return dp[m - 1][n - 1];
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="合并区间">2023-09-13： <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/description/">56.
合并区间</a></h3>
<h3 id="我思-20">我思</h3>
<ol type="1">
<li><p>排序：依据左端点值</p></li>
<li><p>合并重合区间：数轴画图直观表示 <span class="math display">\[
[a_j,a_k],[a_l,a_m]\\
1.\ 必有a_l&gt;=a_j\\
2.\ 如果a_l&lt;=a_k,那么两区间必定能合并
\]</span></p></li>
</ol>
<h4 id="实现-20">实现</h4>
<ol type="1">
<li><p>主要是合并的判断</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;
        &#x2F;&#x2F; 结果集
        vector&lt;vector&lt;int&gt;&gt; ans;
        &#x2F;&#x2F; 边界处理
        if (intervals.size() &#x3D;&#x3D; 0) &#123;
            return ans;
        &#125;

        &#x2F;&#x2F; 依据子区间左值排序
        sort(intervals.begin(), intervals.end());
        int left &#x3D; intervals[0][0], right &#x3D; intervals[0][1];
        for (int i &#x3D; 1; i &lt; intervals.size(); i++) &#123;
            &#x2F;&#x2F; 如果当前区间的左值小于等于上一个区间的右值，说明有重叠
            if (intervals[i][0] &lt;&#x3D; right) &#123;
                &#x2F;&#x2F; 更新右值
                right &#x3D; max(right, intervals[i][1]);
            &#125; else &#123;
                &#x2F;&#x2F; 没有重叠，将上一个区间加入结果集
                ans.push_back(&#123;left, right&#125;);
                &#x2F;&#x2F; 更新左右值
                left &#x3D; intervals[i][0];
                right &#x3D; intervals[i][1];
            &#125;
        &#125;
        &#x2F;&#x2F; 最后一个子区间处理后需要加入结果集
        ans.push_back(&#123;left, right&#125;);
        return ans;
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="跳跃游戏">2023-09-12：<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/description/">55.
跳跃游戏</a></h3>
<h4 id="我思-21">我思</h4>
<ol type="1">
<li>每走一步，都能够确定目前的活动范围，所以范围之内，在其他的下标处，需要确定新的活动范围，但是都需要计算，但是<code>O(n)</code>已经不错了</li>
</ol>
<h4 id="实现-21">实现</h4>
<ol type="1">
<li><p>其实代码还是蛮简单</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    bool canJump(vector&lt;int&gt;&amp; nums) &#123;
        &#x2F;&#x2F; 能够到达的最右位置
        int enableMostRight &#x3D; 0;

        &#x2F;&#x2F; 一次遍历:O(n)
        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;
            &#x2F;&#x2F; 取等号
            if (i &lt;&#x3D; enableMostRight) &#123;
                &#x2F;&#x2F; 在最右范围内更新最右值
                enableMostRight &#x3D; max(enableMostRight, nums[i] + i);
            &#125; else &#123;
                &#x2F;&#x2F; 超出了目前的最右位置
                return false;
            &#125;
        &#125;
        &#x2F;&#x2F; 遍历完所有元素，自然能够到达最后一个位置
        return true;
    &#125;
&#125;;</code></pre></li>
</ol>
<h3 id="字母异位词分组">2023-05-14: <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">49.
字母异位词分组</a></h3>
<blockquote>
<p>失踪人口回归</p>
</blockquote>
<ul>
<li><p><strong>我思</strong></p>
<p><code>字母异位词</code>的特点：每个单词具有相同的字母，只是顺序不一样。如果将他们排序，就会是同一个单词。</p>
<p><strong>但是</strong>我没想到好的处理方式，事实上我们可以将这个排序（唯一）的词作为<code>key</code>,而用一个<code>vector&lt;string&gt;</code>作为值而存储</p></li>
<li><p>法1：<strong>排序</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;
        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;
        for (string&amp; str: strs) &#123;
            string key &#x3D; str;
            sort(key.begin(), key.end());
            mp[key].emplace_back(str);
        &#125;
        vector&lt;vector&lt;string&gt;&gt; res;
        &#x2F;&#x2F; [_, v] 是一个 C++17 中引入的结构化绑定（Structured
        &#x2F;&#x2F; Binding）的语法。它的作用是将 mp
        &#x2F;&#x2F; 中的元素解包成两个变量，第一个变量是占位符
        &#x2F;&#x2F; _，表示忽略掉键值对中的键，第二个变量 v
        &#x2F;&#x2F; 则表示键值对中的值。
        for (auto&amp; [_, v] : mp) &#123;
            res.emplace_back(v);
        &#125;
        return res;
    &#125;
&#125;;</code></pre>
<figure>
<img src="https://s2.loli.net/2023/05/14/4f3qECMXYAQvRDZ.png"
alt="image-20230514160154371" />
<figcaption aria-hidden="true">image-20230514160154371</figcaption>
</figure></li>
<li><p>法2：<strong>计数</strong></p>
<p>难以理解的代码:我选择法1</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;
        &#x2F;&#x2F; 自定义对 array&lt;int, 26&gt; 类型的哈希函数
        auto arrayHash &#x3D; [fn &#x3D; hash&lt;int&gt;&#123;&#125;] (const array&lt;int, 26&gt;&amp; arr) -&gt; size_t &#123;
            return accumulate(arr.begin(), arr.end(), 0u, [&amp;](size_t acc, int num) &#123;
                return (acc &lt;&lt; 1) ^ fn(num);
            &#125;);
        &#125;;

        unordered_map&lt;array&lt;int, 26&gt;, vector&lt;string&gt;, decltype(arrayHash)&gt; mp(0, arrayHash);
        for (string&amp; str: strs) &#123;
            array&lt;int, 26&gt; counts&#123;&#125;;
            int length &#x3D; str.length();
            for (int i &#x3D; 0; i &lt; length; ++i) &#123;
                counts[str[i] - &#39;a&#39;] ++;
            &#125;
            mp[counts].emplace_back(str);
        &#125;
        vector&lt;vector&lt;string&gt;&gt; ans;
        for (auto it &#x3D; mp.begin(); it !&#x3D; mp.end(); ++it) &#123;
            ans.emplace_back(it-&gt;second);
        &#125;
        return ans;
    &#125;
&#125;;</code></pre></li>
</ul>
<h3 id="旋转图像">2023-02-12：<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h3>
<ul>
<li><p>我思</p>
<ul>
<li>原地操作（只能采用交换）</li>
<li>对二维数组的操作</li>
<li>我感觉是个找规律题：甚至我尝试把坐标变换列出来，去找规律，但是不行
<ul>
<li>变化步数和（列变+行变）＝n</li>
</ul></li>
<li>事实上：旋转90度，可我们直接把原先的列当成行去读，就是旋转后的答案，但是<strong>原地操作</strong></li>
<li></li>
<li>从几何视角看：直线角度变化
<ul>
<li>从中间到外围是一个个正方形</li>
</ul></li>
</ul></li>
<li><p>参考</p>
<ul>
<li>事实上就是找规律</li>
<li>关于矩阵的知识联想：转置，对称。(正好是容易进行的操作）</li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
        &#x2F;&#x2F; 00 02    10 01   20 00
        &#x2F;&#x2F; 01 12    11 11   21 12
        &#x2F;&#x2F; 02 22    12 21   22 20

        &#x2F;&#x2F; 00 03    01 13   02 23   03 33
        &#x2F;&#x2F; 10 02    11 12   12 22
        &#x2F;&#x2F;

        &#x2F;&#x2F; 规律就是转置+镜像(纵向)对称

        &#x2F;&#x2F; 转置：限定j&lt;i 或 i &lt; j
        for (int i &#x3D; 0; i &lt; matrix.size(); ++i) &#123;
            for (int j &#x3D; 0; j &lt; i; j++) &#123;
                swap(matrix[i][j], matrix[j][i]);
            &#125;
        &#125;

        &#x2F;&#x2F; 对称
        for (int i &#x3D; 0; i &lt; matrix.size(); i++) &#123;
            for (int j &#x3D; 0; j &lt; matrix.size() &#x2F; 2; j++) &#123;
                swap(matrix[i][j], matrix[i][matrix.size() - 1 - j]);
            &#125;
        &#125;
    &#125;
&#125;;</code></pre></li>
</ul>
<h3 id="全排列">2022-01-23：<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h3>
<ul>
<li><p>我思</p>
<ul>
<li>回溯</li>
<li>问题是：取出第一个数字后，如何取出剩余其它数字</li>
</ul></li>
<li><p>参考：</p>
<ul>
<li>方法正确</li>
<li>解决我思的问题：
<ul>
<li>法1：标记法</li>
<li>法2：数组分割交换</li>
</ul></li>
</ul></li>
<li><p>submit</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    &#x2F;&#x2F; 回溯法
    &#x2F;&#x2F; 标记数组
    vector&lt;int&gt; path;
    vector&lt;vector&lt;int&gt;&gt; ans;
    void backTrace(vector&lt;int&gt; nums,vector&lt;bool&gt;flag) &#123;
        if (path.size() &#x3D;&#x3D; nums.size()) &#123;
            ans.emplace_back(path);
            return;
        &#125;

        for(int i &#x3D; 0; i &lt; nums.size(); ++i) &#123; 
            if(!flag[i]) &#123;  &#x2F;&#x2F; 没被标记则可使用
                path.emplace_back(nums[i]);
                flag[i] &#x3D; true;
                backTrace(nums,flag);
                path.pop_back();
                flag[i] &#x3D; false;        &#x2F;&#x2F; 这句 必须加
            &#125;
        &#125;
    &#125;
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;bool&gt;flag (nums.size(),false);
        backTrace(nums, flag);
        return ans; 
    &#125;
&#125;;</code></pre>
<figure>
<img src="https://s2.loli.net/2023/01/25/sAe9u5NWUXcJT7w.png"
alt="image-20230125192151573" />
<figcaption aria-hidden="true">image-20230125192151573</figcaption>
</figure></li>
</ul>
<h3 id="搜索旋转排序数组">2022-01-21: <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33.
搜索旋转排序数组</a></h3>
<ul>
<li>我思
<ul>
<li>一开始没看懂题目，总感觉它想让我们求旋转后的数组</li>
<li>结果是考查找</li>
<li>然后把时间复杂度要求O(log n )看成了O(n)</li>
<li>根据时间复杂度O(log n )很容易联想到二分查找</li>
<li>二分查找要求有序，旋转数组后数组分成两段分别有序，那么如何找到这个分界点是一个问题。</li>
</ul></li>
<li>参考
<ul>
<li>旋转后的数组必定：一部分有序，另一部分无序或有序；难以理解。</li>
<li>并且如果mid 小于right,则这部分必定有序</li>
<li>以上两条结论是如何解释</li>
</ul></li>
<li>submit</li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        int left &#x3D; 0;
        int right &#x3D; nums.size() - 1;

        &#x2F;&#x2F; 总的来说比起常规
        while (left &lt; right) &#123;
            int mid &#x3D; (left + right) &gt;&gt; 1;
            if (nums[mid] &#x3D;&#x3D; target) &#123;
                return mid;
            &#125;

            if (nums[left] &lt;&#x3D; nums[mid]) &#123;    &#x2F;&#x2F; 前半段有序
                if (target &gt;&#x3D; nums[left] &amp;&amp; target &lt; nums[mid]) &#123;    &#x2F;&#x2F; 先查找前半段;注意等号
                    right &#x3D; mid - 1;
                &#125; else &#123;    &#x2F;&#x2F; 在后半段查找
                    left &#x3D; mid + 1;
                &#125;
            &#125; else &#123;    &#x2F;&#x2F; 后半段有序
                if(target &gt; nums[mid] &amp;&amp; target &lt;&#x3D; nums[right]) &#123;    &#x2F;&#x2F; 先查找后半段
                    left &#x3D; mid + 1;
                &#125; else &#123;    &#x2F;&#x2F; 在前半段查找
                    right &#x3D; mid - 1;
                &#125;

            &#125;
        &#125;
        return nums[left] &#x3D;&#x3D; target ? left : -1;
    &#125;
&#125;;</code></pre>
<figure>
<img src="https://s2.loli.net/2023/01/21/P8WAcpr6adluZLK.png"
alt="image-20230121155254016" />
<figcaption aria-hidden="true">image-20230121155254016</figcaption>
</figure>
<h3 id="下一个排列">2022-01-18: <a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/">31.
下一个排列</a></h3>
<ul>
<li>我思：
<ul>
<li>按题意：将所有的数字排列进行排序并构成一个循环，下一个排列就是按大小排在后一位的排列。</li>
<li>一个条件：必须原地修改，且是常数空间</li>
<li>我猜是：交换。
<ul>
<li>但是这个交换规则应该是怎样呢。</li>
<li>注意到：他们的排序，实质就是转化为：从左到右，将数字放在相应的百十个位上形成的值。</li>
<li>一个特殊情况是：最大-》最小是一种特殊情况:
<ul>
<li>其实这种情况可以理解为正序，则我们将它逆序即为所求。</li>
</ul></li>
<li>忽然想到一个词：正序。
<ul>
<li>那么找到第一个正序（这个正序的交换得到的结果得是最小），并将他们进行交换即是所求。</li>
</ul></li>
</ul></li>
</ul></li>
<li>参考：
<ul>
<li>看了题解，我的思路是正确的。但还需要修补：</li>
<li>首先，除了对发现的第一个逆序进行交换外，对他们之间的数字应该进行一次排序。可以确保在大于前一个排序后，这个排列还可能尽可能的小。即能满足下一个排列</li>
<li>其次，又是双指针法</li>
</ul></li>
<li>submit</li>
<li>以下不能保证left &gt;= 0</li>
</ul>
<figure>
<img src="https://s2.loli.net/2023/01/19/S1VuI6BoCOx4nmy.png"
alt="image-20230119010340407" />
<figcaption aria-hidden="true">image-20230119010340407</figcaption>
</figure>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;
        &#x2F;&#x2F; 双指针遍历
        for (int left &#x3D; nums.size() - 2; left &gt;&#x3D; 0; left--) &#123;
            for (int right &#x3D; nums.size() - 1; right &gt; left; right--) &#123;    &#x2F;&#x2F; 是否考虑数组只有一个数字
                if (nums[left] &lt; nums[right]) &#123;
                    swap(nums[left], nums[right]);
                    sort(nums.begin() + left + 1, nums.end());
                    return;
                &#125;
            &#125;
        &#125;
        reverse(nums.begin(), nums.end());
    &#125;
&#125;;</code></pre>
<figure>
<img src="https://s2.loli.net/2023/01/19/osqg5QPNem6SAuU.png"
alt="image-20230119011004353" />
<figcaption aria-hidden="true">image-20230119011004353</figcaption>
</figure>
<h3 id="section">2022-01-16</h3>
<h4 id="括号生成"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">22.
括号生成</a></h4>
<ul>
<li><p>我思：</p>
<ul>
<li><p>全部有效的括号，如何分类：可以根据括号嵌套层数，最深层数=n</p></li>
<li><p>还有个不同层数排序的问题：涉及数字的拆解，</p>
<ul>
<li>n = 5,（用最高层数限定，且必有这个最高层数）
<ul>
<li>5
<ul>
<li>5*1</li>
</ul></li>
<li>4(4,1)
<ul>
<li>4+1</li>
<li>1+4</li>
</ul></li>
<li>3（3,2,1）
<ul>
<li>3+2</li>
<li>2+3</li>
<li>3+1+1</li>
<li>1+3+1</li>
<li>1+1+3</li>
</ul></li>
<li>2（1,2）
<ul>
<li>2+1+1+1</li>
<li>1+2+1+1</li>
<li>1+1+2+1</li>
<li>1+1+1+2</li>
</ul></li>
<li>1
<ul>
<li>1+1+1+1+1</li>
</ul></li>
</ul></li>
<li>上面分类是错误的。还有可能这种情况：最深两层，但是第二层有两个并列的一层</li>
<li>因此什么算法能包含所有情况呢：我认为回溯法</li>
</ul></li>
<li><p>参考</p>
<ul>
<li>回溯法确实对的；问题是，我不知道递归单层该完成的任务</li>
<li>规则是：每层先尝试添加左括号，直到左括号不能添加为止再添加右括号。</li>
<li>那么递归终止条件是什么：
<ul>
<li>可用括号数量不够</li>
<li>使用的右括号数量超过了左括号</li>
</ul></li>
</ul></li>
<li><p>submit</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    vector&lt;string&gt; generateParenthesis(int n) &#123;
        vector&lt;string&gt; ans;
        string path;
        backTrace(ans, path, 0, 0, n);    &#x2F;&#x2F; path 直接放空也行
        return ans;
    &#125;

    &#x2F;&#x2F; ans 得是引用
    &#x2F;&#x2F; left 是已用还是剩余需明确
    void backTrace(vector&lt;string&gt;&amp; ans, string path, int left, int right, int n) &#123;
        if (left &gt; n || right &gt; n || right &gt; left) &#123;    &#x2F;&#x2F; 递归终止条件
            return;
        &#125;

        if (left &#x3D;&#x3D; n &amp;&amp; right &#x3D;&#x3D; n) &#123;    &#x2F;&#x2F; 压入返回值的条件(全部括号得用完，且左右相等)
            ans.push_back(path);
            return;     &#x2F;&#x2F; 压入之后返回上一层 
        &#125;

        &#x2F;&#x2F; 路径的生成在传参时完成
        &#x2F;&#x2F; path 参数需要特别注意不能用引用，且使用加法更不会出错，因为返回上一层时，path的值还得是上一层的值，而不能是下一层的值
        backTrace(ans, path + &quot;(&quot;, left + 1, right, n);
        backTrace(ans, path + &quot;)&quot;, left, right + 1, n);
    &#125;
&#125;;</code></pre>
<figure>
<img src="https://s2.loli.net/2023/01/16/YBOfm2SCD7kxAWM.png"
alt="image-20230116222246838" />
<figcaption aria-hidden="true">image-20230116222246838</figcaption>
</figure></li>
<li><p>dfs （回溯）</p></li>
<li><p>注意它括号的添加规则</p></li>
<li><p>注意到回溯，其实这确实也是一个从所有子集中选取符合条件子集的类型</p></li>
</ul></li>
</ul>
<h3 id="section-1">2022-01-14</h3>
<h4 id="电话号码的字母组合"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17.
电话号码的字母组合</a></h4>
<ul>
<li>我思：
<ol type="1">
<li>列出数字与字母的映射</li>
<li>注意有多少个数字，组合的字母串就有多长</li>
<li>多重循环。（如果数字多是不是会超时）add:另外循环层数不确定，代码是写不出来的
<ul>
<li>到此，我判断我的思路错误</li>
</ul></li>
</ol></li>
<li>递归三要素
<ol type="1">
<li>确定递归函数的参数和返回值</li>
<li>确定终止条件</li>
<li>确定单层递归的逻辑</li>
</ol></li>
<li>回溯三要素（代表性问题：集合中取满足条件的子集）
<ol type="1">
<li>回溯函数参数和返回值</li>
<li>回溯函数终止条件</li>
<li>回溯搜索的遍历（for循环 横向遍历，递归（回溯）纵向遍历）</li>
</ol></li>
<li>参考</li>
<li>submit</li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   private:
    const string s[10] &#x3D; &#123;
        &quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;,
    &#125;;

   public:
    vector&lt;string&gt; ans;
    string path;
    void backtracking(string digits, int level) &#123;
        if (level &#x3D;&#x3D; digits.size()) &#123;    &#x2F;&#x2F; 终止条件：纵向遍历完(每条分支)
            ans.push_back(path);
            return; &#x2F;&#x2F; 返回上一层
        &#125;

        int digit &#x3D; digits[level] - &#39;0&#39;;
        for (int i &#x3D; 0; i &lt; s[digit].size(); ++i) &#123;
            path.push_back(s[digit][i]);
            &#x2F;&#x2F; backtracking(digits, ++level);   &#x2F;&#x2F; ++level的执行时间(所在层数)，这是错误的
            backtracking(digits, level+1);     &#x2F;&#x2F; 返回上一层后，level的值还是本层的值，不会加一
            path.pop_back();    &#x2F;&#x2F; 回溯，弹出最后一层
        &#125;
    &#125;

    vector&lt;string&gt; letterCombinations(string digits) &#123;
        if (digits.size() &#x3D;&#x3D; 0) &#123;
            return ans;
        &#125;

        backtracking(digits,0);
        return ans;
    &#125;
&#125;;</code></pre>
<ul>
<li>注意这个问题</li>
</ul>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; backtracking(digits, ++level);   &#x2F;&#x2F; ++level的执行时间(所在层数)，这是错误的
backtracking(digits, level+1);     &#x2F;&#x2F; 返回上一层后，level的值还是本层的值，不会加一</code></pre>
<figure>
<img src="https://s2.loli.net/2023/01/14/6elTax8Eyf2rYuh.png"
alt="image-20230114032944436" />
<figcaption aria-hidden="true">image-20230114032944436</figcaption>
</figure>
<h3 id="section-2">2022-01-13</h3>
<h4 id="三数之和"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">15.
三数之和</a></h4>
<ul>
<li>我的思路
<ul>
<li>排序效果应该不错</li>
<li>参考双指针，采用三指针（<del>定2移1</del>）：这里我错了，因此陷入了一个胡同。因为双指针不需要固定指针，因此三指针应该是定1移2。</li>
</ul></li>
<li>参考思路
<ul>
<li>看了下评论区，果然不出所料</li>
<li>问题在于如何移动指针，其实还是类似双指针
<ul>
<li>固定左指针，移动中指针和右指针（将三指针转化为双指针）</li>
</ul></li>
<li>还注意到 有 <code>哈希-剪枝法</code></li>
</ul></li>
<li>submit</li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;
        sort(nums.begin(), nums.end());    &#x2F;&#x2F; 先排序
        vector&lt;vector&lt;int&gt;&gt; ans;
        int left &#x3D; 0;
        int mid;
        int right &#x3D; nums.size() - 1;
        if (nums[left] &gt; 0 || nums[right] &lt; 0) &#123;
            return ans;
        &#125;

        &#x2F;&#x2F; 每次固定左指针，最中、右指针处理
        for (left; left &lt; nums.size() - 2; left++) &#123;
            if(left !&#x3D; 0 &amp;&amp; nums[left] &#x3D;&#x3D; nums[left-1]) &#123;   &#x2F;&#x2F; left 也得去重
                continue;   &#x2F;&#x2F; 不是break
            &#125;

            &#x2F;&#x2F; left 移动，则mid,right重置
            mid &#x3D; left + 1;
            right &#x3D; nums.size() - 1;

            while (mid &lt; right) &#123;
                if (nums[left] + nums[mid] + nums[right] &gt; 0) &#123;
                    right--;
                &#125; else if (nums[right] + nums[mid] + nums[left] &lt; 0) &#123;
                    mid++;
                &#125; else &#123;
                    ans.push_back(vector&lt;int&gt;&#123;nums[left], nums[mid], nums[right]&#125;);

                    &#x2F;&#x2F;  去重
                    &#x2F;&#x2F; mid 先去重
                    mid++;
                    while (mid &lt; right &amp;&amp; nums[mid] &#x3D;&#x3D; nums[mid - 1]) &#123;
                        mid++;
                    &#125;

                    right--;
                    while (mid &lt; right &amp;&amp; nums[right] &#x3D;&#x3D; nums[right + 1]) &#123;
                        right--;
                    &#125;

                &#125;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;</code></pre>
<figure>
<img src="https://s2.loli.net/2023/01/13/f2U3YDbKH87xnRt.png"
alt="image-20230113040033052" />
<figcaption aria-hidden="true">image-20230113040033052</figcaption>
</figure>
<ul>
<li><ul>
<li>效率这么低</li>
<li>但是暂时不折腾了</li>
</ul></li>
<li>一题做了一晚上，天亮了，牛批
<ul>
<li>脑子出问题了，没法debug，提交了多次错误的。（提交正确率今晚可降了不少
:sob:</li>
</ul></li>
</ul>
<figure>
<img src="https://s2.loli.net/2023/01/13/JoInHm3p5qFU9lr.png"
alt="image-20230113040338308" />
<figcaption aria-hidden="true">image-20230113040338308</figcaption>
</figure>
<h3 id="section-3">2022-01-12</h3>
<h4 id="盛最多水的容器"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/">11.
盛最多水的容器</a></h4>
<ul>
<li><strong>我的思路</strong>
<ul>
<li>分析：容积以两轴中短轴为准
<ul>
<li>两根轴要尽可能远，且短轴尽可能高，能保证最大容积。但是显然最优解不一定要同时满足这两个条件。</li>
<li>这个问题本质是确定两个边界</li>
<li>问题是：如何确定这两个边界呢，暴力解法O(n²)不考虑</li>
<li>两个边界很容易联想到<strong>双指针</strong></li>
<li>双指针的移动规则怎么确定呢，是否要遍历每一种情况呢（显然不要，不然不就是暴力吗）</li>
</ul></li>
</ul></li>
<li><strong>参考答案</strong>
<ul>
<li>两个边界肯定不是同时移动，那么就是一次移动一个</li>
<li>每次不管左移还是右移，底边都是-1，因此得确保高尽量高，也就是长轴保持，移动短轴寻找更长轴</li>
<li>不容易注意到的一个问题是：如果要保证之后的结果比现在更大，那么最短轴一定要更长（因为底边再减小），也就是说每次移动，最短轴一定要变化。<strong>如果最短轴不变，那么这次移动是无效的。</strong></li>
</ul></li>
<li><strong>submit</strong></li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    int maxArea(vector&lt;int&gt;&amp; height) &#123;
        int left &#x3D; 0;
        int right &#x3D; height.size() - 1;
        int ans &#x3D; 0;
        while (left &lt; right) &#123;
            ans &#x3D; max(ans, (right - left) * min(height[left], height[right]));
            if (height[left] &lt; height[right]) &#123;
                left++;
            &#125; else &#123;
                right--;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;</code></pre>
<figure>
<img src="https://s2.loli.net/2023/01/12/1wToSpzrQuWtLyq.png"
alt="image-20230112012322777" />
<figcaption aria-hidden="true">image-20230112012322777</figcaption>
</figure>
<h3 id="section-4">2022-12-28</h3>
<h4 id="删除字符串两端相同字符后的最短长度"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/">1750.
删除字符串两端相同字符后的最短长度</a></h4>
<ul>
<li><p>我的思路：无</p></li>
<li><p>分析：</p>
<ul>
<li>双指针法</li>
<li>不能有交集：left &lt; right</li>
<li>边界处理
<ul>
<li>s长度为1：无法删除</li>
</ul></li>
</ul></li>
<li><p>submit</p></li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    int minimumLength(string s) &#123;    &#x2F;&#x2F; 双指针法
        if (s.length() &lt;&#x3D; 1) &#123;
            return s.length();
        &#125;
        int left &#x3D; 0;
        int right &#x3D; s.length() - 1;
        while (left &lt; right &amp;&amp; s[left] &#x3D;&#x3D; s[right]) &#123;
                left++;
                while (left &lt; right &amp;&amp; s[left - 1] &#x3D;&#x3D; s[left]) &#123;    &#x2F;&#x2F; 删除左边的全部
                    left++;
                &#125;
                right--;
                while (left &lt; right &amp;&amp; s[right + 1] &#x3D;&#x3D; s[right]) &#123;    &#x2F;&#x2F; 删除右边的全部
                    right--;
                &#125;
            &#125;
            return right - left + 1;
        &#125;
&#125;;</code></pre>
<h3 id="section-5">2022-12-27</h3>
<h4 id="找到所有数组中消失的数字"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/">448.
找到所有数组中消失的数字</a></h4>
<ul>
<li>自己没有特别好的思路</li>
<li>我的第一思路：遍历一遍数组，记录每个数字出现的次数</li>
</ul>
<pre class="language-none"><code class="language-none">nums &#x3D; [4,3,2,7,8,2,3,1]</code></pre>
<p>例如上述数组：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">数组s[n]&#x3D;&#123;0,0,0,0,0,0,0.....,0&#125;;
s[4]++;
s[3]++;
s[2]++</code></pre>
<p>最后统计值为0的下标</p>
<ul>
<li>评论区看到的巧妙解法</li>
</ul>
<figure>
<img src="https://s2.loli.net/2022/12/26/qBLNDi9wk1AvSl4.png"
alt="image-20221226235202663" />
<figcaption aria-hidden="true">image-20221226235202663</figcaption>
</figure>
<blockquote>
<ul>
<li>本质上还是将研究的那一串数字，作为下标去研究，此解法是做标记（正负数区分）</li>
</ul>
</blockquote>
<ul>
<li>submit</li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
   public:
    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;
        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;
            nums[abs(nums[i]) - 1] &#x3D; -abs(nums[abs(nums[i]) - 1]); &#x2F;&#x2F; 取绝对值的原因在于有些数字会重复出现，第一次出现就会更改为负数，而负数不能作为下标
        &#125;
        vector&lt;int&gt; result;
        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;
            if (nums[i] &gt; 0) &#123;
                result.push_back(i + 1);    &#x2F;&#x2F; 这里是i+1
            &#125;
        &#125;
        return result;
    &#125;
&#125;;</code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Jf710001011</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://Jf710001011.github.io/2022/12/27/leetcode-zhi-lu/">https://Jf710001011.github.io/2022/12/27/leetcode-zhi-lu/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="/about" target="_blank">Jf710001011</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/C/">
                                    <span class="chip bg-color">C++</span>
                                </a>
                            
                                <a href="/tags/Python/">
                                    <span class="chip bg-color">Python</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'U2qj9LBn7UhJFyVyb1bYDa9w-gzGzoHsz',
        appKey: 'Tg6wRvRlIfODtULeHu4P96zh',
        notify: 'true' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'en',
        placeholder: 'just go go'
    });
</script>

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2023/01/18/php/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="php">
                        
                        <span class="card-title">php</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            语法、函数
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-01-18
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Programming-Design/" class="post-category">
                                    Programming Design
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/php/">
                        <span class="chip bg-color">php</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/12/20/web-dvwa/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="DVWA">
                        
                        <span class="card-title">DVWA</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            dvwa靶场
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-12-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Cybersecurity/" class="post-category">
                                    Cybersecurity
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Web/">
                        <span class="chip bg-color">Web</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>



                            <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023</span>
            
            <span id="year">2023</span>
            <a href="/about" target="_blank">Jf71o0x1o1l</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">238.7k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2023";
                    var startMonth = "2";
                    var startDate = "16";
                    var startHour = "24";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
            <span id="icp"><img src="/medias/icp.png" style="vertical-align: text-bottom;" />
                <a href="/null" target="_blank">津ICP备Jf710001011号</a>
            </span>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Jf710001011" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:lhhyp2333@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


                                <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

                                    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


                                        <script
                                            src="/libs/materialize/materialize.min.js"></script>
                                        <script
                                            src="/libs/masonry/masonry.pkgd.min.js"></script>
                                        <script
                                            src="/libs/aos/aos.js"></script>
                                        <script
                                            src="/libs/scrollprogress/scrollProgress.min.js"></script>
                                        <script
                                            src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
                                        <script
                                            src="/js/matery.js"></script>

                                        <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

                                            <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

                                                
                                                    <script
                                                        src="/libs/others/clicklove.js"
                                                        async="async"></script>
                                                    
                                                        
                                                            <script async
                                                                src="/libs/others/busuanzi.pure.mini.js"></script>
                                                            

                                                                

                                                                        

                                                                                
                                                                                        
                                                                                            <script
                                                                                                type="text/javascript"
                                                                                                color="0,0,255"
                                                                                                pointColor="0,0,255"
                                                                                                opacity='0.7'
                                                                                                zIndex="-1"
                                                                                                count="99"
                                                                                                src="/libs/background/canvas-nest.js"></script>
                                                                                            

                                                                                                

                                                                                                            
                                                                                                                <script
                                                                                                                    type="text/javascript"
                                                                                                                    src="/libs/background/ribbon-dynamic.js"
                                                                                                                    async="async"></script>
                                                                                                                

                                                                                                                    
                                                                                                                        <script
                                                                                                                            src="/libs/instantpage/instantpage.js"
                                                                                                                            type="module"></script>
                                                                                                                        
                                                                                                                            <script
                                                                                                                                type="text/javascript">
                                                                                                                                    //只在桌面版网页启用特效
                                                                                                                                    var windowWidth = $(window).width();
                                                                                                                                    if (windowWidth > 768) {
                                                                                                                                        document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>');
                                                                                                                                    }
                                                                                                                                </script>
                </body>

</html>