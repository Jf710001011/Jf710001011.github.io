<!DOCTYPE HTML>
<html lang="en">




<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Academic Progress, Hunter|Hacker|Coder|Artist">
    <meta name="description" content="信念与认知">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>


    <title>Academic Progress | Jf71o0x1o1l</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Jf71o0x1o1l" type="application/atom+xml">
</head>


    

                <body>
                    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Jf71o0x1o1l</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Jf71o0x1o1l</div>
        <div class="logo-desc">
            
            信念与认知
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

                        



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/6.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Academic Progress</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Academic/">
                                <span class="chip bg-color">Academic</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Cybersecurity/" class="post-category">
                                Cybersecurity
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2022-09-05
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>Update Date:&nbsp;&nbsp;
                    2023-12-10
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    53.8k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>Read Count:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="论文合集置顶">论文合集（置顶）</h3>
<p>描述：我看过的全部论文</p>
<p><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/search/searchresult.jsp?queryText=malware%20malicious&amp;highlight=true&amp;returnFacets=ALL&amp;returnType=SEARCH&amp;matchPubs=true&amp;refinementName=Publication%20Title&amp;refinements=PublicationTitle:IEEE%20Transactions%20on%20Information%20Forensics%20and%20Security&amp;refinements=PublicationTitle:IEEE%20Transactions%20on%20Dependable%20and%20Secure%20Computing">在TIFS和TDSC上的恶意代码检测相关文章检索</a></p>
<p><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/search/searchresult.jsp?queryText=adversarial%20example&amp;highlight=true&amp;returnType=SEARCH&amp;matchPubs=true&amp;refinementName=Publication%20Title&amp;pageNumber=1&amp;refinements=PublicationTitle:IEEE%20Transactions%20on%20Information%20Forensics%20and%20Security&amp;refinements=PublicationTitle:IEEE%20Transactions%20on%20Dependable%20and%20Secure%20Computing&amp;returnFacets=ALL">在TIFS和TDSC上的对抗样本的相关文章检索</a></p>
<p><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/585456510">对抗鲁棒性学习资料汇总</a></p>
<hr />
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9186721">Can We Trust
Your Explanations? Sanity Checks for Interpreters in Android Malware
Analysis</a>(<strong>CCF-A</strong>:TIFS)</li>
<li><a
target="_blank" rel="noopener" href="https://t.cnki.net/kcms/detail?v=7X1a-1n3lSlo7e8SD7MIrB4FNnqSB7t_ePAoPyb7UoHmdjy7X1BnKGJRTP-uE0xthwgZy7oAvyPeohpt27IF1AemI04TB997jyRzzpbNlx1tRRBs7PwTDS05-d4AuiQsZVkR1WkGtsg=&amp;uniplatform=NZKPT">深度学习赋能的恶意代码攻防研究进展</a>《计算机学报-方滨兴》</li>
<li><a
target="_blank" rel="noopener" href="https://www.sohu.com/a/295737605_468736">关于对抗样本恢复的研究</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.secrss.com/articles/19040">深度学习中对抗样本的防御和攻击</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0167404822001572">Adversarial
malware sample generation method based on the prototype of deep learning
detector</a>（<strong>CCF-B</strong>:computer and security）</li>
<li><a
target="_blank" rel="noopener" href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CDFD&amp;dbname=CDFDLAST2022&amp;filename=1020405886.nh&amp;uniplatform=NZKPT&amp;v=xjiG-vadnpzkvu94KN5K6owyE63keKSbdc119t_5nEfUR2a8ZsLu8ytcab9C2gM2">对抗样本技术在恶意软件检测和自动驾驶应用中的研究</a>（湖大-博士论文）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9762803">MsDroid:
Identifying Malicious Snippets for Android Malware
Detection</a>（<strong>CCF-A</strong>:TDSC-2022，作者来自浙大）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9477038">Backdoor
Attack on Machine Learning Based Android Malware
Detectors</a>（<strong>CCF-A</strong>:TDSC-2022，作者：斯威本科技大学博士）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9484718">DL-FHMC: Deep
Learning-Based Fine-Grained Hierarchical Learning Approach for Robust
Malware Classification</a>（<strong>CCF-A</strong>:TDSC-2022）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9833659">Transcending
TRANSCEND: Revisiting Malware Classification in the Presence of Concept
Drift</a>（CCF-A会议:IEEE S&amp;P）<br />
</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9186721">Can We Trust
Your Explanations? Sanity Checks for Interpreters in Android Malware
Analysis</a><span
style="background:##ffb86c;font-family:FiraCode;">（TIFS）</span></li>
<li><a
target="_blank" rel="noopener" href="https://t.cnki.net/kcms/detail?v=7X1a-1n3lSlo7e8SD7MIrB4FNnqSB7t_ePAoPyb7UoHmdjy7X1BnKGJRTP-uE0xthwgZy7oAvyPeohpt27IF1AemI04TB997jyRzzpbNlx1tRRBs7PwTDS05-d4AuiQsZVkR1WkGtsg=&amp;uniplatform=NZKPT">深度学习赋能的恶意代码攻防研究进展</a>《计算机学报-方滨兴》</li>
<li><a
target="_blank" rel="noopener" href="https://www.sohu.com/a/295737605_468736">关于对抗样本恢复的研究</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.secrss.com/articles/19040">深度学习中对抗样本的防御和攻击</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0167404822001572">Adversarial
malware sample generation method based on the prototype of deep learning
detector</a>（<strong>CCF会议 B</strong>-computer and security）</li>
<li><a
target="_blank" rel="noopener" href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CDFD&amp;dbname=CDFDLAST2022&amp;filename=1020405886.nh&amp;uniplatform=NZKPT&amp;v=xjiG-vadnpzkvu94KN5K6owyE63keKSbdc119t_5nEfUR2a8ZsLu8ytcab9C2gM2">对抗样本技术在恶意软件检测和自动驾驶应用中的研究</a>（湖大-博士论文）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9762803">MsDroid:
Identifying Malicious Snippets for Android Malware
Detection</a>（<strong>CCF-A</strong>:TDSC-2022，作者来自浙大）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9477038">Backdoor
Attack on Machine Learning Based Android Malware
Detectors</a>（<strong>CCF-A</strong>:TDSC-2022，作者：斯威本科技大学博士）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9484718">DL-FHMC: Deep
Learning-Based Fine-Grained Hierarchical Learning Approach for Robust
Malware Classification</a>（<strong>CCF-A</strong>:TDSC-2022）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9833659">Transcending
TRANSCEND: Revisiting Malware Classification in the Presence of Concept
Drift</a>（<strong>CCF-A会议</strong>:IEEE S&amp;P）</li>
<li><a
target="_blank" rel="noopener" href="https://link.springer.com/article/10.1007/s00521-021-06597-0">Applications
of deep learning for mobile malware detection: A systematic literature
review</a>(NCA:人工智能-<strong>CCF-C</strong>)</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9964330">A Survey of
Adversarial Attack and Defense Methods for Malware Classification in
Cyber Security</a>（<strong>中科院JCR分区一区TOP</strong>:IEEE
COMMUNICATIONS SURVEYS &amp; TUTORIALS）</li>
<li><a target="_blank" rel="noopener" href="https://www.hindawi.com/journals/scn/2020/8858010/">A
Survey of Automatic Software Vulnerability Detection, Program Repair,
and Defect Prediction Techniques</a>（<strong>CCF-C:</strong>Security
and Communication Networks 2020）</li>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3474553">Efficiency and
Effectiveness of web application vulnerability detection approaches: A
Review</a> （<a target="_blank" rel="noopener" href="https://dl.acm.org/toc/csur/2022/54/9">ACM
Computing Surveys</a>：<strong>中科院分区一区top</strong>）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9842744">Can Deep
Learning Models Learn the Vulnerable Patterns for Vulnerability
Detection?</a> [<strong>CCF-C</strong>: 2022 IEEE 46th Annual Computers,
Software, and Applications Conference (COMPSAC)]</li>
<li><a
target="_blank" rel="noopener" href="https://www.usenix.org/conference/usenixsecurity22/presentation/li-song">Mining
Node.js Vulnerabilities via Object Dependence Graph and
Query</a>(<strong>CCF-A</strong>:31st USENIX Security Symposium
2022)</li>
<li><a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0167404822004072?via%3Dihub">MFXSS:
An effective XSS vulnerability detection method in JavaScript based on
multi-feature model</a>(<strong>CCF-B</strong>:Computers &amp;
Security)</li>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3488932.3497769">On
Measuring Vulnerable JavaScript Functions in the
Wild</a>(<strong>CCF-C:</strong>17th AsiaCCS 2022: Nagasaki, Japan)</li>
<li><a
target="_blank" rel="noopener" href="https://www.ndss-symposium.org/ndss-paper/fuzzilli-fuzzing-for-javascript-jit-compiler-vulnerabilities/">FUZZILLI:
Fuzzing for JavaScript JIT Compiler
Vulnerabilities</a>(<strong>CCF-A</strong>会议：NDSS 2023)</li>
<li><a
target="_blank" rel="noopener" href="https://www.ndss-symposium.org/ndss-paper/auto-draft-207/">Probe
the Proto: Measuring Client-Side Prototype Pollution Vulnerabilities of
One Million Real-world Websites</a>(<strong>CCF-A</strong>会议：NDSS
2022)</li>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3468264.3468542">Detecting
Node.js prototype pollution vulnerabilities via object lookup
analysis</a>(<strong>CCF-A</strong>:ESEC/SIGSOFT FSE 2021)</li>
<li><a
target="_blank" rel="noopener" href="https://www.computer.org/csdl/proceedings-article/sp/2023/933600b059/1NrbYrQrQ2I">Scaling
JavaScript Abstract Interpretation to Detect and Exploit Node.js
Taint-style Vulnerability</a>: <strong>CCF-A</strong>会议：IEEE S&amp;P
2023</li>
<li><a
target="_blank" rel="noopener" href="https://www.usenix.org/conference/14th-usenix-security-symposium/finding-security-vulnerabilities-java-applications-static">Finding
Security Vulnerabilities in Java Applications with Static Analysis</a>
<strong>CCF-A:</strong>USENIX Security Symposium 2005</li>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3554732">An In-depth Study
of Java Deserialization Remote-Code Execution Exploits and
Vulnerabilities.</a>(<strong>CCF-A</strong>:软件工程顶刊：ACM
Transactions on Software Engineering and Methodology, Volume 32)</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/10172888">Improving
Java Deserialization Gadget Chain Mining via Overriding-Guided Object
Generation</a>（程序语言<strong>CCF-A</strong>:2023 IEEE/ACM 45th
International Conference on Software Engineering (ICSE)）</li>
<li><code>A Composite Discover Method for Gadget Chains in Java Deserialization Vulnerability</code></li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/10202660">Tabby:
Automated Gadget Chain Detection for Java Deserialization
Vulnerabilities</a>（<strong>CCF-B</strong>会议：DSN2023）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/10188756">Improving
Precision of Detecting Deserialization Vulnerabilities with Bytecode
Analysis</a>（计算机网络<strong>CCF-B</strong>:31st IWQoS 2023）</li>
</ol>
<h3 id="section">2023-12-09</h3>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/12/09/java/#toc-heading-40">Java异常机制</a><img
src="https://s2.loli.net/2023/12/10/KSwbyaQUW3T6ZVM.png"
alt="image-20231209225321575" /></li>
<li><a
href="https://jf710001011.github.io/2023/12/09/static-analysis-ii/">静态分析再研究</a><img
src="https://raw.githubusercontent.com/Jf710001011/pictureBed/main/img/image-20231209225337843.png"
alt="image-20231209225337843" /></li>
</ol>
<h3 id="section-1">2023-12-02</h3>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/08/26/java/#toc-heading-36">Java
IO</a></li>
<li>tabby 源码分析
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/10/28/tabby-fen-xi/#toc-heading-7">tabby/core/data/FileLocation.java</a></li>
<li><a
href="https://jf710001011.github.io/2023/10/28/tabby-fen-xi/#toc-heading-8">tabby/core/data/TabbyRule.java</a></li>
</ol></li>
</ol>
<h3 id="section-2">2023-11-19</h3>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/10/28/tabby-fen-xi/#toc-heading-9">tabby分析</a>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/10/28/tabby-fen-xi/#toc-heading-2">run.sh</a></li>
<li><a
href="https://jf710001011.github.io/2023/10/28/tabby-fen-xi/#toc-heading-4">tabby/core/Analyser.java</a></li>
<li><a
href="https://jf710001011.github.io/2023/10/28/tabby-fen-xi/#toc-heading-5">tabby/core/scanner/CallGraphScanner.java</a></li>
</ol></li>
<li>找到一个不错的分析思路<img
src="https://s2.loli.net/2023/11/18/w4cLOvbhnT8qfPR.png"
alt="image-20231118230811392" /></li>
</ol>
<h3 id="section-3">2023-11-11</h3>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2022/09/05/academic-progress/">Tabby/core/container分析</a><img
src="https://s2.loli.net/2023/11/12/bZ4omvGEiWakn1s.png"
alt="image-20231112124458950" /></li>
</ol>
<h4 id="总结">总结</h4>
<ol type="1">
<li>首先是对数据（类、方法和类之间的关系）的存储，其次是对数据的使用，内存中查找不到，则从Neo4j图数据库中读取</li>
<li>对规则的存储和读取，包括类规则和方法规则</li>
</ol>
<h3 id="section-4">2023-11-04</h3>
<h4 id="tabby项目分析">Tabby项目分析</h4>
<ol type="1">
<li>本周主要分析的是：项目的<strong>核心模块：</strong>负责收集待分析的文件或依赖库，解析
Java 代码，生成 Soot 模型，进行污点分析，发现可能存在的漏洞
<ol type="1">
<li>tabby 的核心模块是 Tabby
的核心功能所在。该模块主要由以下几个类组成：
<ul>
<li><strong>FileCollector：</strong>负责收集待分析的文件或依赖库。</li>
<li><strong>Parser：</strong>负责解析 Java 代码，生成 Soot 模型。</li>
<li><strong>TaintAnalysis：</strong>负责进行污点分析，发现可能存在的漏洞。</li>
</ul></li>
</ol></li>
<li><a
href="https://jf710001011.github.io/2023/10/28/tabby-fen-xi/#toc-heading-6">笔记记录</a></li>
</ol>
<h4 id="总结-1">总结</h4>
<ol type="1">
<li><code>Tabby</code> 的设计思路主要有以下几点：
<ul>
<li>基于 Soot 实现，支持 Java 代码的静态分析。</li>
<li>支持多种漏洞挖掘方法，包括反序列化链挖掘、信息泄露检测、代码漏洞检测等。</li>
<li>支持多种输出格式，包括 HTML、CSV 等</li>
</ul></li>
<li>Tabby 的代码组织主要分为以下几个模块：
<ul>
<li><strong>核心模块：</strong>负责收集待分析的文件或依赖库，解析 Java
代码，生成 Soot 模型，进行污点分析，发现可能存在的漏洞。</li>
<li><strong>输出模块：</strong>负责生成报告，展示漏洞信息。</li>
<li><strong>配置模块：</strong>负责配置 Tabby 的运行参数。</li>
</ul></li>
<li>写出这样的项目真的挺难啊：有思路和方法，但是实现出来不容易。</li>
</ol>
<h3 id="section-5">2023-10-28</h3>
<h4 id="论文1">论文1</h4>
<ol type="1">
<li><a
target="_blank" rel="noopener" href="https://www.infocomm-journal.com/cjnis/CN/10.11959/j.issn.2096-109x.2022009">基于混合分析的Java反序列化利用链挖掘方法</a></li>
</ol>
<h5 id="正文">正文</h5>
<ol type="1">
<li>反序列化漏洞三要素：
<ol type="1">
<li>污染源：攻击者可控的变量；</li>
<li>入口函数：反序列化时自动调用的接口函数；</li>
<li>危险函数：能够执行命令的函数。</li>
</ol></li>
<li>另外，如果只通过声明类型构造简单调用图，然后在调用图中寻找从入口函数到危险函数的调用链作为反序列化利用链。这种做法将存在大量的误报：
<ol type="1">
<li><strong>一是</strong>因为根据声明类型构造的调用图不准确，调用关系在实际运行的过程中可能不存在；</li>
<li><strong>二是</strong>即使调用链存在，如果污点源无法传播到危险函数，调用链也将无法利用</li>
</ol></li>
</ol>
<h4 id="tabby项目分析-1">Tabby项目分析</h4>
<ol type="1">
<li>源自这篇论文：<a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/10202660">Tabby: Automated
Gadget Chain Detection for Java Deserialization
Vulnerabilities</a>（<strong>CCF-B</strong>会议：DSN2023）</li>
<li>代码中的<strong>注释</strong>即为我的分析过程</li>
<li><a
href="https://jf710001011.github.io/2023/10/28/tabby-fen-xi/#toc-heading-1">Tabby分析-记录</a></li>
</ol>
<h4 id="总结-2">总结</h4>
<ol type="1">
<li>本周主要是开启对唯一一篇CCF-B中的<strong>项目源码进行分析</strong>
<ol type="1">
<li>全部自己实现是个非常困难的事，需要个参照</li>
<li>这是第一次对整个项目进行分析</li>
</ol></li>
<li>下周结束这个项目分析</li>
</ol>
<h3 id="section-6">2023-10-21</h3>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/08/26/java/#toc-heading-30">Java反序列化漏洞底层探究
记录</a>，包括以下内容<img
src="https://s2.loli.net/2023/10/21/etCgaulSrUR7PMz.png"
alt="image-20231021225016323" />
<ol type="1">
<li>两种方式触发漏洞</li>
<li>利用反射实现利用链</li>
<li>序列化和反序列化流程分析</li>
<li>经典利用链分析</li>
</ol></li>
</ol>
<h4 id="总结-3">总结</h4>
<ol type="1">
<li>探究底层原理发现了更多漏洞检测的细节问题，主要是针对这些问题去改进</li>
<li>我的一个<strong>新想法</strong>：一条完整的利用链包括<code>source()-&gt;中间函数--&gt;sink()</code>
<ol type="1">
<li>一对<code>(source,sink)</code>,有非常多的路线，而我们只是找出有效的利用链。而从source()出发经过的各个中间方法我们无法确定能否到达source,<strong>反其道行之</strong>从sink()出发,逐步向source靠近，将这些可达sink的函数进行<strong>标记</strong>，就可以减少无效的利用链分析</li>
<li>正如1中所述，主要需要考虑从<code>sink向上标记到第几层</code>，总的来说<code>前向和后向分析</code>可以同时进行提高效率</li>
</ol></li>
</ol>
<h3 id="section-7">2023-10-14</h3>
<h4 id="论文1-1">论文1</h4>
<ol type="1">
<li><code>A Composite Discover Method for Gadget Chains in Java Deserialization Vulnerability</code>（10th
QuASoQ / 6th SEED@APSEC 2022: Virtual）</li>
</ol>
<h5 id="正文-1">正文</h5>
<ol type="1">
<li><p>对基于指纹检测的Java反序列化漏洞检测方法</p>
<p>Java反序列化过程可能存在安全漏洞,通过构造恶意序列化数据可以实施远程代码执行等攻击。为了检测这种漏洞,可以使用基于指纹的方法。</p>
<p>基本思路是收集已知的可利用的反序列化gadget代码特征,构建一个<code>指纹库</code>。在运行时监控应用的反序列化流量,用指纹库去匹配查看是否包含已知的危险gadget。<strong>匹配到</strong>则表明可能存在可利用的反序列化漏洞。</p>
<p>这种方法的优点是可以快速检测已知模式的漏洞利用,不需要复杂的代码审计。缺点是指纹库需要维护更新,对未知的0day攻击效果不佳。</p></li>
<li><p>3个漏洞检测工具</p>
<ol type="1">
<li><strong>Ysoserial:</strong></li>
<li><strong>Marshalsec:</strong>
Marshalsec主要用于生成有效负载，但不包括小工具链的发现功能。</li>
<li><strong>Java Deserialization Scanner:</strong>
这是一个用于检测Java反序列化漏洞的插件，它可以与广泛使用的渗透测试工具Burp
Suite集成。该插件利用Ysoserial生成有效负载，用于对反序列化漏洞的目标进行渗透测试和漏洞验证。</li>
</ol></li>
<li><p>Gadget Inspector</p></li>
<li><p><code>fingerprinting-based detection can only detect the presence of known gadget chains in the program,but not unknown gadget chains in the program.</code></p></li>
<li><p><code>In 2020, Rasheed[13] proposed a hybrid analysis strategy to avoid false positives. It uses static analysis results as a guide for fuzzing.</code></p></li>
</ol>
<h4 id="论文2">论文2</h4>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=wPbW6zQ52w8">Automated
Discovery of Deserialization Gadget Chains</a></li>
</ol>
<h5 id="正文-2">正文</h5>
<ol type="1">
<li><p><code>ysoserial</code> project and
<code>Marshalsec</code>:<code>is a similar project which supports a wider breadth of              12 deserialization libraries, but is again a tool which largely includes known gadget chains.</code></p></li>
<li><p>The <code>NCC Group Burp Pluginis</code> another 14 Burp Suite
plugin but which is mainly based on the JSON payloads from Muñoz and
Mirosh’s work.</p></li>
<li><p><code>joogle</code></p></li>
<li><p><code>The ASM (Objectweb ASM)</code> library is a popular and
widely-used Java bytecode manipulation framework. It allows developers
to analyze and modify Java classes at the bytecode level. ASM provides a
low-level, efficient, and flexible way to work with Java class files,
making it an essential tool for various applications, including:</p>
<ol type="1">
<li><p><strong>Bytecode Generation:</strong> Developers can use ASM to
generate Java class files programmatically. This is useful for code
generation, code transformation, and dynamic class creation.</p></li>
<li><p><strong>Code Analysis:</strong> ASM can be used to analyze
existing Java class files. It allows you to inspect the structure of
classes, methods, fields, and instructions, making it valuable for tools
like code analyzers and documentation generators.</p></li>
<li><p><strong>Code Transformation:</strong> ASM enables the
modification of existing class files, allowing you to inject code, add
or remove methods, and change class structures. This is often used in
frameworks and libraries that need to instrument or modify classes
during runtime.</p></li>
<li><p><strong>Performance Enhancements:</strong> Some applications use
ASM to optimize Java bytecode for better performance. This can include
inlining, method call optimizations, and other bytecode-level
improvements.</p></li>
<li><p><strong>Java Agents:</strong> ASM is commonly used in Java
agents, which are Java programs that can be dynamically attach to
running Java applications to instrument and monitor them. Agents can be
used for profiling, logging, and other runtime analysis.</p></li>
<li><p><strong>Aspect-Oriented Programming (AOP):</strong> ASM is
sometimes used in AOP frameworks to weave aspect code into classes at
the bytecode level. This allows developers to separate cross-cutting
concerns, such as logging or security, from the main application
logic.</p></li>
</ol>
<p>ASM is known for its small footprint, high performance, and the
ability to work with different versions of Java class files. It offers
both a simple and a more complex API, making it suitable for a wide
range of use cases, from simple class file generation to advanced
bytecode manipulation.</p>
<p>If you are working on projects that require Java bytecode
manipulation, ASM is a powerful and versatile library that can help you
achieve your goals. It's often used in conjunction with other tools and
libraries for specific tasks like code generation, optimization, or
instrumentation.</p></li>
<li><p>How Gadget Inspector <strong>Works</strong></p>
<ol type="1">
<li>Class and Method Hierarchy Enumeration</li>
</ol></li>
</ol>
<h4 id="总结-4">总结</h4>
<ol type="1">
<li><p>在查询语言上进行优化使用<code>Codeql</code>:</p>
<p>CodeQL查询语言是CodeQL用于编写代码分析查询规则的语言,具有以下主要特点:</p>
<ol type="1">
<li>基于逻辑查询:查询以类似SQL的逻辑语句组织,例如选择、联接等。</li>
<li>支持面向对象:可以直接作用于类、对象、方法等。</li>
<li>路径敏感:可以精确捕获代码执行路径。</li>
<li>数据流分析:可以跟踪数据流动,寻找问题。</li>
<li>支持聚合:可以聚合和分组结果。</li>
<li>丰富的APIs:提供访问AST、控制流图、调用关系等程序结构信息的API。</li>
<li>可扩展:可以导入其他语言写的库。</li>
<li>可组合:查询可以组合使用。</li>
<li>注释支持:可以在查询中加入注释说明。</li>
<li>良好的IDE支持:如VS Code插件。</li>
</ol></li>
<li><p>一个检测工具需要满足的<strong>特点</strong>参考-设计指南：</p>
<ol type="1">
<li>确定类路径上存在的 gadget
链漏洞：工具应该能够检测类路径中可能存在的潜在 gadget 链漏洞。</li>
<li>评估漏洞的影响：工具应该能够评估这些漏洞的影响，包括可能导致的安全问题，如
RCE、SSRF 和 DoS。</li>
<li>提供保守的影响评估：工具应该提供限制性的、谨慎的漏洞影响评估，以确保不低估漏洞的危害程度。</li>
<li>适用于整个类路径：工具应该能够轻松操作应用程序的整个类路径，无论应用程序中使用的编程语言是什么。如果应用程序使用多种源语言，工具应该能够在
Java 字节码上运行。</li>
<li>理解不同反序列化库：工具应该能够理解和适应不同的反序列化库，了解每个库对
gadget 链的限制，以便更好地检测漏洞。</li>
</ol></li>
<li><p>下一个计划：</p>
<ol type="1">
<li>研究几个经典的反序列化漏洞案例，把握漏洞特征，针对特定的问题，设计对应的解决策略</li>
<li>重点在设计方法调用图和数据流图上</li>
</ol></li>
</ol>
<h3 id="section-8">2023-10-07</h3>
<h4 id="java反射">Java反射</h4>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/08/26/java/#toc-heading-29">JAVA反射记录</a><img
src="https://s2.loli.net/2023/10/07/W6hYOL2gpAGuaZ3.png"
alt="image-20231007221736659" /></li>
<li>JAVA反射是JAVA一个非常重要的特性，机制复杂，出现安全的问题也更加复杂，是一个非常值得关注的点</li>
</ol>
<h4 id="论文1-2">论文1</h4>
<ol type="1">
<li><p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/10188756">Improving
Precision of Detecting Deserialization Vulnerabilities with Bytecode
Analysis</a>（计算机网络<strong>CCF-B</strong>:31st IWQoS 2023）</p>
<ol type="1">
<li><p>作者：广州大学网络空间安全学院</p></li>
<li><p>Index Terms：</p>
<p>Security and Protection,</p>
<p>Web Servers,</p>
<p>Program Analysis,</p>
<p>Java.</p></li>
</ol></li>
</ol>
<h5 id="正文-3">正文</h5>
<ol type="1">
<li><p><code>JNDI（Java Naming and Directory Interface）</code>注入是一种安全漏洞，通常出现在Java应用程序中，特别是那些使用JNDI来连接和管理命名和目录服务的应用程序中。JNDI是Java中用于访问命名和目录服务的API，允许应用程序查找和访问各种资源，如数据库连接、消息队列等。</p>
<p>JNDI注入<code>发生在</code>攻击者能够控制或影响JNDI查找的输入时。攻击者可以通过恶意构造的JNDI名称或URL，迫使应用程序加载和执行不安全的类或代码。这可能导致严重的安全问题，包括远程代码执行、信息泄露或拒绝服务攻击。</p>
<p>通常，JNDI注入漏洞的利用方式包括将恶意的JNDI名称传递给应用程序，然后应用程序试图查找这个名称，最终执行了攻击者控制的恶意代码。</p></li>
<li><p><code>Static analysis based on bytecode analysis, such as GadgetInspector [1] and GadgetSearch [2], is the most popular measure to detect deserialization vulnerabilities</code></p></li>
<li><p><code>Java反射（Reflection）</code>是一种高级编程技术，允许在运行时检查、获取和操作类、对象、方法、字段等程序元素的信息。反射提供了一种强大的机制，使开发人员能够在运行时获取类的信息、创建对象、调用方法和访问字段，而不需要在编译时知道这些信息。</p>
<p>以下是Java反射的一些关键概念和用法：</p>
<ol type="1">
<li><p><strong>Class类：</strong>
在Java中，每个类都有一个对应的<code>Class</code>对象，用于表示类的信息。你可以使用<code>Class</code>类的静态方法<code>forName</code>来获取一个类的<code>Class</code>对象。</p></li>
<li><p><strong>获取类信息：</strong>
通过<code>Class</code>对象，你可以获取类的名称、父类、接口、构造方法、方法、字段等信息。这使得你可以在运行时了解类的结构。</p></li>
<li><p><strong>创建对象：</strong>
反射允许你在运行时创建对象，即使你不知道类的名称，也可以使用<code>Class</code>对象的<code>newInstance</code>方法来实现。</p></li>
<li><p><strong>调用方法：</strong>
使用反射，你可以在运行时调用类的方法。<code>Method</code>类表示一个方法，你可以使用它来调用方法，传递参数，并获取方法的返回值。</p></li>
<li><p><strong>访问字段：</strong>
通过反射，你可以获取和修改对象的字段值。<code>Field</code>类表示一个字段，你可以使用它来读取和写入字段的值。</p></li>
<li><p><strong>访问构造方法：</strong>
使用反射，你可以获取类的构造方法并创建对象的实例。<code>Constructor</code>类表示一个构造方法，你可以使用它来实例化对象。</p></li>
<li><p><strong>动态代理：</strong>
反射还用于实现动态代理，允许你在运行时创建代理对象来控制对目标对象的访问。</p></li>
<li><p><strong>注解处理：</strong>
反射也常用于处理注解，你可以通过反射获取类、方法或字段上的注解，并根据注解的信息执行相应的逻辑。</p></li>
</ol>
<p>反射通常在某些高级应用程序、框架和工具中使用，例如ORM（对象关系映射）、依赖注入、动态代码生成等。</p></li>
<li><p><code>代理对象（Proxy Object）</code>是在软件设计中常用的一种模式，用于<code>控制</code>对其他对象的访问。代理对象充当了其他对象的接口，以控制对这些对象的访问，通常用于添加额外的功能或控制访问权限。代理对象可以在不改变原始对象的情况下对其进行增强或包装。</p>
<p>代理对象通常有以下几种类型：</p>
<ol type="1">
<li><p><strong>静态代理：</strong>
在编译时创建的代理对象，开发人员需要手动编写代理类。静态代理通常用于实现特定功能，如日志记录或权限控制。</p></li>
<li><p><strong>动态代理：</strong>
在运行时创建的代理对象，无需手动编写代理类，可以根据需要动态生成。Java中的动态代理通常使用<code>java.lang.reflect.Proxy</code>类和<code>InvocationHandler</code>接口实现。</p></li>
<li><p><strong>远程代理：</strong>
用于在不同地址空间中控制对远程对象的访问。远程代理允许本地程序像访问本地对象一样访问远程对象。</p></li>
</ol>
<p>代理对象的一些常见应用场景包括：</p>
<ul>
<li><p><strong>AOP（面向切面编程）：</strong>
代理对象可以用于实现横切关注点，例如日志记录、性能监控、事务管理等，而不需要在每个方法中编写相同的代码。</p></li>
<li><p><strong>延迟加载：</strong>
代理对象可以用于延迟加载对象，只有在需要时才真正创建和初始化对象，以提高性能。</p></li>
<li><p><strong>权限控制：</strong>
代理对象可以用于控制对某些操作的访问权限，根据用户的角色或权限级别来限制操作。</p></li>
<li><p><strong>远程调用：</strong>
代理对象可用于在分布式系统中执行远程方法调用，以便在不同的计算机上执行操作。</p></li>
</ul>
<p>代理对象的设计模式有助于提高代码的可维护性和可扩展性，因为它们将关注点分离并允许在不影响原始对象的情况下添加或修改功能。代理对象通常是面向对象编程中的重要概念，经常与其他设计模式如装饰器模式、适配器模式等一起使用。</p></li>
<li><p><strong>问题</strong>：这个漏洞是因为在反序列化过程中，动态代理类<code>AnnotationInvocationHandler</code>中的<code>equalsImpl</code>()方法使用了反射，但成员"memberMethods"被标记为"<code>transient</code>"，反序列化无法控制它。这导致了一些静态分析工具认为这种反射是不受控制的，可能会导致潜在的安全问题。</p></li>
<li><p><code>JRE7u21</code> deserialization vulnerability.</p></li>
<li><p>那些不会推断本地变量和参数类型的常规静态分析工具会错误地将这样具有不正确参数的反射视为可控制的反射，从而产生许多错误结果</p></li>
</ol>
<h4 id="总结-5">总结</h4>
<ol type="1">
<li><p><code>JAVA反射</code>
拓宽了我的思路，能够发现更多的安全问题和提供了更多改进优化的思路</p></li>
<li><p>本文注意到了<strong>三个问题</strong>并提出了三个<code>提高检测精度</code>的方法</p>
<ol type="1">
<li><p><code>CROSS-FUNCTION MEMBERS DATA FLOW TRACKING</code></p>
<p><strong>P</strong>:在JRE7u21反序列化漏洞中，成员"memberMethods"具有"transient"修饰符，这在反序列化中是不可控制的，因此常规的静态分析认为这个反射不可控制。</p>
<p><strong>S</strong>:在分析每个方法的数据流之前，需要初始化污点源（taint
sources）和一个成员数据流表格。这个表格用于保存在执行过程中对象成员的变化以及谁改变了这些成员的信息</p></li>
<li><p><code>LOCAL VARIABLES AND ARGUMENTS TYPES INFERENCE</code></p>
<p>P:动态反射需要特定类型的参数数组来执行危险操作，而常规静态分析工具如果无法正确推断本地变量和参数的类型，可能会误判反射为可控制的</p>
<p>S:在操作栈和表中的每个元素中保存<code>类型信息</code>,包括确切类型和可能类型</p></li>
<li><p><code>CALL CHAIN SUBJECT INFERENCE BASED ON INHERITANCE RELATIONSHIPS</code></p>
<p><strong>P</strong>:如果存在一个调用链，其中在子类A、超类和子类B之间存在"this"或"super"方法调用，而且类A和类B之间没有继承关系，那么这个调用链可以被认为是不可能存在的调用链。</p>
<p><strong>S</strong>:
在方法调用中确定继承关系，剔除无效的调用链</p></li>
</ol></li>
<li><p>另一方面在研究一些静态分析工具的<code>源码</code></p></li>
</ol>
<h3 id="section-9">2023-09-30</h3>
<h4 id="论文信息">论文信息</h4>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/10202660">Tabby:
Automated Gadget Chain Detection for Java Deserialization
Vulnerabilities</a>（<strong>CCF-B</strong>会议：DSN2023）<img
src="https://s2.loli.net/2023/09/30/7pMQi4mDtWCb5P8.png"
alt="image-20230930164833918" /></li>
</ol>
<h4 id="正文-4">正文</h4>
<h5 id="background">background</h5>
<ol type="1">
<li><p>Existing state-of-the-art analysis tools (e.g.,
<code>Spotbugs</code> [8], <code>CodeQL</code> [9])</p></li>
<li><p><strong>难点</strong>：</p>
<ol type="1">
<li><strong>控制流难以追踪</strong>：针对Java反序列化漏洞，其中一个根本原因是难以追踪控制流。与其他漏洞（如SQL注入或XSS）不同，无法仅仅依靠输入分析来检测漏洞。必须关注数据在输入后传递到源方法后的控制流，以确定是否会执行到危险的汇聚方法。这种控制流的复杂性增加了漏洞的发现和分析难度。</li>
<li><strong>多样性和复杂性</strong>：另一个根本原因是Java反序列化漏洞的多样性和复杂性。利用这些漏洞需要构造复杂的“小工具链”（gadget
chain），这些链由许多类对象的巧妙组合组成。由于Java的多态性和继承机制，存在大量潜在的小工具链。这增加了查找和利用这些漏洞的复杂性。同时，现有的分析工具通常无法有效地处理这些库中的漏洞，因为这些库通常非常广泛且数量众多。</li>
<li>此外，研究人员通常在手动追踪小工具链或<code>自定义</code>现有工具方面面临困难，因为后者要么不提供对自定义分析的支持，要么要求对每个新的自定义都进行源代码的重复分析。此外，自定义分析通常需要精细的调整，当需要为每个自定义重新分析源代码时，这将变得<code>耗时且容易出错</code>。因此，一个重大的技术挑战在于创建中间<code>数据结构</code>，可以存储所有潜在数据并促进多次自定义重新分析。我们对这一挑战的解决方案是使用代码属性图构建一个中间数据结构。</li>
</ol></li>
<li><p><code>RPC(Remote Procedure Call)</code>即远程过程调用,是一种进程间通信方式,允许客户机程序调用服务端程序的函数或者过程,具有以下主要特征:</p>
<ol type="1">
<li>客户机可以像调用本地函数一样调用服务器端的函数或过程,不需要了解底层通信细节。</li>
<li>RPC隐藏了底层的网络通信,数据序列化,使得分布式计算透明化。</li>
<li>服务器端通过Skelton(存根函数)接收函数调用,执行函数后将结果返回客户端。</li>
<li>常用的RPC框架有gRPC, Thrift, Dubbo等。</li>
<li>RPC需要解决网络通信,序列化,目标查找,权限等多个方面的问题。</li>
<li>RPC的主要优势是对分布式通信进行封装抽象,调用远程函数像调用本地函数一样简单。</li>
<li>但RPC也存在额外开销,不宜用于对性能要求极高的场景。</li>
</ol></li>
<li><p>数据结构中存在的<strong>问题</strong></p>
<ol type="1">
<li>The semantic information extracted during the analysis cannot be
reused.</li>
</ol>
<p><strong>解决</strong>：图数据库。The introduction of graph databases
splits the static program analysis process into two parts: semantic
information extraction and specific vulnerability pattern
identification</p></li>
</ol>
<hr />
<h5 id="tabbydesign-and-implementation">TABBYDESIGN AND
IMPLEMENTATION</h5>
<ol type="1">
<li>our work’s <strong>technical challenge</strong> is to create
intermediate data structures that store all potential data. To overcome
this, we propose a novel data structure based on
<code>Code Property Graph (CPG)</code>, which involves converting Java
code into graph nodes and edges and storing the results in Neo4j.</li>
<li>we developed a <code>controllability analysis algorithm</code>
(detailed in §III-C) to help construct the CPG.</li>
</ol>
<h4 id="总结-6">总结</h4>
<ol type="1">
<li><p>一图总结Tabby工作流程<img
src="https://s2.loli.net/2023/10/01/WroAZShb8iF9R5X.png"
alt="image-20231001151759302" /></p></li>
<li><p>设计思路</p>
<ol type="1">
<li><p>首先构建<code>对象关系图（ORG）</code>、<code>方法调用图MCG、方法别名图（MAG）</code>,在此基础构建<code>代码属性图（CPG）</code></p></li>
<li><p>在<code>方法调用图（MCG）</code>中，使用<code>可控性分析算法</code>,生成更精确的<code>Precise Call Graph (PCG)</code></p>
<p>这个思路跟我之前想的一样：就是对数据结构进行合理化的调整，使得这个图提供更多我们需要的信息，移除不必要的信息</p></li>
<li><p>非常创新的一点在于它的三个算法,提高了寻找漏洞的<code>精确性</code>：可控性算法，Expander算法，Evaluator算法</p>
<ol type="1">
<li><code>污染位置（Polluted Position）</code>：是CALL关系边的一个数组属性，用于表示方法调用者和方法参数的<code>可控性权重</code>。这个属性用于衡量方法调用的<code>污染程度</code>，即哪些部分可能受到不可信输入或变量污染的影响。在反序列化漏洞分析中，PP属性对于评估方法调用的风险和潜在漏洞非常重要。它帮助确定哪些参数或方法调用者需要受到额外的关注，以识别潜在的漏洞。</li>
<li><code>触发条件（Trigger Condition）</code>：是<code>汇聚方法</code>的一个数组属性，<strong>表示必须可控的参数以达到攻击效果</strong>。触发条件属性定义了在攻击效果触发时，必须满足的参数条件。这些条件通常用于确定攻击是否能够成功执行，以及哪些参数的可控性对于攻击效果至关重要。触发条件属性在分析和查找漏洞时起到关键作用，帮助确定哪些参数需要特别关注和保护，以防止潜在的攻击。</li>
<li>为了充分以上两个属性，设计了两个算法：
<ol type="1">
<li><code>Expander</code>用于确定关系边的PP是否满足TC的要求，</li>
<li>而<code>Evaluator</code>用于确定搜索深度是否超过了设置的限制或是否达到了目标节点</li>
</ol></li>
</ol></li>
<li><p>在soot（一个非常知名的开源静态分析工具）的基础上，使用三个算法结合实现了java反序列化的<code>利用链</code>查询</p></li>
</ol></li>
</ol>
<h3 id="section-10">2023-09-23</h3>
<h4 id="记录">记录</h4>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/08/26/lab-static-analysis/#toc-heading-16">指针分析lab</a><img
src="https://s2.loli.net/2023/09/23/w9lRgQVFnWj4iBS.png"
alt="image-20230923215625766" />
<ol type="1">
<li>上下文敏感</li>
<li>非上下文敏感</li>
</ol></li>
</ol>
<h3 id="section-11">2023-09-16</h3>
<h4 id="笔记记录">笔记记录</h4>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/08/26/lab-static-analysis/#toc-heading-10">lab-4.
类层次结构分析和过程间常量传播</a> <img
src="https://s2.loli.net/2023/09/16/FpxkTd1DaoUW8vS.png"
alt="image-20230916204351902" /></li>
<li><a
href="https://jf710001011.github.io/2023/08/26/java/#toc-heading-28">Java
泛型和foreach陷阱</a><img
src="https://s2.loli.net/2023/09/16/Bgz5Al1CnUH6XWe.png"
alt="image-20230916204511941" /></li>
</ol>
<h4 id="总结-7">总结</h4>
<ol type="1">
<li>lab实现了三个算法<img
src="https://s2.loli.net/2023/09/16/UN7dHkaKs3tLgwp.png"
alt="image-20230916204617878" /></li>
<li>Java语法巩固</li>
</ol>
<h3 id="section-12">2023-09-09</h3>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/08/26/java/#toc-heading-26">Java
集合框架</a><img
src="https://s2.loli.net/2023/09/09/KejiH6983dm1g7c.png"
alt="image-20230909175945385" /></li>
<li><a
href="https://jf710001011.github.io/2023/08/26/lab-static-analysis/#toc-heading-8">lab-死代码检测</a><img
src="https://s2.loli.net/2023/09/09/wrn9tUIgCNHJxSP.png" /></li>
</ol>
<h3 id="section-13">2023-09-02</h3>
<ol type="1">
<li>Java<a
href="https://jf710001011.github.io/2023/08/26/java/#toc-heading-5">关键字学习</a></li>
<li><a
href="https://jf710001011.github.io/2023/08/26/lab-static-analysis/#toc-heading-5">lab-常量传播和
Worklist 求解器</a></li>
</ol>
<h3 id="section-14">2023-08-26</h3>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/08/26/lab-static-analysis/">实验过程简单记录</a></li>
</ol>
<h4 id="总结-8">总结</h4>
<ol type="1">
<li>进行这些实验，一方面是回顾以往的分析方法，将这些分析技术串联起来；另一方面，静态分析的难点之一也是算法的实现，最终的研究结果都需要用代码实现</li>
<li>两周内结束这些实验后，尝试应用于分析反序列化漏洞</li>
</ol>
<h3 id="section-15">2023-08-19</h3>
<h4 id="论文1-3">论文1</h4>
<ol type="1">
<li><a
target="_blank" rel="noopener" href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains-wp.pdf">Automated
Discovery of Deserialization Gadget Chains</a>
（来自<strong>黑帽大会</strong>2018：Ian Haken Senior Security Software
Engineer, Netflix）</li>
</ol>
<hr />
<h4 id="正文-5">正文</h4>
<ol type="1">
<li>即使在从“<code>readObject()</code>”方法返回之前，反序列化库也会自动调用<code>魔术方法</code>。</li>
<li><code>ysoserial</code> 工具不能发现新的利用链</li>
<li><code>Gadget Inspector</code> tool</li>
</ol>
<h4 id="符号执行">符号执行</h4>
<ol type="1">
<li><p>符号执行技术指的是通过程序分析的方法，确定哪些输入向量会对应导致程序的执行结果为某个向量的方法</p></li>
<li><p><strong>分析程序的执行路径</strong></p></li>
<li><p>例如</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> m<span class="token operator">=</span>M<span class="token punctuation">,</span> n<span class="token operator">=</span>N<span class="token punctuation">,</span> q<span class="token operator">=</span>Q<span class="token punctuation">;</span> 
<span class="token keyword">int</span> x1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>x2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>x3<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    x1<span class="token operator">=</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;</span><span class="token number">12</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>m <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        x2<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    x3<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">assert</span><span class="token punctuation">(</span>x1<span class="token operator">+</span>x2<span class="token operator">+</span>x3<span class="token operator">!=</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol type="1">
<li>它有以下执行路径<img
src="https://s2.loli.net/2023/08/19/w4bsB1xDZroVMKh.png"
alt="简单理解符号执行1" /></li>
<li>叶子节点显示的数值表示当前输入情况下，可以得到的数值。（比如，如果英雄出装是M<sup>(N&lt;12)，那么最终的属性值R=0）。其中M</sup>(N&lt;12)表达的是，M是非零值且N要小于12，Q为任意值的情况下，得到R=0。可以发现，当条件为~M<sup>(N&lt;5)</sup>Q时，得到了最终结果等于3.即，我们通过这种方式逆向发现了输入向量。<strong>如果把结果条件更改为漏洞条件，理论上也是能够进行漏洞挖掘了。</strong></li>
<li>符号执行的流程<img
src="https://s2.loli.net/2023/08/19/vO7x2QLpFA3yih1.png"
alt="image-20230819212728240" /></li>
</ol></li>
</ol>
<h4 id="总结-9">总结</h4>
<ol type="1">
<li>通过黑帽大会那篇论文了解了现存工具是如何就检测gadget
chain的，但目前大部分工具都是只能检测已经发现的工具利用链</li>
<li>符号执行也是一种非常适合静态分析的技术</li>
<li>下周开始 进行这8个静态分析实验<img
src="https://s2.loli.net/2023/08/19/GRIq68XMKLveDgw.png"
alt="image-20230819212534334" /></li>
</ol>
<h3 id="section-16">2023-08-12</h3>
<h4 id="论文1-4">论文1</h4>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/10172888">Improving
Java Deserialization Gadget Chain Mining via Overriding-Guided Object
Generation</a>（程序语言<strong>CCF-A</strong>:2023 IEEE/ACM 45th
International Conference on Software Engineering (ICSE)）</li>
</ol>
<hr />
<ol start="2" type="1">
<li><p>关注<code>Gadget Inspector</code>工具：static taint
analysis</p></li>
<li><p>关注<code>SerHybrid</code> ：hybrid analysis solution</p></li>
<li><p>SerHybrid has limited effectiveness due to <strong>two
reasons</strong>：</p>
<ol type="1">
<li>SerHybrid performs points-to analysis [16] to identify
source-to-sink method execution paths. However, due to the dynamic
features (e.g., runtime polymorphism [17]) of Java language, any
available overridden method (gadget) on the application’s classpath may
be exploited to construct gadget chains, resulting in <strong>high false
negatives</strong></li>
<li>due to the unawareness of hard constraints (requiring dynamically
modifying the properties of an injection object to trigger the target
gadget chain) introduced by certain gadgets, such generated injection
objects may be <strong>semantically invalid</strong></li>
</ol></li>
<li><p>Found:</p>
<ol type="1">
<li>Java deserialization gadgets are usually exploited by abusing
advanced <strong>language features</strong> (e.g., runtime
polymorphism), which enables attackers to reuse serializable overridden
methods on the application’s classpath;</li>
<li>attackers usually invoke exploitable overridden methods (gadgets)
via <code>dynamic binding</code> [19] to generate injection objects for
gadget chain construction.</li>
</ol></li>
<li><p>GCMiner performs static analysis to construct the
<code>Deserialization-Aware Call Graph</code> (DA-CG) to model both
explicit and implicit (method overriding) method calls to identify more
gadget chains.</p></li>
<li><p>GCMiner adopts an
<code>overriding-guided object generation approach</code> to generate
exploitable injection objects for fuzzing.</p></li>
<li><p>two state-of-the-art gadget chain mining tools,：</p>
<ol type="1">
<li>Gadget Inspector</li>
<li>Serhybrid</li>
</ol></li>
<li><p><code>magic method</code>：执行payload触发反序列化；last
gadget执行<code>恶意命令</code></p></li>
<li><p>Property-Oriented Programming (POP)</p></li>
<li><p>示例分析:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span>  <span class="token comment">/*javax.naming.ldap.Rdn$RdnEntry.class*/</span>
<span class="token number">2</span>  <span class="token keyword">private</span> <span class="token class-name">Oject</span> value<span class="token punctuation">;</span>
<span class="token number">3</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">RdnEntry</span> that<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/*Source or Magic Method*/</span>
<span class="token number">4</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>
  
<span class="token number">5</span>  <span class="token comment">/*com.sun.org.apache.xpath.internal.objects.XString.class*/</span>
<span class="token number">6</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/*2nd gadget*/</span>
<span class="token number">7</span>    <span class="token keyword">return</span> <span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
<span class="token number">8</span>  <span class="token comment">/*javax.swing.MultiUIDefaults.class*/</span>
<span class="token number">9</span>  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/*3rd gadget*/</span>
<span class="token number">10</span>   <span class="token class-name">Enumeration</span> keys <span class="token operator">=</span> <span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">11</span>   <span class="token keyword">while</span> <span class="token punctuation">(</span>keys<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token number">12</span>     <span class="token class-name">Object</span> key <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">13</span>     buf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>
<span class="token number">14</span> <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/*4th gadget*/</span>
<span class="token number">15</span>    <span class="token class-name">Object</span> value <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>
 
<span class="token number">16</span> <span class="token comment">/*javax.swing.UIDefaults.class*/</span>
<span class="token number">17</span> <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/*5th gadget*/</span>
<span class="token number">18</span>   <span class="token class-name">Object</span> value <span class="token operator">=</span> <span class="token function">getFromHashtable</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>
<span class="token number">19</span> <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">getFromHashtable</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/*6th gadget*/</span>
<span class="token number">20</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">LazyValue</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token number">21</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
<span class="token number">22</span>      value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">LazyValue</span><span class="token punctuation">)</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
<span class="token number">23</span> <span class="token comment">/*sun.swing.SwingLazyValue.class*/</span>
<span class="token number">24</span> <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">createValue</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">UIDefaults</span> table<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/*7th gadget*/</span>
<span class="token number">25</span>   <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
<span class="token number">26</span>     <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> c <span class="token operator">=</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">27</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>methodName <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token number">28</span>       <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> types <span class="token operator">=</span> <span class="token function">getClassArray</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">29</span>       <span class="token class-name">Method</span> m <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>methodName<span class="token punctuation">,</span> types<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">30</span>       <span class="token function">makeAccessible</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">31</span>       <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*Sink or Security-Sensitive Call Site*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码展示了一个Java反序列化漏洞的利用链:</p>
<ol type="1">
<li><p>RdnEntry的compareTo方法作为<strong>入口</strong>点被触发。</p></li>
<li><p>调用了XString的equals方法。</p></li>
<li><p>进而调用了MultiUIDefaults的toString方法。</p></li>
<li><p>toString遍历键值对并调用get方法。</p></li>
<li><p>get调用了父类UIDefaults的get。</p></li>
<li><p>最终调用了getFromHashtable。</p></li>
<li><p>在LazyValue的情况下会<strong>反射调用指定的方法</strong>。</p></li>
<li><p>攻击者可以构造恶意LazyValue,并注入任意方法。</p></li>
<li><p>这样就可以通过反序列化调用任意方法,实现RCE。</p></li>
</ol>
<p>分析:</p>
<ul>
<li>反序列化时compareTo被调用</li>
<li>多个类组成了完整的调用链</li>
<li>LazyValue反射调用点可被利用</li>
<li>攻击者可构造执行任意代码的payload</li>
</ul>
<p>这展示了Java反序列化漏洞的复杂利用链分析过程。</p></li>
<li><p>well-known vulnerability disclosure platforms such as National
Vulnerability Database (<code>NVD</code>), Common Vulnerabilities and
Exposures (<code>CVE</code>) , Exploit Database
(<code>Exploit-D</code>)</p></li>
<li><p>An exploitable gadget chain requires:</p>
<ol type="1">
<li>a <code>magic method</code> (source or the first gadget)
deserializing untrusted data that can be injected by attackers;</li>
<li>a <code>security-sensitive call site</code> (sink or the last
gadget) that ultimately executes a dangerous operation; and</li>
<li>a series of gadgets facilitating the
<code>propagation of injection objects</code> [33].</li>
</ol></li>
<li><p><code>Java runtime polymorphism</code></p></li>
<li><p>invoke <code>overridden methods</code></p></li>
<li><p><code>application’s classpath</code></p></li>
<li><p><code>Java reflection</code></p></li>
<li><p>modify the <code>properties of injection objects</code></p></li>
<li><p>known gadget
<code>chainCommonsCollections1 of ysoserial</code>：combine dynamic
proxy and dynamic binding</p></li>
<li><p>add <code>additional overriding relations</code> through Class
Hierarchy Analysis <code>(CHA)</code> [37] to construct a
Deserialization-Aware Call Graph (DACG) to identify implicit method
calls</p></li>
<li><p><strong>Framework of GCMiner</strong><img
src="https://s2.loli.net/2023/08/12/qk8GMreLyua5T21.png"
alt="image-20230812045329846" /></p></li>
<li><p><strong>Overview of gadget chain verification.</strong><img
src="https://s2.loli.net/2023/08/12/dMgqlI1UOXzw89F.png"
alt="image-20230812045122878" /></p></li>
<li><p><strong>Partial DA-CG</strong> for our motivating example.<img
src="https://s2.loli.net/2023/08/12/f14cFJqGPUODCh5.png"
alt="image-20230812045150441" /></p></li>
<li><p>a <code>declarative language</code> for graph data retrieval
[39], to design <code>query scripts</code> for suspicious gadget chain
identification.</p></li>
<li><p>A simple query <code>script</code> example.</p>
<pre class="line-numbers language-cypher" data-language="cypher"><code class="language-cypher"><span class="token number">1</span>  <span class="token keyword">match</span> <span class="token punctuation">(</span>source<span class="token operator">:</span> <span class="token class-name">Method</span> <span class="token punctuation">&#123;</span>NAME<span class="token operator">:</span><span class="token string">"readObject"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token number">2</span>  <span class="token keyword">match</span> <span class="token punctuation">(</span>sink<span class="token operator">:</span> <span class="token class-name">Method</span> <span class="token punctuation">&#123;</span>NAME<span class="token operator">:</span><span class="token string">"invoke"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token number">3</span>  <span class="token keyword">call</span> apoc<span class="token punctuation">.</span>algo<span class="token punctuation">.</span><span class="token function">allSimplePaths</span><span class="token punctuation">(</span>sink<span class="token punctuation">,</span> source<span class="token punctuation">,</span> <span class="token string">"&lt;Call|Overriding>"</span><span class="token punctuation">)</span>
   <span class="token keyword">yield</span> path
<span class="token number">4</span>  <span class="token keyword">return</span> path<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>然后，为了使生成的注入对象能够遵循目标gadget链的执行流程，GCMiner通过<code>动态绑定</code>的方式<strong>修改</strong>注入对象的属性值</p></li>
<li><p>对于属性选择，我们通过<code>Java反射</code>动态获取注入对象的每个属性类型[40]-[42]，这允许软件系统在<code>运行时</code>检查和更改其类、接口、方法和字段的行为</p></li>
<li><p>当属性类型是<code>类对象</code>时，该属性将被列为值赋值的候选属性。</p></li>
<li><p>GCMiner 利用 <code>JQF-Zest 算法</code> [44]
来生成新的输入，通过在位级别改变有趣的种子来更深入地进入目标 gadget
链。</p></li>
<li><p>实验的<strong>实现</strong>：</p>
<ol type="1">
<li>tabby: Java代码分析工具</li>
<li>Neo4j: 图数据库</li>
<li>JQF算法：注入对象生成策略</li>
</ol></li>
<li><p>实验<strong>评估指标</strong>：</p>
<ol type="1">
<li>Known Gadget Chains (KGC）</li>
<li>Reported Gadget Chains (Rep)</li>
<li>True Positives (TP)<img
src="https://s2.loli.net/2023/08/12/sfhPjOHJr9u6NIG.png"
alt="image-20230812055654282" /></li>
<li>Precision (P)<img
src="https://s2.loli.net/2023/08/12/VnpwuC1Fo4yORvB.png"
alt="image-20230812055702103" /></li>
</ol></li>
<li><p>从这篇论文中挑选的有用的参考文献：</p>
<ol type="1">
<li>J. C. S. Santos, R. A. Jones, C. Ashiogwu, and M. Mirakhorli,
“Serialization-aware call graph construction“</li>
<li>Y. Wei, X. Sun, L. Bo, S. Cao, X. Xia, and B. Li, “A comprehensive
study on security bug characteristics,”</li>
<li>J. Dahse, N. Krein, and T. Holz, “Code reuse attacks in PHP:
automated POP chain generation,”</li>
<li>I. Haken, “Automated discovery of deserialization gadget chains,” in
Proceedings of the Black Hat USA, 2018.</li>
<li>S. Rasheed and J. Dietrich, “A hybrid analysis to detect java
serialisation vulnerabilities,</li>
</ol>
<p>........</p></li>
</ol>
<h4 id="论文2-1">论文2</h4>
<ol type="1">
<li>论文：<code>A Composite Discover Method for Gadget Chains in Java Deserialization Vulnerability</code></li>
</ol>
<hr />
<ol type="1">
<li>该方法遵循Gadget
Inspector的<code>静态分析</code>来获取待验证的gadget链。在这项工作中，仍然使用<code>符号执行</code>来生成调用图。</li>
<li>这种BFS没有考虑到多个gadget链可能<code>共享节点</code>，这导致只会搜索经过同一节点的多个gadget链中的一个</li>
<li>提出了一种基于<code>Java序列化协议</code>和<code>反射机制</code>的匹配动态验证机制。</li>
<li><code>Java Deserialization Scanner</code>[16]可以证实该策略的有效性。它是著名渗透测试工具`<code>Burp Suite</code>的插件。</li>
<li><code>基于指纹的检测</code>只能检测程序中已知的gadget链的存在，而不能检测程序中未知的gadget链的存在。</li>
<li>A gadget chain can be abstracted as source-&gt;gadget
core-&gt;sink.</li>
<li>我们的<code>静态分析</code>分为以下几个步骤：
<ol type="1">
<li>获取目标程序的类信息和方法信息。</li>
<li>通过符号执行生成调用图。</li>
<li>搜索所有边链。</li>
</ol></li>
<li><code>ASM库</code>[18]，一个优秀的Java字节流操作工具。</li>
<li>使用小工具检查器的<code>符号执行</code>来获得每个方法的调用关系。这些调用关系组成了调用关系图，这个调用关系图被存储为
&lt; <code>call，callee array &gt;</code> 的集合</li>
</ol>
<h4 id="总结-10">总结</h4>
<ol type="1">
<li><strong>论文1总结</strong>：
<ol type="1">
<li>这篇文献主要是针对Java反序列化漏洞：
<ol type="1">
<li>分析了：gadge chain 原理</li>
<li>通过分析<strong>注入对象</strong>的有害数据从<code>source</code>传播到<code>sink</code>验证这条gadge
chain的有效性</li>
<li>自动化生成注入对象进行fuzzing测试</li>
</ol></li>
<li>实验仅粗略查看，总结如下：
<ol type="1">
<li>实验部分<strong>构成</strong>:
<ol type="1">
<li>确定实验研究问题（RQ）</li>
<li>实验实施需要的配置和工具</li>
<li>评估准则</li>
<li>实验方法的效率</li>
<li>与其他方法的全面对比</li>
</ol></li>
</ol></li>
</ol></li>
<li>理解source-sink这个传播路径对于安全研究非常关键</li>
<li>扩大了知识面：了解到了更多相关的漏洞工具、研究方法</li>
<li>没有足够多的论文品读，换个思路可以从<strong>工具源码</strong>、<strong>博客文章</strong>入手</li>
<li>作者在结论中提到:java反序列化漏洞在工业届造成了严重危害，但是学术界关注不多：<code>Java deserialization vulnerability receives little attention in the academic community despite its severe impact in practice.</code></li>
</ol>
<h3 id="section-17">2023-08-15</h3>
<h4 id="论文">论文</h4>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3554732">An In-depth Study
of <strong>Java Deserialization Remote-Code Execution</strong> Exploits
and Vulnerabilities.</a>(<strong>CCF-A</strong>:软件工程顶刊：ACM
Transactions on Software Engineering and Methodology, Volume 32)</li>
<li><a
target="_blank" rel="noopener" href="https://kns.cnki.net/kcms2/article/abstract?v=3uoqIhG8C475KOm_zrgu4sq25HxUBNNTmIbFx6y0bOQ0cH_CuEtpsBEA1ZchHvbBzXSfH-MI98eDZf0c0EzlXHEueUNCTYsU&amp;uniplatform=NZKPT">基于反向污点分析的反序列化漏洞挖掘技术研究</a></li>
</ol>
<h4 id="论文1-5">论文1</h4>
<h5 id="简介">简介</h5>
<ol type="1">
<li>反序列化漏洞非常关键，因此被OWASP列为web应用程序的<strong>十大安全风险之一</strong></li>
<li>Java、PHP和.
NET等几种主流编程语言中的反序列化漏洞，目前主要研究Java中的反序列化漏洞</li>
<li>Java<strong>序列化</strong>允许将类实例转换成字节流。因此，Java对象可以通过<strong>网络传输</strong>。<strong>反序列化</strong>包括读取序列化的字节流，以便通过加载它们的字段来重建<strong>原始实例</strong></li>
<li>当在远程主机上进行反序列化时，可以通过链接称为<strong>gadget的Java代码序列</strong>来控制Java代码的执行流</li>
<li>与其他漏洞相比-反序列化攻击能够<strong>完全控制</strong>受攻击的系统或让位于<strong>勒索软件攻击</strong></li>
<li>文中提到的这个工具我用过：<code>Ysosial</code>是一个提供概念验证工具的项目，并提供了34个在众所周知的反序列化攻击中利用的Java有效负载。</li>
</ol>
<h5 id="重要概念">重要概念</h5>
<ol type="1">
<li><strong>Gadget和Gadget链</strong>。在本文的上下文中，Gadget是一种使用可由攻击者控制的对象或字段的Java方法。小工具链是攻击者创建的一系列恶意方法(小工具)调用。易受攻击的应用程序的类路径中存在一组小工具是执行反序列化攻击所需的条件之一</li>
<li><strong>Java反序列化漏洞</strong>：(1)包含此方法的程序接受并反序列化来自攻击者可以控制的源的数据，以及(2)攻击者可以利用此漏洞。在实践中，(2)需要构建小工具链，因此要求所有必要的小工具都位于易受攻击应用程序的类路径中。</li>
</ol>
<h5 id="示例">示例</h5>
<ol type="1">
<li>著名的<code>CommonsCollections1反序列化攻击</code></li>
<li><code>ysoserial</code>工具可以生成针对于Java反序列化漏洞的恶意代码</li>
</ol>
<h5 id="本文conclusion">本文conclusion</h5>
<ol type="1">
<li>本文是Java反序列化远程代码执行漏洞和漏洞的深入研究。它探讨了反序列化的危险性，以及它如何使应用程序容易受到远程代码执行等攻击的影响。该研究分析了Java库中存在的攻击工具和Java应用程序中的漏洞。它还提出了防止引入攻击工具的库开发人员的建议，并讨论了一些库的修补时间。此外，该研究分析了104个Mitre
CVE，这些CVE涉及Java应用程序中的反序列化漏洞，并得出结论，不是所有的补丁都能防止攻击并保护应用程序。</li>
<li>对于漏洞的修补部分，不做太多关注。而本文也不是关于该漏洞的检测方面的内容。仅仅是对漏洞原理的分析，便能成为该文的一创新点。可见Java反序列化漏洞研究甚少。</li>
</ol>
<h4 id="论文2-2">论文2</h4>
<ol type="1">
<li><p>检索的这篇中文论文：主要是改进污点分析在漏洞检测中的不足。常规污点分析是正向的，本文提出反向分析技术改进了遗漏问题和效率问题。</p></li>
<li><p>PHP反序列化漏洞挖掘流程与Java反序列化漏洞挖掘相似，主要分为四步：</p>
<ol type="1">
<li>使用PHP-Parser工具将PHP源码解析为AST树，并将有用的字节码数据保存进字节码数据库中</li>
<li>然后寻找可控动态函数调用，如所有函数对象和参数对象都可控的<code>a(b)</code>函数调用</li>
<li>接着反向分析函数调用链，构造从危险函数到起点函数的反序列化漏洞链</li>
<li>最后输出所有检出反序列化漏洞链。</li>
</ol></li>
<li><p>基于<code>CodeQL</code>等框架的自动化安全分析技术</p></li>
<li></li>
</ol>
<h4 id="总结-11">总结</h4>
<ol type="1">
<li>需要阅读两方面的论文，也可以说是研究的思路：
<ol type="1">
<li>针对各种漏洞的静态分析框架相关论文：改进静态分析技术本身的缺点（例如检测效率与检测速度之间的平恒问题）</li>
<li>研究反序列化，深入了解反序列化漏洞的特点，针对该特点，去设计相应的检测框架（一种新的检测方法）</li>
</ol></li>
</ol>
<h3 id="section-18">2023-07-29</h3>
<h4 id="学习内容">学习内容</h4>
<ul>
<li><a
href="https://jf710001011.github.io/2023/06/08/static-program-analysis/#toc-heading-58">结束静态分析</a></li>
<li><a
href="https://jf710001011.github.io/2023/07/12/101-ctf/#toc-heading-6">padding
oracle漏洞原理</a></li>
<li><a
href="https://jf710001011.github.io/2023/03/06/portswigger/#toc-heading-37">认证漏洞原理</a></li>
</ul>
<h4 id="总结-12">总结</h4>
<h5 id="静态分析">静态分析：</h5>
<ul>
<li><p>学习了<strong>数据流分析</strong></p>
<ul>
<li><p>变量可达分析</p></li>
<li><p>变量存活分析</p></li>
<li><p>表达式可用分析</p></li>
<li><p>常量传播</p></li>
</ul></li>
<li><p>学习了程序<strong>理论</strong></p>
<ul>
<li>主要是格（lattice）理论</li>
</ul></li>
<li><p>学习了<strong>过程间</strong>分析</p>
<ul>
<li>CHA</li>
<li>控制流图</li>
<li>数据流分析</li>
</ul></li>
<li><p>学习了<strong>指针分析</strong>：在面向对象程序中的作用尤为明显，体现在</p>
<ul>
<li><strong>方法调用</strong></li>
</ul></li>
<li><p>指针分析中的<strong>上下文敏感</strong>分析</p></li>
<li><p>静态分析如何应用<strong>安全研究</strong></p>
<ul>
<li>指针分析和<strong>污点分析</strong>结合</li>
</ul></li>
<li><p>Datalog-Based
程序分析：<strong>声明式语言</strong>在静态分析设计算法有很多优点</p></li>
<li><p>在整个学习过程中：<strong>体会</strong>到了一个完整的解决问题的过程</p>
<ol type="1">
<li>针对问题</li>
<li>设计符号和新的定义</li>
<li>设计规则</li>
<li>算法实现上述内容</li>
</ol></li>
<li><p>积累的算法对我后续的研究奠定了一个<strong>基础</strong></p></li>
</ul>
<h5 id="下一个目标">下一个目标</h5>
<ul>
<li>回到论文</li>
<li>目前打算着手Java中的反序列化漏洞，原因：
<ul>
<li>指针分析利于分析面向对象语言</li>
<li>此漏洞特点：对象之间方法调用复杂</li>
<li>构建相关的对象图、方法调用图、污点分析适合检测此种类型漏洞</li>
</ul></li>
</ul>
<h3 id="section-19">2023-07-22</h3>
<ul>
<li><a
href="https://jf710001011.github.io/2023/06/08/static-program-analysis/#toc-heading-38">静态分析：课程08（Pointer
Analysis） &amp; Pointer Analysis Foundations (I)</a></li>
<li><a
href="https://jf710001011.github.io/2023/03/06/portswigger/#toc-heading-43">漏洞：Cross-site
scripting(XSS)</a></li>
<li>感觉还要一周才能结束剩下的<strong>指针分析</strong>部分：<img
src="https://s2.loli.net/2023/07/22/PUSbpEzxl1sy8MN.png"
alt="image-20230722173813445" /></li>
</ul>
<h3 id="section-20">2023-07-15</h3>
<ul>
<li><a
href="https://jf710001011.github.io/2023/06/08/static-program-analysis/#toc-heading-33">静态分析：foundation2
&amp; Call Graph Construction (CHA)</a></li>
<li><a
href="https://jf710001011.github.io/2023/03/06/portswigger/#toc-heading-2">漏洞：sql
injection</a></li>
</ul>
<h3 id="section-21">2023-07-08</h3>
<ul>
<li><a
href="https://jf710001011.github.io/2023/06/08/static-program-analysis/#toc-heading-21">静态分析-Data
Flow Analysis - Foundations I</a></li>
<li><a
href="https://jf710001011.github.io/2023/03/06/portswigger/#toc-heading-33">漏洞分析-结束Java反序列化漏洞</a></li>
</ul>
<h5 id="总结-13">总结</h5>
<ul>
<li>这周的静态分析<strong>理论性</strong>很强，很多新概念，找到我在读论文时候的那个感觉了，论文正是以这种形式对漏洞检测建模</li>
<li><strong>反序列化漏洞</strong>由于本身的漏洞特性，非常符合我研究的静态分析技术特点，即需要分析源码。
<ul>
<li>果然我之前提到的<strong>advance
topic</strong>上的漏洞都很有研究价值<img
src="https://s2.loli.net/2023/07/08/s2C6cobMyN5wS3p.png"
alt="image-20230708203433921" /></li>
</ul></li>
<li>目前来说我所做的工作：并行学习静态分析和更多的前沿漏洞是<strong>正确的思路</strong>。
<ul>
<li>就差对静态分析的掌握与灵活应用了</li>
</ul></li>
<li><strong>下周</strong>：检索静态分析反序列化漏洞相关论文。</li>
</ul>
<h3 id="section-22">2023-07-01</h3>
<ul>
<li><a
href="https://jf710001011.github.io/2023/06/08/static-program-analysis/#toc-heading-15">学习了静态分析-数据流分析</a></li>
</ul>
<h4 id="总结-14">总结</h4>
<ul>
<li>数据流分析主要涉及程序的变量和表达式</li>
</ul>
<h3 id="section-23">2023-06-24</h3>
<ul>
<li><a
href="https://jf710001011.github.io/2023/06/08/static-program-analysis/#toc-heading-5">学习了静态分析-中间表示</a></li>
<li><a
href="https://jf710001011.github.io/2023/03/06/portswigger/#toc-heading-27">学习了反序列化漏洞</a></li>
</ul>
<h4 id="总结-15">总结</h4>
<ul>
<li>静态分析以及前沿漏洞的学习将持续一段时间，争取一个月内结束</li>
</ul>
<h3 id="section-24">2023-06-09</h3>
<ul>
<li><a
target="_blank" rel="noopener" href="https://dblp.uni-trier.de/search?q=Static%20Analysis%20%20Vulnerabilities">静态分析&amp;漏洞
论文检索</a></li>
</ul>
<h4 id="论文信息-1">论文信息</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://www.usenix.org/conference/14th-usenix-security-symposium/finding-security-vulnerabilities-java-applications-static">Finding
Security Vulnerabilities in Java Applications with Static Analysis</a>
<strong>CCF-A:</strong>USENIX Security Symposium 2005</li>
</ul>
<h4 id="正文-6">正文</h4>
<ul>
<li><p>字节码（Bytecode）是一种中间代码形式，它是在程序源代码经过编译但尚未被执行时生成的。字节码通常与特定的虚拟机（如Java虚拟机）相关联，它们是一种可被虚拟机解释或即时编译执行的指令集。字节码的好处之一是它具有跨平台的特性，因为不同的虚拟机可以解释执行相同的字节码。</p>
<p>在Java中，源代码首先经过编译器编译成字节码文件（以.class为扩展名），然后由Java虚拟机加载和执行这些字节码文件。字节码是一种中间形式，它包含了程序的指令、常量池、字段、方法等信息。通过解释或即时编译，Java虚拟机将字节码转换为机器码，并执行相应的操作。</p></li>
<li><p>污点对象传播问题：论文定义了源（source）、汇（sink）和派生（derivation）描述符来表示安全漏洞的特征。源描述符表示潜在的污点数据来源，汇描述符表示敏感操作的目标，派生描述符表示对象之间的传播关系。</p></li>
<li><p>指针分析：指针分析是静态分析中的关键问题，用于确定程序变量在程序执行期间可能指向的堆对象。论文介绍了基于二叉决策图（BDD）的上下文敏感指针分析算法，该算法在保持精确性的同时实现了可扩展性</p></li>
<li><p>静态安全违规检测：论文提出了使用PQL（Program Query
Language）来描述安全漏洞模式的方法。PQL是一种程序查询语言，通过声明变量、定义匹配模式和指定返回结果，可以方便地表达与程序执行相关的动态事件序列。</p></li>
</ul>
<h4 id="总结-16">总结</h4>
<h5 id="论文总结">论文总结</h5>
<p>作者的方法基于可扩展且精确的指针分析。指针分析是一种确定从给定对象可以访问到的对象集合的技术。这些信息可以用于发现安全漏洞，如SQL注入和跨站脚本攻击。</p>
<p>作者的方法使用上下文敏感的指针分析。这意味着分析考虑了变量的使用上下文。例如，如果一个变量在已知包含用户输入的上下文中使用，那么分析将考虑从该变量可以访问到的所有对象，即使这些对象不是直接从该变量可达的。</p>
<p>作者还使用了一种称为改进对象命名的技术。这种技术通过给对象赋予更有意义的名称来减少误报数量。例如，如果一个对象用于存储用户输入，那么该对象将被赋予反映这一事实的名称。这有助于分析区分可能包含用户输入的对象和不包含用户输入的对象</p>
<h3 id="section-25">2023-06-02</h3>
<h4 id="论文-1">论文</h4>
<h5 id="开篇">开篇</h5>
<ul>
<li><p><strong>论文信息</strong></p>
<p><a
target="_blank" rel="noopener" href="https://www.computer.org/csdl/proceedings-article/sp/2023/933600b059/1NrbYrQrQ2I">Scaling
JavaScript Abstract Interpretation to Detect and Exploit Node.js
Taint-style Vulnerability</a>: <strong>CCF-A</strong>会议：IEEE S&amp;P
2023</p></li>
<li><p><strong>keywords</strong></p></li>
</ul>
<h5 id="正文-7">正文</h5>
<ul>
<li><p>源点和汇点是软件程序中与数据流相关的概念。</p>
<p><code>源点</code>（source）是指程序中产生数据流的起点或来源。它可以是用户输入、传感器数据、文件读取等。源点提供了数据流的初始值或输入，它是数据流的生成者。</p>
<p><code>汇点</code>（sink）是指程序中接收数据流的终点或目标。它可以是数据库写入、网络传输、文件输出等。汇点接收和处理数据流，并对其进行操作或存储，它是数据流的消费者。</p>
<p>数据流从源点开始，通过程序的不同部分传递，最终到达汇点。在安全领域，源点和汇点之间的数据流可能存在安全风险。例如，源点可能包含恶意输入，汇点可能存在安全漏洞，导致恶意输入被利用或导致安全问题。</p></li>
<li><p><strong>现存问题</strong></p>
<ol type="1">
<li>准确性和可扩展性的权衡之</li>
<li>现有的JavaScript静态分析面临的另一个主要挑战是异步函数调用，特别是涉及Promise的函数调用。</li>
</ol></li>
<li><p>描述了一个新的系统，称为
<code>FAST</code>（可扩展性快速抽象解释）：FAST在这一步的<strong>创新之处</strong>在于采用函数作用域而不是调用序列（与之前的工作相比）进行抽象解释。这使得FAST能够高效地分析一个函数，而不是每次函数调用都要重复分析。此外，为了捕捉JavaScript函数调用解析的复杂性，FAST构建了一种新颖的函数依赖图（<code>FDG</code>），描述了函数如何创建、解析或触发其他函数的执行。</p>
<ul>
<li><code>自顶向下</code>的抽象解释修剪了程序，并只分析与可能的污点式汇点具有控制和数据依赖关系的语句
<ul>
<li>符号约束</li>
</ul></li>
</ul></li>
<li><p><strong>Contributions</strong></p>
<ul>
<li>提出了一种两阶段的抽象解释方法，第一阶段生成控制流图，以指导第二阶段的高效分析。</li>
<li>实现了一个名为FAST的原型开源静态工具，用于检测污点式漏洞。</li>
<li>评估结果显示，FAST在减少误报的方面显著优于最先进的漏洞检测工具。</li>
</ul></li>
<li><p>代码分析</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">1</span> <span class="token comment">// util.js</span>
<span class="token number">2</span> <span class="token keyword">const</span> childProcess <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"child_process"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">3</span> <span class="token keyword">const</span> logger <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./logger"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token keyword">function</span> <span class="token function">promisify</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
5return <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
6return <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">executor</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
<span class="token number">7</span><span class="token function">fn</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token number">8</span><span class="token function">if</span> <span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">9</span><span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">11</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token number">13</span> <span class="token punctuation">&#125;</span>
<span class="token number">14</span> <span class="token keyword">function</span> <span class="token function">execProcess</span><span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
15return <span class="token function">promisify</span><span class="token punctuation">(</span>childProcess<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">16</span> <span class="token punctuation">&#125;</span>
<span class="token number">17</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">deflate</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
18const <span class="token function-variable function">flush_pending</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">strm</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
19const s <span class="token operator">=</span> strm<span class="token punctuation">.</span>state<span class="token punctuation">;</span>
<span class="token number">20</span><span class="token comment">// let f(n) = 2*nˆ2,</span>
<span class="token punctuation">,</span>→after k iterations<span class="token punctuation">,</span> there are <span class="token function">fˆk</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> objects
21let len <span class="token operator">=</span> s<span class="token punctuation">.</span>pending<span class="token punctuation">;</span><span class="token comment">// n objs</span>
<span class="token number">22</span><span class="token function">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> strm<span class="token punctuation">.</span>avail_out<span class="token punctuation">)</span>
23len <span class="token operator">=</span> strm<span class="token punctuation">.</span>avail_out<span class="token punctuation">;</span><span class="token comment">// 2*n objs</span>
24strm<span class="token punctuation">.</span>avail_out <span class="token operator">-=</span> len<span class="token punctuation">;</span><span class="token comment">// 2*nˆ2 objs</span>
<span class="token number">25</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token number">26</span><span class="token function">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// ...k*k iterations</span>
<span class="token number">27</span><span class="token function">while</span> <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//...k iterations</span>
<span class="token number">28</span><span class="token function">flush_pending</span><span class="token punctuation">(</span>strm<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ...</span>
<span class="token number">29</span><span class="token punctuation">&#125;</span>
<span class="token number">30</span><span class="token punctuation">&#125;</span>
<span class="token number">31</span> <span class="token punctuation">&#125;</span>
<span class="token number">32</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">compress</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token number">33</span><span class="token function">switch</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>alg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
34case ’zip’<span class="token operator">:</span>
35return <span class="token keyword">await</span> <span class="token function">deflate</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
36case ’xz’<span class="token operator">:</span>
37var command <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"xz"</span><span class="token punctuation">,</span> <span class="token string">"--stdout"</span><span class="token punctuation">,</span> <span class="token string">"-k"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token number">38</span><span class="token function">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>path<span class="token punctuation">)</span>
39command<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
40else
41command<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
42command <span class="token operator">=</span> command<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>
43logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>‘xz<span class="token punctuation">,</span> $<span class="token punctuation">&#123;</span>command<span class="token punctuation">&#125;</span>‘<span class="token punctuation">)</span><span class="token punctuation">;</span>
44return <span class="token keyword">await</span> <span class="token function">execProcess</span><span class="token punctuation">(</span><span class="token string">"exec"</span><span class="token punctuation">)</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">45</span><span class="token punctuation">&#125;</span>
<span class="token number">46</span> <span class="token punctuation">&#125;</span>
<span class="token number">47</span> module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Util</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token number">48</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>compress <span class="token operator">=</span> compress<span class="token punctuation">;</span>
<span class="token number">49</span> <span class="token comment">// exploit code, under attacker control</span>
<span class="token number">50</span> <span class="token keyword">const</span> Util <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span>’util<span class="token punctuation">.</span>js’<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">51</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Util</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compress</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">’alg’</span><span class="token operator">:</span> ’xz’<span class="token punctuation">,</span> <span class="token literal-property property">’path’</span><span class="token operator">:</span> ’<span class="token punctuation">;</span> touch
<span class="token punctuation">,</span>→exploit #’ <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>漏洞原理：</strong></p>
<ol type="1">
<li><p>在第51行，通过<code>const Util = require('util.js');</code>导入了<code>util.js</code>模块，并创建了一个<code>Util</code>的实例。</p></li>
<li><p>在第51行的代码<code>(new Util()).compress(&#123; 'alg': 'xz', 'path': '; touch exploit #' &#125;);</code>中，调用了<code>Util</code>实例的<code>compress</code>方法，并传入了一个包含选项的对象作为参数。其中，<code>alg</code>选项的值为'xz'，<code>path</code>选项的值为';
touch exploit #'。</p></li>
<li><p>在<code>compress</code>方法中，根据<code>options.alg</code>的值进行条件判断。</p></li>
<li><p>当<code>options.alg</code>的值为'xz'时，执行37-44行的代码块。这段代码构建一个命令，并将其作为字符串拼接到<code>command</code>变量中。如果<code>options.path</code>为空，则拼接的命令为"xz
--stdout -k data"；否则，拼接的命令为"xz --stdout
-k"加上<code>options.path</code>的值。最后，通过调用<code>execProcess("exec")</code>方法，将命令作为参数传递给<code>childProcess.exec</code>函数进行执行。</p></li>
<li><p>漏洞出现在拼接命令的过程中。由于未对<code>options.path</code>进行适当的输入验证或过滤，攻击者可以在<code>options.path</code>中注入恶意的操作系统命令。在这个例子中，注入的命令是";
touch exploit
#"，它会尝试在操作系统中执行<code>touch</code>命令创建一个名为"exploit"的文件。</p></li>
<li><p>漏洞的利用代码出现在49-51行，攻击者通过传入恶意的<code>options.path</code>，即";
touch exploit
#"，来触发操作系统命令注入漏洞。当程序执行到这部分代码时，恶意命令将被执行，导致在操作系统中创建了一个名为"exploit"的文件。</p></li>
</ol>
<p>因此，这个操作系统命令注入漏洞使得攻击者能够在执行压缩操作时执行任意的操作系统命令，从而对系统造成潜在的安全风险。</p></li>
<li><p><strong>Vulnerability Detection Challenges</strong></p>
<ol type="1">
<li><p>accuracy-scalability trade-off</p>
<blockquote>
<ol type="1">
<li>首先，静态地解析fn是具有挑战性的，因为fn在promisify的闭包中被定义为函数参数。其次，childProcess[method]的解析取决于第14行的函数参数method，该参数作为字符串传递给第44行的函数。最后，尽管在第7行注册了回调函数cb，但是异步函数仅在第44行执行，当await等待所有的promise被解决时。事实上，经典的静态分析[4]无法解析fn（第7行）或childProcess[method]（第15行），导致控制流图中缺少调用边缘，从而导致漏报漏洞。</li>
<li>抽象解释常常面临对象爆炸的问题。也就是说，涉及的对象数量可能呈指数级增加，导致需要大量的存储空间来存储对象，并且需要过多的时间来确定每个对象。</li>
</ol>
</blockquote></li>
<li><p>vulnerability validation</p></li>
</ol></li>
<li><p>FAST包含<strong>三个阶段</strong>：</p>
<ul>
<li><ol type="i">
<li>控制流路径生成阶段，使用自底向上的抽象解释来构建控制流图，并找到从入口点到汇函数的路径；</li>
</ol></li>
<li><ol start="2" type="i">
<li>数据流路径生成阶段，使用自顶向下的抽象解释来根据第一阶段中的控制流路径生成准确和有信息量的数据流路径</li>
</ol></li>
<li><ol start="3" type="i">
<li>漏洞利用生成阶段，将数据流路径转换为约束，并解决这些约束以生成漏洞利用代码。</li>
</ol></li>
</ul></li>
<li><p><strong>可扩展性</strong>是指系统能够有效地处理大规模代码和复杂性的能力。在软件漏洞检测中，可扩展性是一项重要的挑战，因为现实世界中的代码规模庞大且复杂</p></li>
<li><p>提取控制流和数据流约束以供<code>约束求解器</code>使用</p></li>
</ul>
<h4 id="总结-17">总结</h4>
<ul>
<li><p><strong>论文总结</strong>：</p>
<p>本文是一篇关于使用<strong>FAST</strong>（一种用于检测和利用Node.js污点风格漏洞的两阶段抽象解释方法）的论文。文章介绍了FAST的<strong>两个阶段</strong>：bottom-up
abstract interpretation和top-down abstract
interpretation，并详细描述了它们如何优化抽象解释过程以提高分析效率。文章还讨论了现有方法在检测taint-style漏洞时存在的问题，以及JavaScript语言中静态分析<strong>可扩展性和准确性之间的固有权衡</strong>。最后，作者通过实验验证了FAST在检测Node.js应用程序中污点风格漏洞方面的有效性和可扩展性。</p></li>
<li><p>本文还将作者之前提出的框架<code>ODGen</code>（见之前原型污染相关文章）进行了对比，可以说本文是对之前自己所做研究成果的进一步完善</p></li>
</ul>
<hr />
<h4 id="补充">补充：</h4>
<ul>
<li>太难，留着以后回看</li>
</ul>
<h3 id="section-26">2023-05-19</h3>
<h4 id="学习笔记和漏洞研究记录">学习笔记和漏洞研究记录</h4>
<ul>
<li><p><a
href="https://jf710001011.github.io/2023/05/02/javascript/">web &amp;
js</a></p>
<p>其中<strong>重点内容</strong>是：</p>
<ul>
<li>表单的提交：这可能涉及用户提交的个人信息（如账号密码），此处是漏洞研究的主要目标。</li>
<li>Js程序在用户与浏览器交互 和
浏览器与服务器交互中扮演的重要作用。</li>
</ul></li>
<li><p><strong><a
href="https://jf710001011.github.io/2023/03/06/portswigger/">漏洞研究</a></strong>：</p>
<p>当涉及到<code>AngularJS</code>时，XSS漏洞可能会在没有HTML的情况下发生，这是PortSwigger研究团队在其文章《<code>XSS without HTML: Client-Side Template Injection with AngularJS</code>》中提到的主题。<strong>总结</strong>如下：</p>
<ul>
<li>AngularJS是一种流行的JavaScript框架，用于创建单页应用程序。</li>
<li>AngularJS模板用于在客户端渲染HTML内容。</li>
<li>AngularJS模板可能会被注入恶意代码，从而利用XSS漏洞。</li>
<li>有多种方式可以将恶意代码注入到AngularJS模板中，包括：
<ul>
<li>使用未经过清理的用户输入。</li>
<li>使用第三方库。</li>
<li>使用AngularJS指令。</li>
<li>一旦将恶意代码注入到AngularJS模板中，就可以在受害者的浏览器上执行任意JavaScript代码。
<ol type="1">
<li>这可以用于窃取Cookie、会话令牌和其他敏感信息。</li>
<li>还可以用于劫持受害者的浏览器并执行其他恶意操作。</li>
</ol></li>
</ul></li>
<li>文章提供了一些预防AngularJS应用程序中XSS漏洞的建议。这些建议包括：
<ul>
<li>在将用户输入用于AngularJS模板之前对其进行清理。</li>
<li>仅使用可信任的第三方库。</li>
<li>在使用AngularJS指令之前仔细审查它们。</li>
<li>及时更新AngularJS以获取最新的安全补</li>
</ul></li>
</ul></li>
</ul>
<h4 id="总结-18">总结</h4>
<ul>
<li>最近都是以实验、实践的形式在研究发现漏洞的手法：主要是使用<strong>国外安全团队的Lab研究博客</strong>作为学习资料</li>
<li>学习过程中对其中的<strong>关键应用程序代码</strong>和<strong>注入的恶意代码</strong>进行了细致学习，学习了漏洞原理和发掘漏洞的思路。</li>
</ul>
<h3 id="section-27">2023-05-12</h3>
<h4 id="我的学习笔记">我的学习笔记</h4>
<ul>
<li><a
href="https://jf710001011.github.io/2023/05/02/javascript/">Web开发与JavaScript编程</a></li>
<li><a
href="https://jf710001011.github.io/2023/03/06/portswigger/">漏洞的学习</a></li>
</ul>
<h3 id="section-28">2023-05-05</h3>
<h4 id="paper">paper</h4>
<ul>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3468264.3468542">Detecting
Node.js prototype pollution vulnerabilities via object lookup
analysis</a>(<strong>CCF-A</strong>:ESEC/SIGSOFT FSE 2021)</li>
<li><strong>Author</strong>:Song Li</li>
</ul>
<h4 id="正文-8">正文</h4>
<ul>
<li><p>源对象和汇对象是在数据流分析中常用的两个术语。</p>
<p><strong>源对象</strong>是数据流分析中的输入，也就是程序中已经存在的数据，可以被使用或传递到其他地方。例如，一个函数的参数或者全局变量。</p>
<p><strong>汇对象</strong>则是分析结果的输出，也就是数据流分析发现的结果。通常来说，汇对象会根据分析的目的而有所不同。例如，在安全漏洞检测中，汇对象可能是程序中的一段危险代码，或者一处未经正确验证的用户输入。</p>
<p>在数据流分析过程中，源对象和汇对象都是需要被识别和跟踪的。数据流分析的目的通常就是为了找到源对象和汇对象之间的关系，并且确定其中潜在的漏洞或其他问题。</p></li>
<li><p><strong>CCS
CONCEPTS</strong>是ACM计算机协会提出的一种分类体系，用于分类和描述计算机科学领域中的概念和研究方向。其中涉及到的两个概念是“Security
and privacy”和“Software and its engineering”。</p>
<p>“<code>Security and privacy</code>”指的是关于计算机安全和隐私的研究方向，其中Web应用程序安全是一个子领域，主要研究如何保护Web应用程序免受各种威胁和攻击，例如跨站脚本攻击（XSS）、SQL注入、CSRF攻击等。</p>
<p>“<code>Software and its engineering</code>”指的是关于软件及其工程的研究方向，主要涉及软件开发、测试、部署、维护等方面。在软件工程领域，安全是一个非常重要的考虑因素，因为安全漏洞可能导致系统失效、用户信息泄露等严重后果。因此，在软件工程中，需要关注如何设计和实现安全的软件系统。</p></li>
<li><p><strong>KEYWORDS</strong> Abstract Interpretation,</p>
<p>Prototype Pollution,</p>
<p>Object Lookup Analysis,</p>
<p>JavaScript</p></li>
<li><p>Js<strong>动态重定义</strong>内置函数</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 定义一个自定义的log函数</span>
<span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Custom log: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>message<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 使用自定义的log函数替换掉内置的console.log函数</span>
console<span class="token punctuation">.</span>log <span class="token operator">=</span> log<span class="token punctuation">;</span>

<span class="token comment">// 测试一下，现在调用console.log实际上是调用我们定义的log函数了</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello, world!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>JavaScript 中，对象可以通过一个内部的属性 <code>__proto__</code>
来指向另一个对象，这个对象被称为原型对象。如果一个对象试图访问一个不存在的属性，JavaScript
引擎会在该对象的原型对象上继续查找这个属性，如果在原型对象上也找不到，就会在原型对象的原型对象上查找，直到找到该属性或者到达<strong>原型链的末尾</strong>（即
Object.prototype）</p></li>
<li><blockquote>
<p><strong>The major challenges</strong> come from the complexity of the
sink and source structures in prototype pollution detection using static
analysis.</p>
</blockquote></li>
<li><p>在软件安全领域中，<code>sink（漏洞点）</code>通常指代那些潜在的漏洞利用点或攻击目标，例如对输入数据的不当处理或未正确验证可能导致的注入攻击、XSS（跨站脚本）漏洞、CSRF（跨站请求伪造）漏洞等。在上下文敏感分析中，sink通常是程序中的一个<strong>函数调用</strong>，它从潜在的漏洞源中接收输入并进行进一步处理，因此可能受到恶意输入的影响。在ObjLupAnsys中，sink指的是<strong>系统内置函数</strong>，例如Object.prototype.toString，该函数可能被重新定义以实现攻击效果。</p></li>
<li><p>我们讲解的是原型污染漏洞中的<code>源（source）对象</code>。通常，传统漏洞（如命令注入漏洞）的源对象是一个简单类型的<strong>用户输入，</strong>比如字符串。因此，可以简单地将这些输入标记为污点数据。但是，在原型污染漏洞中，源对象通常是一个包含<strong>复杂结构</strong>的对象，例如从
JSON
输入解析而来的对象。挑战在于，输入对象的结构通常是<strong>未知的、动态的</strong>，即由攻击者决定的。因此，简单地将对象标记为污点数据并不能反映其内部结构，以及该结构如何影响上述“sink”对象的查找。</p></li>
<li><p><code>污点分析</code>是一种静态或动态代码分析技术，用于检测和防范安全漏洞，特别是与输入验证和数据处理相关的漏洞。其核心思想是标记数据流中可能被污染（即潜在攻击数据）的变量或参数，并<strong>跟踪</strong>这些污点在程序中的流动，以检测可能的漏洞点。如果一个污点最终到达了一个<strong>敏感函数</strong>（如系统调用、SQL查询、文件操作等），就会被判定为漏洞，并触发警报或其他防御措施。污点分析可以通过<strong>数据流分析、控制流分析、符号执行</strong>等技术实现。它已经成为软件安全分析的重要工具之一，在漏洞挖掘、漏洞修复、软件测试等方面都有广泛应用。</p></li>
<li><p><code>符号执行</code>的基本思想是：将程序中的每个变量符号化，然后从程序的入口点开始执行程序，为每个条件语句创建一个分支，将每个分支上的每个符号变量的所有可能取值表示为约束条件，并对这些约束条件求解，以确定程序路径的所有可能走向。通过对程序的每个路径进行符号执行，可以查找程序中的漏洞或错误，并生成相应的测试用例，以验证程序的正确性。</p></li>
<li><p><strong>代码分析</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// (a) Vulnerable code:</span>
<span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> p <span class="token keyword">in</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                a<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                a<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            a<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>config<span class="token punctuation">.</span>userId<span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Config must have userId '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>config<span class="token punctuation">.</span>password<span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Config must have password '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">...</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>config <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>defaultConfig<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token operator">...</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Paypal<span class="token punctuation">;</span>

<span class="token comment">// (b) Exploit</span>
<span class="token keyword">var</span> PayPal <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'paypal -adaptive '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PayPal</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>
    <span class="token string">'&#123;" __proto__ ": &#123;" toString ": "polluted"&#125;, "userId ":"foo", "password ": "bar", "signature ": "abcd","appId ": "1234", "sandbox ": "1234"&#125; '</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toString<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol type="a">
<li><p>这段代码定义了一个 <code>merge</code>
函数，用于合并两个对象。它的输入是两个对象 <code>a</code> 和
<code>b</code>，其中 <code>b</code> 对象的属性会覆盖 <code>a</code>
对象中同名属性的值。具体来说，它会递归地合并两个对象的属性，当某个属性的值是一个对象时，就递归调用
<code>merge</code>
函数，将该属性的值继续合并。如果某个属性的值不是对象，就直接用
<code>b</code> 对象中该属性的值覆盖 <code>a</code>
对象中的值。如果在合并过程中发生异常，则直接用 <code>b</code>
对象中该属性的值覆盖 <code>a</code> 对象中的值。最后返回合并后的
<code>a</code> 对象。</p></li>
<li><p>这段代码首先导入了一个名为 <code>paypal-adaptive</code>
的模块，然后创建了一个 <code>PayPal</code> 类的实例
<code>p</code>。在创建 <code>p</code> 的时候，它的构造函数接收一个 JSON
字符串作为参数，该字符串描述了一个具有 <code>__proto__</code>
属性的对象，该属性的值是一个对象，其中有一个名为 <code>toString</code>
的属性，值为字符串 <code>"polluted"</code>。该 JSON 字符串还描述了
<code>userId</code>、<code>password</code>、<code>signature</code>、<code>appId</code>
和 <code>sandbox</code> 等属性。由于该 JSON 对象具有
<code>__proto__</code> 属性，这可能导致 Prototype Pollution
漏洞。</p></li>
</ol>
<p>接下来，在输出日志信息时，该代码调用了一个空对象 <code>(&#123;&#125;)</code> 的
<code>toString</code>
方法，由于该空对象的原型链被污染，所以该代码实际上调用的是
<code>polluted</code> 字符串的 <code>toString</code>
方法，最终输出的是字符串 <code>"polluted"</code>。</p>
<p><strong>污染过程</strong>：</p>
<p>该空对象的原型链被污染是因为在第三行代码中，攻击者通过向构造函数的参数中传递一个具有特殊属性__proto__的JavaScript对象来污染了空对象的原型链。在第五行代码中，merge函数对对象b的属性进行遍历，将属性值复制到对象a中。由于b对象具有特殊属性__proto__，因此在第五行中，if条件为真，将a[p]的原型链设置为b[p]的原型链，从而将a[p]对象的原型链污染为攻击者控制的对象的原型链。这样，在第六行代码中，当检查空对象的原型链时，它将返回被污染的原型链。这是一个典型的原型污染攻击。</p></li>
<li><p><code>CVE-2020-7643</code>是一个影响Node.js的漏洞，属于Prototype
Pollution漏洞类型。该漏洞的影响版本为Node.js
12.x版本，利用该漏洞，攻击者可以通过构造恶意数据来污染JavaScript对象的原型链，从而导致代码执行漏洞。</p>
<p>具体来说，在Node.js中，有一些<strong>内置模块</strong>（比如querystring模块），会将查询字符串解析为JavaScript对象。攻击者可以在查询字符串中携带特殊构造的__proto__属性，这会导致在解析过程中创建的JavaScript对象的原型链被污染。如果攻击者能够控制该对象的原型链，则可以在目标系统上执行任意JavaScript代码，从而导致严重的安全问题。</p>
<p>该漏洞的修复包括在Node.js
v12.16.2、v10.19.0和v8.17.0版本中，Node.js官方已发布安全更新，建议用户及时升级到最新版本来修复该漏洞。</p></li>
<li><p><code>静态分析</code>可以找到所有的可能路径和条件，但可能会错过一些动态执行的情况。而<code>动态分析</code>可以发现动态执行的情况，但无法保证所有的路径和条件都能够被触发。因此，在某些情况下，需要同时使用静态和动态分析来发现漏洞</p></li>
<li><p>本文提出了<strong>三个细粒度污染流</strong>，即对象污染流、函数污染流和属性污染流</p></li>
<li><p>JavaScript具有很强的<strong>动态特性</strong>，包括以下几个方面：</p>
<ol type="1">
<li>动态类型：JavaScript是一种动态类型语言，变量的类型是在运行时确定的，而不是在编译时。</li>
<li>动态解释执行：JavaScript代码不需要编译成二进制代码，而是在执行时解释执行。</li>
<li>动态对象：JavaScript中的对象是动态的，可以在运行时添加、删除和修改属性。</li>
<li>动态作用域：JavaScript中的作用域是基于函数的，而不是基于块的。因此，作用域链是在函数调用时动态生成的。</li>
<li>动态闭包：JavaScript中的闭包可以在运行时动态生成，通过闭包可以实现函数的嵌套和变量的私有化。</li>
<li>动态函数：JavaScript中的函数可以在运行时动态生成和修改，可以通过Function构造函数和eval函数实现。</li>
<li>动态模块加载：JavaScript中的模块可以在运行时动态加载，可以通过import函数和动态脚本标签实现。</li>
</ol>
<p>以上特性也是使得JS<strong>出现各种漏洞的原因</strong></p></li>
</ul>
<h4 id="总结-19">总结</h4>
<ul>
<li><p><strong>文献总结</strong></p>
<ul>
<li><p><strong>研究背景</strong>：原型污染是一种常见的安全漏洞，它可以导致恶意攻击者在应用程序中执行任意代码或获取敏感信息。目前已经有一些针对原型污染漏洞的检测和预防技术，但它们通常只能检测到一些简单的漏洞，并且存在误报率较高的问题。因此，本文旨在提出一种更准确和有效的原型污染检测和预防技术。</p></li>
<li><p><strong>创新之处</strong>：本文提出了一种基于对象查找分析（Object
Lookup
Analysis）的方法，用于检测和预防JavaScript应用程序中的原型污染漏洞。该方法利用Object
Property
Graph（OPG）模型来捕获JavaScript对象之间的相互作用关系，并设计了一个名为ObjLupAnsys的框架来进行对象查找分析和漏洞检测。</p></li>
</ul></li>
<li><p>Song Li <strong>三文对比</strong></p>
<ol type="1">
<li><a
target="_blank" rel="noopener" href="https://www.usenix.org/conference/usenixsecurity22/presentation/li-song">Mining
Node.js Vulnerabilities via Object Dependence Graph and
Query</a>(<strong>CCF-A</strong>:31st USENIX Security Symposium
2022)</li>
<li><a
target="_blank" rel="noopener" href="https://www.ndss-symposium.org/ndss-paper/auto-draft-207/">Probe
the Proto: Measuring Client-Side Prototype Pollution Vulnerabilities of
One Million Real-world Websites</a>(<strong>CCF-A</strong>会议：NDSS
2022)</li>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3468264.3468542">Detecting
Node.js prototype pollution vulnerabilities via object lookup
analysis</a>(<strong>CCF-A</strong>:ESEC/SIGSOFT FSE 2021)</li>
</ol>
<p>本文与Song
Li前两篇文献整体框架如出一辙，但是我是<strong>逆着</strong>作者文章发表顺序阅读的，更准确地说这篇更像是ODGen的雏形。本文提出的是OPG，相比于他后续提出的ODG，工作量明显是更小的。</p>
<p>总的来说，无论是OPG（对象属性图）还是ODG（对象依赖图），作者研究的都是<strong>对象层次</strong>（不是函数或者普通变量）；其无论是属性图还是依赖图，都是以往已经提出并写进大学教材的程序分析方式，作者都是基于这些内容，去研究JS对象中的原型污染问题。</p>
<p>三篇文献的<strong>框架</strong>都类似：提出一种数据结构（分析程序的方法），做出基于此方法的自动化工具（系统框架）。评估标准也是类似。</p>
<p>我感觉第二篇是最难读懂的，这一篇也还是有挺多疑问的地方</p></li>
</ul>
<h3 id="section-29">2023-04-28</h3>
<h4 id="paper信息">paper信息</h4>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://www.ndss-symposium.org/ndss-paper/auto-draft-207/">Probe
the Proto: Measuring Client-Side Prototype Pollution Vulnerabilities of
One Million Real-world Websites</a>(<strong>CCF-A</strong>会议：NDSS
2022,Song Li)</p></li>
<li><p><strong>keywords</strong>:</p>
<p>Prototype Pollution</p>
<p>Joint Taint Flow Analysis</p>
<p>Dynamic Taint Analysis</p></li>
</ul>
<h4 id="正文-9">正文</h4>
<ul>
<li><p>从<strong>title</strong>上看注意到，作者这次研究的客户端上的<code>JS</code></p></li>
<li><p><strong>原型污染</strong>的出处：文献[6]</p></li>
<li><p>讨论了原型污染的后果，除了污染原型对象本身之外，原型污染还可能导致<strong>其他安全问题</strong>。</p>
<p><strong>举例</strong>：<code>如果另一段JavaScript代码与原型污染漏洞位于同一位置，并循环遍历对象下的所有具有常量值的属性以生成HTML代码，则该原型污染将允许攻击者注入任意JavaScript代码，从而导致跨站脚本攻击（XSS）的发生</code></p>
<p>假设存在以下JavaScript代码段：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 此处省略了获取input的代码</span>
<span class="token keyword">var</span> input <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> input<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">" = "</span> <span class="token operator">+</span> input<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"&lt;br>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该代码段遍历了一个名为input的对象的所有属性，并生成相应的HTML代码。
如果input对象被受到原型污染漏洞的影响，攻击者可以注入任意JavaScript代码，并因此导致跨站脚本攻击。</p>
<p>例如，攻击者可以将<code>Object.prototype</code>修改为：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">someEvilFunction</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'gotcha'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在这种情况下，JavaScript代码段将被修改为：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> input <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token function-variable function">someEvilFunction</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'gotcha'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> input<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">" = "</span> <span class="token operator">+</span> input<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"&lt;br>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在运行这段代码时，会执行被注入的<code>someEvilFunction</code>函数，导致一个弹窗出现，从而执行了跨站脚本攻击。</p>
<p><code>Object.prototype</code> 是所有 JavaScript 对象的原型对象。它是
JavaScript
中最顶层的原型对象，所有的内置对象都继承自它，包括数组、函数、日期、正则表达式等。在
JavaScript
中，每个对象都有一个原型对象，它会自动继承原型对象的属性和方法。通过
<code>Object.prototype</code>，我们可以为所有的对象添加共享的属性和方法。</p></li>
<li><p>关于原型污染引起的<code>Xss</code>漏洞研究，可以关注的<strong>博客</strong>和<strong>github
repository</strong>：文献[9] [10] [6] [24] [29]</p></li>
<li><p>在测量客户端原型污染和后续影响方面，有<strong>两个主要挑战</strong>：</p>
<ol type="1">
<li><p>原型污染和后续影响通常包括两个或更多个链接在一起的属性查找。因此，
PROBETHEPROTO
通过动态污点分析跟踪这些联合污点流来检测原型污染，并引导对象查找传播污点到最终的后果相关的终端接收器（例如
innerHTML）。</p>
<p>假设有一个网站使用了一个第三方 JavaScript
库，其中存在一个漏洞导致原型污染。攻击者可以利用此漏洞在该网站上执行任意代码。攻击者可以将恶意代码注入到网站上，以窃取用户的登录凭据或将用户重定向到其他恶意网站上。攻击者使用以下代码来执行原型污染攻击：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>polluted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这段代码将污染 Object 类型的原型，因此所有基于 Object 的 JavaScript
对象都将受到影响。例如，攻击者可以在以下位置注入恶意代码：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> user_input <span class="token operator">=</span> document<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> user_input<span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>div<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个例子中，攻击者可以通过 user_input 参数注入一个包含恶意脚本的
URL，该脚本会被注入到 div 元素的 innerHTML 属性中。由于 innerHTML
属性具有副作用，攻击者的恶意代码将被执行，导致进一步的攻击。</p>
<p>PROBETHEPROTO 通过动态污点分析追踪了用户输入到 innerHTML
属性的数据流。当 innerHTML
属性被污染时，它被标记为受到攻击的污点，并且跟踪整个数据流直到最终的影响。通过这种方式，PROBETHEPROTO
可以检测出潜在的原型污染漏洞以及它们的后续影响。</p></li>
<li><p>原型污染后续影响的最终接收器可能无法直接到达。因此，
PROBETHEPROTO
采用输入/利用程序生成模块，根据属性查找和接收器函数主动创建对象属性。PROBETHEPROTO执行多个动态污点分析运行。一次运行将记录缺失的属性查找和中间接收器，然后
PROBETHEPROTO
将在后续运行中包括这些缺失属性，以达到与后续影响相关的最终接收器。</p>
<p>举个例子，假设有一个网站上的代码如下：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> prop <span class="token operator">=</span> <span class="token string">"userInput"</span><span class="token punctuation">;</span>
obj<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"safe value"</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> inputValue <span class="token operator">=</span> <span class="token function">getQueryStringValue</span><span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>inputValue<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  obj<span class="token punctuation">[</span>inputValue<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"evil value"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> obj<span class="token punctuation">.</span>userInput<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个例子中，如果攻击者控制了输入值
<code>inputValue</code>，并将其设置为 <code>__proto__</code>，则可以在
<code>obj</code> 对象的原型链上污染 <code>userInput</code>
属性，使其指向一个恶意值。由于 <code>innerHTML</code> 函数的输出将包含
<code>userInput</code>
属性的值，因此攻击者可以利用这种原型污染漏洞，将任意恶意代码注入到网站页面中，从而实现
XSS 攻击。</p>
<p>为了检测这种原型污染漏洞和其后续影响，PROBETHEPROTO将跟踪
<code>obj</code>
对象的属性查找，并在发现原型污染时引入污点值。然后，PROBETHEPROTO将使用动态污点分析生成一个利用程序，将
<code>inputValue</code> 设置为
<code>__proto__</code>，以演示攻击者如何利用此漏洞。最终，PROBETHEPROTO将观察到
<code>innerHTML</code>
函数作为最终接收器，以检测任何潜在的后续影响。</p></li>
</ol></li>
<li><p><strong>漏洞原理</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/* Exploit: https://www.boulderboats.com/default.asp?
__proto__[k]=&lt;script>alert(1)&lt;/script>&amp;
page=xAllInventory&amp;make=chaparral */</span>
<span class="token comment">// Step 1: polluting the prototype</span>
<span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">Q</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//Q="__proto__[k]=&lt;script>alert(1)&lt;/script>"</span>
    <span class="token keyword">var</span> <span class="token constant">H</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// 创建空对象 H</span>
        <span class="token constant">K</span> <span class="token operator">=</span> <span class="token constant">Q</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"="</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 将传入参数按照等号分割为数组 K</span>
        <span class="token comment">/* 例如：Q="__proto__[k]=&lt;script>alert(1)&lt;/script>"
        则 K = ["__proto__[k]", "&lt;script>alert(1)&lt;/script>"] */</span>
        <span class="token constant">P</span> <span class="token operator">=</span> <span class="token function">decodeURIComponent</span><span class="token punctuation">(</span><span class="token constant">K</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 将 K 中的第一个元素进行 URL 解码，得到 P</span>
        <span class="token comment">// P = "__proto__[k]"</span>
        <span class="token constant">J</span><span class="token punctuation">,</span> <span class="token comment">// 声明变量 J</span>
        <span class="token constant">O</span> <span class="token operator">=</span> <span class="token constant">H</span><span class="token punctuation">,</span> <span class="token comment">// 将对象 H 赋值给 O</span>
        <span class="token constant">M</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// 声明变量 M，初始化为 0</span>
        <span class="token constant">R</span> <span class="token operator">=</span> <span class="token constant">P</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"]["</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 P 按照中括号分割为数组 R</span>
    <span class="token comment">// 例如：R = ["__proto__[k]"];</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\[</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token constant">R</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\]$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token constant">R</span><span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 判断 R 中的第一个和最后一个元素是否以中括号开头和结尾</span>
        <span class="token constant">R</span><span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\]$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 R 中的最后一个元素的结尾中括号去掉</span>
        <span class="token constant">R</span> <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"["</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token constant">R</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 R 中的第一个元素通过 shift() 方法移除，并按照中括号再次分割，与剩下的元素合并为新的数组</span>
        <span class="token comment">/* 例如：R = ["__proto__", "k"] */</span>
        <span class="token constant">N</span> <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 记录 R 数组的长度减一</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">K</span><span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token constant">J</span> <span class="token operator">=</span> <span class="token function">decodeURIComponent</span><span class="token punctuation">(</span><span class="token constant">K</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* J = "&lt;script>alert
(1)&lt;/script>" */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">N</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token constant">M</span> <span class="token operator">&lt;=</span> <span class="token constant">N</span><span class="token punctuation">;</span> <span class="token constant">M</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token constant">P</span> <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">[</span><span class="token constant">M</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">""</span> <span class="token operator">?</span> <span class="token constant">O</span><span class="token punctuation">.</span>length <span class="token operator">:</span> <span class="token constant">R</span><span class="token punctuation">[</span><span class="token constant">M</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token comment">// P = "__proto__" (when M=0); P = "k" (when M=1)</span>
                <span class="token constant">O</span> <span class="token operator">=</span> <span class="token constant">O</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">M</span> <span class="token operator">&lt;</span> <span class="token constant">N</span> <span class="token operator">?</span> <span class="token constant">O</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token constant">R</span><span class="token punctuation">[</span><span class="token constant">M</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token constant">R</span><span class="token punctuation">[</span><span class="token constant">M</span> <span class="token operator">+</span>
                    <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token constant">J</span>
                <span class="token comment">// O=O["__proto__"]=Object.prototype (when M=0)</span>
                <span class="token comment">// O=O["k"]="&lt;script>alert(1)&lt;/script>" (when M=1)</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// Step 2: injecting third-party code</span>
<span class="token keyword">var</span> $unitSpecs <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"&lt;ul/>"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addClass</span><span class="token punctuation">(</span><span class="token string">"unitSpecs"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">//$unitSpecs is a DOM element</span>
    data <span class="token operator">=</span> <span class="token punctuation">&#123;</span> ’<span class="token number">123</span><span class="token literal-property property">’</span><span class="token operator">:</span> ’abc’ <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> field <span class="token keyword">in</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// field = "k"</span>
    $unitSpecs<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"&lt;li>&lt;span class=’"</span> <span class="token operator">+</span> field <span class="token operator">+</span> <span class="token string">"’>"</span> <span class="token operator">+</span>
        data<span class="token punctuation">[</span>field<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"&lt;/span>&lt;/li>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// data["k"]="&lt;script>alert(1)&lt;/script>"</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>假设传入的参数为：Q =
"<strong>proto</strong>[k]=<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>&amp;page=xAllInventory&amp;make=chaparral"</p>
<p><strong>Step 1:</strong></p>
<ol type="1">
<li>函数定义了一个变量 H，创建一个空对象。</li>
<li>将传入参数按照等号分割为数组 K，K[0] 为
"<strong>proto</strong>[k]"，K[1] 为
"<code>&lt;script&gt;alert(1)&lt;/script&gt;&amp;page=xAllInventory&amp;make=chaparral</code>"。</li>
<li>对 K[0] 进行 URL 解码，得到变量 P，P 的值为
"<strong>proto</strong>[k]"。</li>
<li>将 P 按照中括号分割为数组 R，R 的值为 ["<strong>proto</strong>",
"k"]。</li>
<li>判断 R
中的第一个和最后一个元素是否以中括号开头和结尾，发现符合条件，去掉 R
中最后一个元素的结尾中括号，并将 R 中的第一个元素通过 shift()
方法移除，再次按照中括号分割，得到新的 R 数组，R 的值为
["<strong>proto</strong>", "k"]。</li>
<li>声明变量 J。</li>
<li>声明变量 O，将对象 H 赋值给 O。</li>
<li>声明变量 M，初始化为 0。</li>
<li>如果 K 数组的长度为 2，则将 K[1] 进行 URL 解码，得到变量 J，J 的值为
"<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>"。</li>
<li>如果 R 数组的长度大于 0，则循环处理 R
数组的元素，将当前元素赋值给变量 P，如果当前元素为 ""，则将 O
数组的长度赋值给
P。如果当前元素对应的值不存在，则创建一个空对象或空数组，并将其赋值给 O
数组中当前元素对应的属性。如果当前元素不是最后一个元素，则将 O
数组中当前元素对应的属性的值赋值给 O
变量，用于处理下一个元素。如果当前元素是最后一个元素，则将变量 J
的值赋值给 O 数组中当前元素对应的属性。</li>
</ol>
<p><strong>Step 2:</strong></p>
<ol type="1">
<li>创建一个变量 $unitSpecs，用 $("<code>&lt;ul/&gt;</code>") 创建一个
ul 元素，并添加一个 class 为 "unitSpecs"。</li>
<li>创建一个变量 data，该对象有一个键值对 { '123': 'abc' }。</li>
<li>循环处理 data 对象中的键值对，将键和值分别存储到变量 field 和
data[field] 中。</li>
<li>将 data["k"] 的值设置为
<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>。</li>
<li>将 "<code>&lt;li&gt;</code><span class="k">" + data["k"] +
"</span><code>&lt;/li&gt;</code>" 添加到 $unitSpecs 元素中。最终的
$unitSpecs 元素为：&lt;ul
<code>class="unitSpecs"&gt;&lt;li&gt;&lt;span class='k'&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;</code>。</li>
</ol></li>
<li><p><strong>作者的定义</strong>：对象污点和值污点</p></li>
<li><p><strong>汇函数</strong>（sink
function）是指在程序中，可以接收并处理来自外部输入的数据的函数。这些函数通常用于处理敏感数据，如用户输入、网络请求等。如果这些数据未经过适当的验证和过滤，就可能导致安全漏洞</p></li>
<li><p><strong>原型污染的三种攻击后果</strong>：</p></li>
</ul>
<ol type="1">
<li>XSS</li>
<li>Storage(Cookie)Manipulation.</li>
<li>URL Manipulation</li>
</ol>
<ul>
<li><code>PROBETHEPROTO</code> has two major parts:
<ol type="1">
<li>joint taint flow analysis,</li>
<li>result validation.</li>
</ol></li>
<li>在信息安全领域，<strong>源和汇</strong>（source和sink）是两个重要的概念。源是指可以产生潜在危害的安全威胁的输入数据，而汇是指在程序执行过程中可以被攻击者利用的漏洞点，攻击者可以将恶意数据输入到汇中来触发漏洞。通常情况下，源和汇之间存在一条或多条数据流路径，攻击者可以通过控制源的数据流来达到攻击汇的目的。</li>
<li>PROBETHEPROTO系统通过<strong>两种方式生成属性输入</strong>：sink-based和lookup-based</li>
</ul>
<h4 id="总结-20">总结：</h4>
<ul>
<li><p><strong>文献总结</strong></p>
<p>本文的研究背景是<strong>客户端原型污染漏洞</strong>。这是一种相对较新的JavaScript漏洞类型，可能导致跨站脚本攻击（XSS）和cookie篡改等安全问题。在过去的几年中，已经有一些研究关注这个问题，但大多数都是基于手动分析或小规模实验室测试。</p></li>
<li><p>本文的主要<strong>Contributions</strong></p>
<p>提出了<code>PROBETHEPROTO</code>系统，这是第一个针对客户端原型污染漏洞进行大规模测量研究的系统。该系统使用动态污点分析和漏洞利用生成来跟踪联合污点流并自动化整个过程来检测客户端原型污染漏洞。此外，该研究还提供了一个全球范围内的网站列表，并对这些网站进行了测试，以揭示客户端原型污染漏洞的普遍性和潜在后果。这些创新点为网站开发人员和安全专业人员提供了有用的建议和指导，以帮助他们更好地保护网站免受客户端原型污染漏洞的攻击。</p></li>
<li><p>阅读本文比较<strong>费时间</strong>：在看懂他方法的过程中，几乎没几个熟悉的概念。</p></li>
<li><p>本文与一个月前的<strong>Node.js原型污染</strong>论文是同一作者<strong>song
li</strong></p>
<p><strong>对比：</strong></p>
<ol type="1">
<li>node.js
针对的是<strong>服务端</strong>的原型污染；本文针对的是<strong>客户端</strong>的原型污染，并且研究了在原型污染漏洞影响下造成的其他漏洞Consequence（如XSS漏洞和CSRF漏洞）</li>
<li>这两篇文献的发表时间都是在2022年，前一篇被Usenix收录，这篇被NDSS收录</li>
<li>本文的创新点基于的<strong>背景</strong>很简单：就是没有前人客户端原型污染上进行大规模的实证研究,因此该研究开创了这一领域的先河；而node.js那篇是基于前人的漏洞检测模型检测漏洞单一、且误报率较高的背景下</li>
</ol></li>
</ul>
<h3 id="section-30">2023-04-21</h3>
<h4 id="paper-1">Paper</h4>
<ul>
<li><p><strong>Paper信息</strong></p>
<p><a
target="_blank" rel="noopener" href="https://www.ndss-symposium.org/ndss-paper/fuzzilli-fuzzing-for-javascript-jit-compiler-vulnerabilities/">FUZZILLI:
Fuzzing for JavaScript JIT Compiler
Vulnerabilities</a>(<strong>CCF-A</strong>会议：NDSS 2023)</p></li>
<li><p><strong>keywords</strong></p>
<p>JIT Compiler</p>
<p>Vulnerbility Dection</p>
<p>Fuzzing</p></li>
</ul>
<h4 id="正文-10">正文</h4>
<ul>
<li><p><strong>之前的研究存在的问题</strong>：<code>Previous work on discovering software faults in JavaScript engines found many vulnerabilities, often using fuzz testing. Unfortunately, these fuzzing approaches are not designed to generate source code that actually triggers JIT semantics.</code></p></li>
<li><p><strong>chrome浏览器沙箱逃逸</strong></p>
<p>浏览器沙箱是一种安全机制，通过将JavaScript代码限制在一定的安全边界内，来防止恶意代码对计算机系统的攻击和损害。但是，在某些情况下，攻击者可能会成功地逃脱浏览器沙箱，进而攻击计算机系统。</p>
<p>浏览器沙箱逃逸通常是通过利用浏览器中的漏洞实现的。攻击者会利用这些漏洞，使自己的代码可以在沙箱之外运行，进而获取更高的权限，并对系统进行攻击。例如，攻击者可能会利用浏览器中的内存漏洞，通过缓冲区溢出等技术，将恶意代码注入到系统中，并在特权模式下执行这些代码。</p>
<p>为了防止浏览器沙箱逃逸，可以采取以下措施：</p>
<ol type="1">
<li>及时更新浏览器和操作系统，修补已知的漏洞。</li>
<li>禁用不必要的浏览器插件和扩展程序，尽可能减少攻击面。</li>
<li>使用最小权限原则，限制JavaScript代码的权限，避免给恶意代码留下可乘之机。</li>
<li>使用沙箱技术，将不可信的代码隔离在一个安全的环境中。</li>
<li>部署安全策略，限制JavaScript代码的访问范围，避免数据泄露和其他安全问题。</li>
</ol></li>
<li><p><strong>WebKit</strong></p>
<p>WebKit 是一种用于呈现 Web
内容的开源引擎，主要用于浏览器和移动设备中的应用程序。WebKit
最初是苹果公司为其 Safari
浏览器开发的，现在已被许多其他浏览器和应用程序采用。WebKit
引擎的优势之一是它能够在多个操作系统和平台上运行，包括
macOS、Windows、Linux 和 iOS 等。</p>
<p>WebKit 引擎包含许多模块，例如解析 HTML 和 CSS、渲染布局、管理
JavaScript 执行和处理网络请求等。由于其广泛的应用，WebKit
引擎经常成为攻击者利用的目标之一。常见的攻击方式包括使用恶意网站或文件触发
WebKit 引擎中的漏洞来执行恶意代码或者绕过沙箱保护等。因此，WebKit
引擎的安全性备受关注，并且经常会发布更新来修复已知的漏洞。</p></li>
<li><p><strong>以前的模糊测试</strong>方法针对的是 JavaScript
引擎，而不关注特定组件或仅关注运行时
API。这种方法可以发现范围广泛的漏洞，但很少发现需要同时存在多个先决条件的更复杂的漏洞。特别是JIT编译漏洞，恰恰就是这样一类漏洞</p></li>
<li><p><strong>JIT 编译器优化的条件</strong>。JIT (Just-In-Time)
编译器是一种在运行时将高级语言编译为本地机器代码的技术，这种技术可以提高程序的执行速度。</p>
<p>这段话中提到，为了 JIT 优化能够发生，需要满足一些特殊的条件。首先，JS
引擎必须频繁地执行特定的代码，其次，这段代码的行为必须在执行过程中保持一致和可预测，只有这样，JIT
编译器才会开始对这段代码进行优化。此外，为了让 JS
引擎发现错误，这段代码必须被执行多次，并以不可预测的方式改变其行为。</p>
<p>因此，如果要利用 JIT
编译器漏洞，攻击者需要构造特殊的代码，并确保它能够被频繁执行，同时在一定条件下改变其行为，从而让
JS 引擎产生错误并执行恶意代码。</p></li>
<li><p>本文的一个<strong>特点</strong>：针对特定组件的模糊测试器</p></li>
<li><p>关注<strong>模糊测试</strong>和<strong>灰盒模糊测试</strong></p>
<p>模糊测试是个热点问题，能检索到太多fuzzing的CCF评级文章</p></li>
<li><p><strong>模糊测试分类</strong></p>
<p><strong>生成式模糊测试</strong>（Generative
Fuzzing）是一种自动化软件测试技术，它通过创建模型和生成测试用例来发现软件程序中的漏洞。与传统的模糊测试不同，生成式模糊测试使用输入模型生成测试用例，而不是基于手动构造的输入。它通过学习输入空间的结构和语法来创建输入模型，并从该模型中生成随机输入数据。生成式模糊测试通常使用机器学习算法来生成输入模型，例如生成式对抗网络（GAN）或变分自动编码器（VAE）。这种技术在发现复杂程序的漏洞方面具有很高的效率和准确性</p>
<p><strong>基于突变的模糊测试</strong></p>
<p><strong>引导式模糊测试</strong></p>
<p><strong>结构感知模糊测试</strong></p>
<p>以上类别都不好理解</p></li>
<li><p>本文多次提到<code>中间表示</code>这个术语，这应该是本文的一个创新之处</p>
<p>在之前看的多篇文献中几乎不出意外都是使用了<code>AST</code>这一中间表示</p>
<p>而本文创造了一个<strong>新的中间表示</strong></p></li>
<li><p><strong>猜测优化</strong>
"猜测优化"指的是在运行时推断代码的使用模式，从而对代码进行优化的一种技术。在
JavaScript
引擎中，如果一个操作符只被用于一种特定的类型，那么引擎会猜测该操作符只会接收该特定类型的值，并进行优化编译。这种优化编译通常被称为
"内联缓存"，它可以大幅提高代码的执行速度。当然，如果猜测错误，就会产生性能上的损失，因为需要回到解释执行的方式。因此，在猜测优化中，通常会使用一些保护机制，如类型监视器等，来确保猜测是正确的。</p>
<p>因为是对JS编译器的漏洞检测，因此本文多次提到对<strong>JS代码的优化原理</strong></p></li>
<li><p><strong>CVE-2018-4233</strong></p>
<p>在 JIT 编译器生成的代码中，为了确保运行时的类型假设都成立，会使用
guards（守卫）来进行检查。但在某些代码中，guards
可能会变得多余。为了进一步优化代码，JIT 编译器可以删除冗余的
guards。为了确保 guards 确实是多余的，JIT 编译器会分析 guards
之间的代码，以确定是否存在潜在的副作用。但这个分析可能是有误的，因为在某些情况下，看似没有副作用的函数调用可能会触发用户定义的
JavaScript 回调函数，进而改变变量的类型。这就是 CVE-2018-4233
中的漏洞利用方式</p>
<p><strong>原理</strong>：可以举一个简单的<strong>例子</strong>来说明这个漏洞的原理。</p>
<p>假设有一个 JavaScript 程序，其中有一个函数 <code>sum</code>
用于计算两个数的和，如下所示：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这个函数很简单，但在 JIT
编译时，由于使用频率较高，可能会被进行优化。在优化时，JIT
编译器可能会根据使用情况猜测输入参数的类型，并针对这些类型进行优化。比如，如果
JIT 编译器猜测输入参数 <code>a</code> 和 <code>b</code>
都是整数类型，那么它就会生成针对整数类型的优化代码。</p>
<p>然而，如果在调用 <code>sum</code>
函数时，传入的是字符串类型的参数，由于 JIT
编译器没有对这种类型进行优化，就会导致代码出现错误。</p>
<p>这种漏洞的危害在于它可能会被恶意利用。攻击者可以构造恶意的输入，来触发
JIT
编译器的类型猜测和优化过程，并利用优化后的代码来执行任意的恶意代码。因此，这种漏洞被称为
JIT-spray 攻击。</p></li>
<li><p><strong>JavaScript引擎</strong>是一种软件程序，用于解释和执行JavaScript代码。而<strong>JIT（Just-In-Time）编译器</strong>则是一种优化技术，可以在程序运行时将解释执行的代码转换为本地机器代码，以提高代码的执行速度。</p>
<p>在JavaScript引擎中，通常包含解析器、抽象语法树（AST）、字节码生成器、字节码解释器以及<strong>JIT编译器等组件</strong>。当解释器解析JavaScript代码时，会将代码转换为AST并生成字节码。如果发现某些代码块被频繁执行，就会启动JIT编译器，将其转换为本地机器代码以提高执行速度。</p>
<p>JIT编译器可以根据代码使用模式推断出类型等信息，然后对代码进行“猜测优化”，生成更高效的本地机器代码。同时，为了保证程序的正确性，JIT编译器还会插入类型检查和边界检查等代码。</p>
<p>总之，JIT编译器是JavaScript引擎中重要的组成部分，可以大大提高JavaScript代码的执行速度。</p></li>
<li><p>保证<strong>代码语义的正确性</strong>是让JIT产生优化的必要条件，作者通过对比验证了这一点</p></li>
<li><p><strong>语义代码变异</strong></p>
<p>语义代码变异技术（Semantic Code
Mutations）是一种基于程序的语义信息进行变异的技术。与传统的基于语法的变异技术不同，语义代码变异技术关注程序的语义信息，如控制流和数据流等。在这种技术中，变异器会通过分析程序的语义结构，针对性地进行代码变异，从而生成具有不同语义行为的程序。</p>
<p>语义代码变异技术通常用于<strong>指导模糊测试</strong>，提高测试的效率和准确性。在进行变异之前，语义分析器会对程序进行静态分析，确定代码的语义结构和变异点，以便更好地进行变异。在执行变异后，语义分析器会对变异后的程序进行检查，确保变异后程序的语义正确性。</p>
<p>语义代码变异技术是一种高级的代码变异技术，需要深入理解程序的语义结构和执行过程。这种技术在实际应用中可以提高程序的可靠性和安全性，是程序分析和测试领域的重要研究方向之一。</p></li>
<li><p><code>Consequently,solely semantic mutations are more challenging to implement as immediate mutations could result merely in syntacticchanges to the program and not semantic ones.</code></p></li>
<li><p>在AST层面的突变，很多是无意义的，为了解决这一问题，作者提出在AST基础上再加一层中间表示（IR）,在<strong>IR层面进行突变</strong>以改善这种情况。</p></li>
<li><p><strong>SSA</strong>（Static Single
Assignment）是一种中间代码表示形式，其中每个变量只能被赋值一次。在SSA中，每次对变量的赋值都会创建一个新的版本（也称为“phi节点”），从而确保每个变量只有一个定义点。这种形式使得编译器更容易进行各种优化，因为可以准确地知道变量在程序中的位置，并且可以避免复杂的别名分析。</p>
<p>SSA形式还可以方便地进行控制流分析，因为它使用显式的控制流分割点（也称为“基本块”），这些分割点定义了程序的基本结构，并帮助编译器进行更准确的分析和转换。在SSA中，每个基本块都只能从一个前驱块到达，这简化了许多优化算法，例如值编号、死代码删除和传播优化等。</p>
<p>许多编译器和静态分析工具都使用SSA作为其中间表示形式，因为它具有良好的性质和可扩展性。</p></li>
<li><p>通过不同的突变方式实现四个突变目标</p></li>
<li><p>三个<strong>改善语义正确性的措施</strong></p>
<ul>
<li>Allowing only a valid corpus</li>
<li>Only performing small changes</li>
<li>A lightweight type system</li>
</ul></li>
<li><p>JIT Compiler中的静态类型推理</p></li>
<li><p>当前被认为是<strong>最先进的三个 JavaScript 引擎</strong>是：</p>
<ol type="1">
<li><strong>V8</strong>：由 Google 开发，用于 Chrome 浏览器和 Node.js
等应用程序。它使用了 JIT（即时编译）技术，可以在运行时将 JavaScript
代码编译成本地机器代码，以提高性能。</li>
<li><strong>SpiderMonkey</strong>：由 Mozilla 开发，是 Firefox
浏览器的默认 JavaScript 引擎。它也使用了 JIT 技术，并且在性能上与 V8
不相上下。</li>
<li><strong>JavaScriptCore</strong>：由苹果公司开发，是 Safari
浏览器的默认 JavaScript 引擎。它采用了一种名为“中间表示”的技术，可以将
JavaScript 代码编译成字节码，然后在运行时进行解释执行。</li>
</ol></li>
<li><p>在进行代码模糊测试时<strong>启用断言</strong>可以帮助发现潜在的漏洞。断言是在代码中插入的用于判断某些<strong>前置条件或后置条件</strong>的检查语句，如果条件不满足则断言会触发并中止程序的执行。在这里，作者指出开启断言可以帮助发现一些不容易被直接发现的安全缺陷。例如，<strong>CVE-2019-8622</strong>这个安全漏洞就是因为断言失败而被发现的。在
JIT
编译器中，存在<strong>一种假设</strong>，即某个操作不会导致垃圾回收，但实际上这个操作确实会触发一些可能引起垃圾回收的
API，而这就为攻击者制造了可乘之机。通过在代码中加入断言可以帮助及早发现此类漏洞。</p></li>
<li><p>作者给出的<strong>建议</strong>：未来的fuzzing研究必须提供任何初始语料库以便进行复制，并且应该更加重视使用不同的、可能是新的语料库来重现以前的fuzzing结果，以估计fuzzer在不同语料库上的泛化能力。</p></li>
<li><ol type="1">
<li></li>
</ol></li>
</ul>
<h3 id="section-31">2023-04-14</h3>
<h4 id="paper1">Paper1</h4>
<ul>
<li><p><strong>paper信息：</strong></p>
<p><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3488932.3497769">On Measuring
Vulnerable JavaScript Functions in the
Wild</a>(<strong>CCF-C:</strong>17th AsiaCCS 2022: Nagasaki, Japan)</p>
<blockquote>
<p>Published:30 May 2022</p>
</blockquote></li>
<li><p><strong>keywords</strong>:</p>
<p>JavaScript security;</p>
<p>vulnerability detection;</p>
<p>vulnerable functions</p></li>
<li><p><strong>正文</strong></p>
<ul>
<li><p><code>As evident from the results,our approach can shift JavaScript vulnerability detection from the coarse package/library level to function level</code>
如何理解包级别和函数级别的关系</p></li>
<li><p><strong>文本相似性方法</strong>和<strong>语义相似性方法</strong>是自然语言处理领域中两个不同的概念。</p>
<p>文本相似性方法（Textual similarity
methods）是指通过比较文本之间的语法、词汇和结构等方面的相似性来度量它们之间的相似性。文本相似性方法通常采用基于词袋模型、TF-IDF、余弦相似度等技术进行计算，常用于文本分类、信息检索和问答系统等领域。</p>
<p>而语义相似性方法（Semantic similarity
methods）则更加注重比较文本之间的意义和语义方面的相似性。语义相似性方法可以采用词嵌入技术（如Word2Vec、GloVe等）来捕捉词汇的语义信息，或者使用深度学习模型（如Siamese网络、BERT等）来学习文本之间的语义表示，从而计算它们之间的相似度。语义相似性方法可以应用于文本匹配、句子相似性计算、知识图谱等领域。</p>
<p>总的来说，文本相似性方法侧重于<strong>文本的形式和结构</strong>方面的相似性，而语义相似性方法更注重<strong>文本的语义和含义</strong>方面的相似性</p></li>
<li><p><strong>元信息</strong></p></li>
<li><p>文本相似性检测方法:内容敏感模糊散列和加密散列</p>
<p><strong>内容敏感模糊散列</strong>（Content-sensitive fuzzy
hashing，CSFH）和加密散列是文本相似性检测中常用的两种方法。</p>
<p><strong>内容敏感模糊散列</strong>是通过对文本进行模糊化处理，提取文本的特征信息，然后计算散列值来判断文本相似性。在处理过程中，可以将一些特定的信息（如时间戳、IP地址等）进行屏蔽，以提高散列算法的鲁棒性和抗干扰能力。</p>
<p>加密散列是将文本通过一个不可逆的加密算法进行加密，得到一段固定长度的散列值，常用的加密算法包括MD5、SHA等。对于两个文本，如果它们的散列值相同，则可以认为它们内容相同或者非常相似。</p>
<p>这两种方法在文本相似性检测中都有广泛的应用，但是内容敏感模糊散列相对于加密散列而言，在抗抄袭能力和相似性检测的精度方面具有一定的优</p></li>
<li><p><strong>Regular Expression Denial of Service</strong></p>
<p>正则表达式拒绝服务攻击（Regular Expression Denial of
Service，简称ReDoS）是一种针对使用正则表达式的应用程序的攻击。攻击者通过构造恶意的输入数据，使得正则表达式匹配过程变得异常耗时，导致服务器资源被耗尽，从而导致服务不可用。</p>
<p>ReDoS攻击的实现方式通常是利用正则表达式中的回溯机制，通过构造特定的字符串使得正则表达式需要反复回溯匹配，从而占用大量CPU时间和内存资源。这种攻击方式不需要大量的网络流量或计算资源，只需要发送一个恶意字符串即可引发攻击。</p>
<p>为了防止ReDoS攻击，可以采取以下措施：</p>
<ul>
<li>使用正则表达式引擎的超时机制，限制匹配时间。</li>
<li>限制正则表达式的复杂度，例如限制正则表达式中的重复次数或递归深度。</li>
<li>对输入数据进行合理的验证和过滤，避免输入中包含可导致ReDoS攻击的字符或模式。</li>
<li>使用更加高效的正则表达式引擎，避免使用容易被攻击的引擎。</li>
</ul></li>
<li><p><strong>两个漏洞数据库</strong>：</p>
<p>Snyk vulnerability database</p>
<p>Google VulnCode-DB project</p></li>
</ul>
<p>----<strong>补充</strong>----</p>
<ul>
<li><p><strong>文本标记化</strong>（Tokenization）是一种将文本转换为标记序列（token
sequence）的自然语言处理（NLP）技术。在文本标记化过程中，将文本分割成词（word）、词组、符号或其他有意义的元素，这些元素被称为标记。标记化通常是文本处理的第一步，是构建自然语言处理系统的基础。</p>
<p>标记化的主要目的是将文本转换为可供计算机处理的数据结构，例如词袋（bag
of
words）或向量。在自然语言处理任务中，标记化是非常关键的，因为文本中的单词顺序和单词之间的关系对于最终结果的影响非常重要。</p></li>
<li><p><code>ML/DL algorithms have to rely on a large dataset of vulnerable and patched functions with clear ground truth which, to the extent of our knowledge, does not exist for JavaScript.</code></p></li>
<li><p>漏洞检测有不同的<strong>粒度级别</strong>：行级、函数级、文件级和包级</p>
<p>是的，漏洞检测可以在不同的粒度级别进行，如下所示：</p>
<ol type="1">
<li>行级：在代码的每一行进行检测，以寻找可能存在的漏洞。</li>
<li>函数级：对每个函数进行检测，以查找可能存在的漏洞。</li>
<li>文件级：对每个文件进行检测，以查找可能存在的漏洞。</li>
<li>包级：对每个软件包或库进行检测，以查找可能存在的漏洞。</li>
</ol>
<p>选择何种粒度级别取决于具体的应用场景和目标，不同的级别有其优缺点。例如，行级检测可以找到最细粒度的漏洞，但可能会产生较高的误报率；文件级检测可以提供更全面的检测结果，但可能会忽略一些局部漏洞；包级检测可以快速检测大量代码，但可能会产生较多的漏洞遗漏。因此，在实际应用中需要根据具体情况进行选择和权衡。</p></li>
</ul></li>
</ul>
<h4 id="总结-21">总结</h4>
<ul>
<li><p><strong>一图总结全文</strong><img
src="https://s2.loli.net/2023/04/15/5C4tyFpMDhT1PqO.png"
alt="image-20230415015912950" /></p>
<p>非常显而易见的是：作者在对<strong>数据的处理</strong>下了很大功夫</p>
<p><strong>具体来说，</strong>基于两个原始的漏洞数据库和github上的链接，使用半自动化函数验证方法和静态分析工具Semgrep使用半自动化过滤步骤来区分真正易受攻击的函数，提取出了更为有有效的数据。</p>
<p>该框架主要用于检测<strong>两种类型的漏洞</strong>：原型污染（在两周前的paper中已经提到）和正则表达式拒绝服务（ReDoS）</p>
<p>检测漏洞的方法：文本相似性方法和语义相似性方法</p>
<p><strong>贡献</strong>和<strong>创新之处</strong>：本文的创新之处在于，它提出了一种结合文本相似性和模式匹配的方法来检测JavaScript函数中的易受攻击漏洞。该方法使用静态分析工具Semgrep来执行高级语义搜索，以理解变量和结构，并在代码中检测模式。此外，作者还开发了一个Web应用程序，使手动验证更快、更容易。他们将收集的数据上传到Web界面，这使得他们可以轻松地在条目、文件和函数之间导航。最后，作者还对一些易受攻击函数进行了案例研究，以了解这些漏洞如何影响包含它们的项目，以及它们对用户构成什么威胁。</p>
<p><strong>本文跟两周前的paper</strong>有一定相似之处，都没引入任何的神经网络模型。</p>
<ol type="1">
<li>两者检测的漏洞有一些不同</li>
<li>本文对数据的收集和处理上花了更多功夫</li>
</ol></li>
<li><p>总的来说：给我的感觉恰恰是没有引入任何神经网络模型的paper更加难以阅读。</p></li>
</ul>
<h3 id="section-32">2023-04-07</h3>
<h4 id="paper1-1">Paper1</h4>
<p><a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0167404822004072?via%3Dihub">MFXSS:
An effective XSS vulnerability detection method in JavaScript based on
multi-feature model</a>(<strong>CCF-B</strong>:Computers &amp;
Security)</p>
<ul>
<li><p><strong>Paper信息：</strong></p>
<p>Article history:<br />
Received 15 September 2022<br />
Revised 1 November 2022<br />
Accepted 14 November 2022<br />
Available online 20 November 2022</p></li>
<li><p><strong>keywords:</strong></p>
<p>Cross-site scripting<br />
Multi-feature fusion<br />
Graph convolutional network<br />
Weighted aggregation<br />
Vulnerability detection</p></li>
<li><p><strong>前置知识</strong></p>
<ul>
<li><p><strong>加权聚合：</strong></p>
<p>加权聚合是一种多指标决策方法，用于将多个指标或评估准则的结果进行汇总和综合评估。该方法将各个指标或评估准则进行加权，将它们的结果按照其权重进行加总，并将得到的总分作为最终评估结果。</p>
<p>在加权聚合中，每个指标或评估准则都有一个权重，这个权重表示了其在最终评估结果中的相对重要性。这些权重通常是根据专家判断或基于历史数据进行确定的。</p>
<p>加权聚合的优点是可以将多个指标或评估准则进行统一的量化，从而更加客观地进行综合评估。缺点是需要对各个指标或评估准则的权重进行准确的确定，否则可能会导致最终评估结果的不准确性</p></li>
<li><p><strong>平均聚合和求和聚合</strong>:</p>
<p>在机器学习中，聚合是将多个模型预测结果合并为单个结果的过程。平均聚合和求和聚合是常见的两种聚合方法。</p>
<p>平均聚合（Mean
Aggregation）是将所有模型的预测结果取平均值的过程。在这种方法中，每个模型的权重都是相等的。例如，如果有5个模型，每个模型的预测结果分别是[0.8,
0.9, 0.7, 0.6, 0.85]，则这些结果的平均值为0.78。</p>
<p>求和聚合（Sum
Aggregation）是将所有模型的预测结果相加的过程。在这种方法中，每个模型的权重也是相等的。例如，如果有5个模型，每个模型的预测结果分别是[0.8,
0.9, 0.7, 0.6, 0.85]，则这些结果的总和为3.85。</p>
<p>需要注意的是，平均聚合和求和聚合都假设每个模型的预测结果具有相同的重要性。在实际情况中，这种假设可能不成立。因此，一些高级聚合方法使用权重来调整每个模型的预测结果的重要性。</p></li>
<li><p><strong>领域自适应</strong></p>
<p>领域自适应（Domain Adaptation）是指将在源领域（Source
Domain）上学习到的知识应用到目标领域（Target
Domain）中的过程。在机器学习领域中，源领域和目标领域通常具有相同的输入特征空间，但是有不同的输出空间。领域自适应的目的是利用源领域的知识来提高目标领域的学习性能。</p>
<p>在实际应用中，由于源领域和目标领域之间的差异，导致在目标领域上使用源领域的模型会导致性能下降。例如，在计算机视觉领域中，源领域可能是一个特定类型的图像数据集，例如人脸图像，而目标领域可能是其他类型的图像数据集，例如动物图像。由于人脸和动物图像之间的视觉特征存在较大差异，因此在人脸数据集上训练的模型在动物图像数据集上的性能可能会下降。</p>
<p>为了解决这个问题，领域自适应方法被提出来了。其基本思路是在源领域和目标领域之间建立联系，通过对源领域的数据进行适当的变换，使得源领域和目标领域的差异最小化，从而提高在目标领域上的性能。常用的领域自适应方法包括最大均值差异（Maximum
Mean Discrepancy，MMD）、核对齐（Kernel Alignment，KA）等</p></li>
</ul></li>
<li><p><strong>Paper正文</strong></p>
<ul>
<li><p>multi-type features</p></li>
<li><p><strong>Bi-LSTM</strong></p>
<p>Bi-LSTM是一种双向长短期记忆神经网络（Bidirectional Long Short-Term
Memory Network）的缩写。它是在LSTM的基础上发展而来的。</p>
<p>LSTM是一种适用于序列数据的神经网络，可以处理长期依赖性问题。但是LSTM只能单向地处理序列，即只能利用历史信息。而Bi-LSTM能够同时利用历史信息和未来信息，因此在处理序列数据时更为有效。Bi-LSTM通过在序列数据的前后分别运行两个LSTM网络，然后将它们的输出合并起来，实现了双向处理。</p>
<p>Bi-LSTM的应用非常广泛，特别是在自然语言处理（NLP）领域中。例如，Bi-LSTM可以用于语音识别、文本分类、命名实体识别、情感分析等任务。</p></li>
<li><p><strong>Dropout</strong>是一种常见的正则化技术，常用于深度学习中，旨在减少过拟合</p></li>
<li><p><strong>多层感知机(MLP)模型</strong></p>
<p>多层感知机（Multi-Layer
Perceptron，MLP）是一种常见的前馈神经网络模型。它由输入层、若干个隐层和输出层组成，每个层之间都有全连接的权重。在训练过程中，输入信号从输入层开始依次传递到隐层和输出层，最终得到模型的预测结果。</p>
<p>MLP模型可以通过反向传播算法进行训练，该算法通过计算模型输出值和真实标签之间的误差，然后逆向传播误差，并根据误差调整权重，从而最小化误差。</p>
<p>MLP模型广泛应用于各种机器学习任务，如分类、回归、聚类等。在实践中，可以通过调整隐层的数量和大小，以及不同的激活函数和优化算法来改善模型性能</p></li>
<li><p><strong>激活函数</strong></p>
<p>激活函数（activation
function）是一种数学函数，通常用于神经网络中的每个神经元，用于将输入信号的加权和转换为输出信号。激活函数的作用是为神经网络引入非线性性，从而使得神经网络可以学习更加复杂的关系。</p>
<p>常见的激活函数包括：</p>
<ol type="1">
<li>sigmoid函数：将输入值压缩到0和1之间，可以用于二分类问题。</li>
<li>ReLU函数：将负数部分置为0，保留正数部分，能够快速计算和解决梯度消失问题。</li>
<li>tanh函数：类似于sigmoid函数，但输出值在-1和1之间，常用于多分类问题。</li>
<li>softmax函数：用于多分类问题，将输出转换为概率分布。</li>
</ol>
<p>选择激活函数的主要考虑因素是其是否具有非线性性质、是否易于计算和是否可以避免梯度消失等问题。不同的神经网络层可能需要不同的激活函数。</p></li>
<li><p>这里给出了<strong>评估分类模型性能的三个重要指标</strong>，以及一个综合这些指标的
F1 score。</p>
<ul>
<li>Accuracy：模型分类正确的样本数占总样本数的比例。</li>
<li>Recall（召回率）：真实正例中被模型正确分类的比例，衡量模型找到正例的能力。</li>
<li>Precision（精度）：模型分类为正例的样本中，真实正例的比例，衡量模型分类为正例的准确性。</li>
<li>F1 score：综合考虑 Precision 和 Recall，是 Precision 和 Recall
的调和平均数，可用于评估分类不平衡问题中的模型性能。</li>
</ul></li>
<li><p><strong>十倍交叉验证</strong></p>
<p>十倍交叉验证是一种常用的机器学习模型评估方法，也叫做十折交叉验证。它将数据集划分为10个部分，每次将其中9个部分作为训练集，剩下的一个部分作为验证集，共进行10次训练和验证。最终，将这10次训练和验证的结果进行平均，得到模型的评估结果。</p>
<p>这种方法的优点是能够更好地评估模型的泛化能力，即模型在未见过的数据上的表现。缺点是需要进行多次训练和验证，计算时间相对较长</p></li>
<li><p><strong>多特征融合</strong></p>
<p>多特征融合指的是将多种不同类型的特征进行整合，用于提高机器学习模型的性能和准确度。在实际应用中，一个问题通常需要从多个方面考虑，因此需要用多种不同类型的特征来描述该问题。比如，在计算机视觉领域中，可以使用图像特征、语义特征和位置特征来描述一个物体；在自然语言处理领域中，可以使用词频、词向量和词性等多种不同类型的特征来描述一段文本。</p>
<p>多特征融合的目的是将这些不同类型的特征融合在一起，以获取更全面的信息，提高模型的性能和准确度。具体来说，多特征融合可以采用以下几种方法：</p>
<ol type="1">
<li>特征拼接：将不同类型的特征按照一定的顺序拼接在一起，形成一个更大的特征向量。</li>
<li>特征加权：给不同类型的特征赋予不同的权重，使得模型更关注某些特定类型的特征。</li>
<li>特征交叉：将不同类型的特征进行交叉组合，产生新的特征，从而扩展特征空间。</li>
<li>特征选择：选择最具代表性的特征，将其用于模型训练和测试，减少噪声和冗余信息。</li>
</ol>
<p>多特征融合可以有效地提高模型的性能和准确度，但也需要注意特征之间的相关性和影响，避免引入噪声和过度拟合的情况。同时，不同的特征融合方法适用于不同的问题和数据集，需要根据具体情况进行选择和调整。</p></li>
<li><p><strong>自注意力机制</strong>（Self-Attention
Mechanism）是一种可以通过对输入序列中各元素进行不同权重的加权，来计算其输出表示的方法。它最早是在2017年提出的，被应用于神经机器翻译中，但其后被证明在众多自然语言处理和计算机视觉任务中都有很好的表现。</p>
<p>自注意力机制主要包含以下几个步骤：</p>
<ol type="1">
<li>将输入序列中的每个元素进行线性变换，得到其对应的查询（Query）、键（Key）和值（Value）向量。</li>
<li>计算每个查询向量与所有键向量的相似度，使用softmax函数将相似度转化为权重系数，得到与该查询向量对应的值向量。</li>
<li>将所有值向量加权求和，得到该查询向量对应的输出表示。</li>
</ol>
<p>自注意力机制的优点是能够动态地计算不同输入元素之间的关系，并且不会受到固定窗口大小的限制，能够处理变长序列。在自然语言处理中，自注意力机制可以被用来构建强大的语言模型，如Transformer，BERT等。</p></li>
<li><p><strong>NLTK</strong></p>
<p>NLTK是一个开源的自然语言处理（NLP）库，全称为Natural Language
Toolkit。它是用Python编写的，并且包含了各种用于处理自然语言的工具、资源和数据集。NLTK可以用于文本分类、标记化、分块、分析、语义推理、语料库管理等任务。NLTK提供了大量的教程和实践，使得学习和使用NLP变得更加容易和有趣。</p></li>
<li><p><strong>Word2Vec</strong></p>
<p>Word2Vec
是一种将单词转换为向量表示的算法，它将单词映射到高维空间中的向量，使得具有相似含义的单词在空间中靠近彼此。该算法基于分布式假设，即单词的含义可以通过它们周围的单词来确定。Word2Vec
算法主要有两种模型：连续词袋模型（Continuous Bag of Words,
CBOW）和跳跃式模型（Skip-gram）。CBOW
模型基于上下文单词的平均值来预测当前单词，而 Skip-gram
则是基于当前单词来预测上下文单词。</p>
<p>Word2Vec
的主要优点是可以将高维稀疏的离散单词转换为低维稠密的连续向量，从而提高了计算效率，并使得语义相似的单词在向量空间中具有相似的几何结构。Word2Vec
可以应用于多种自然语言处理任务，例如情感分析、词性标注、命名实体识别等</p></li>
<li><p><strong>Readout</strong></p>
<p>在机器学习中，readout是指从神经网络的隐藏状态中提取输出的过程。在图神经网络中，readout通常是一个将所有节点或边的隐藏状态聚合成一个图级别表示的函数。例如，可以使用加和或平均值来获得整个图的表示。readout是图神经网络中的一个重要组件，它通常用于将节点和边的表示组合成整个图的表示，以便进行图级别的分类或回归任务。</p></li>
</ul></li>
</ul>
<h4 id="总结-22">总结</h4>
<ul>
<li><p>本文与上周阅读paper有较多联系：同样研究的是JavaScript代码的漏洞</p>
<p><strong>区别在于：</strong></p>
<p>上周paper讨论的是在JS在后端的漏洞(原型链中的内部属性篡改、原型污染和命令注入漏洞)，本文讨论的是前端产生的漏洞（如XSS）</p>
<p>XSS漏洞也正是是我当前研究的漏洞之一</p>
<ul>
<li><p><strong>研究前存在的问题</strong>：</p>
<ol type="1">
<li>特征提取不全面：现有的XSS漏洞检测方法通常只考虑了代码中的部分特征，如字符串、变量等，而忽略了控制流和数据依赖关系等重要特征。</li>
<li>特征维度不够：现有的XSS漏洞检测方法提取的特征维度较低，无法充分捕获JavaScript代码中复杂的语义信息。</li>
<li>缺乏上下文信息：现有的XSS漏洞检测方法通常只考虑单个代码片段中的特征，而忽略了与其相关联的上下文信息。</li>
</ol></li>
<li><p>一图总结本文<strong>贡献</strong><img
src="https://s2.loli.net/2023/04/07/tbBzdP34cRrGHE9.png"
alt="image-20230407204812757" /></p>
<p>总的来说：作者围绕<strong>多特征融合</strong>这个方法，将图结构的特征和代码字符串特征（针对敏感的属性和方法）融合在一起，使用<strong>多层感知模型</strong>对代码中是否存在XSS漏洞做出预测和分类。</p>
<p>其中使用优化加权聚合方法和递归神经网络来<strong>提取图形结构特征</strong>，使用Bi-LSTM模型来提取<strong>代码字符串特征</strong>，使用<strong>自注意力机制</strong>加强两种特征的交互，提升XSS漏洞检测性能</p></li>
<li><p>本文所做的研究工作，引入了神经网络以及NLP技术，正是我之前计划研究的一部分内容，非常贴近我的研究工作。</p></li>
</ul></li>
</ul>
<h3 id="section-33">2023-03-31</h3>
<h4 id="程序设计">程序设计</h4>
<ul>
<li>AST: 例如程序
<code>const team = '大转转FE'</code>的AST如下：是一个JSON对象</li>
</ul>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>
    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Program"</span><span class="token punctuation">,</span>
    <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
    <span class="token property">"body"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">&#123;</span>
        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"VariableDeclaration"</span><span class="token punctuation">,</span>
        <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
        <span class="token property">"declarations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
          <span class="token punctuation">&#123;</span>
            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"VariableDeclarator"</span><span class="token punctuation">,</span>
            <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>
            <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
            <span class="token property">"id"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
              <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Identifier"</span><span class="token punctuation">,</span>
              <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>
              <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">,</span>
              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"team"</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
            <span class="token property">"init"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
              <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Literal"</span><span class="token punctuation">,</span>
              <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
              <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
              <span class="token property">"value"</span><span class="token operator">:</span> <span class="token string">"大转转FE"</span><span class="token punctuation">,</span>
              <span class="token property">"raw"</span><span class="token operator">:</span> <span class="token string">"'大转转FE'"</span>
            <span class="token punctuation">&#125;</span>
          <span class="token punctuation">&#125;</span>
        <span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"const"</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token property">"sourceType"</span><span class="token operator">:</span> <span class="token string">"module"</span>
  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p><strong>Node.js</strong></p>
<p>是一个基于Chrome V8
JavaScript引擎构建的JavaScript运行时环境。它可以在服务器端运行JavaScript代码，使得JavaScript不仅可以用于前端开发，还可以用于后端开发。Node.js采用事件驱动、非阻塞I/O模型，使得它能够处理高并发、高吞吐量的应用程序。</p>
<p>Node.js有以下特点：</p>
<ol type="1">
<li><strong>轻量级</strong>：Node.js的核心只包含几个模块，可以根据需要安装其他模块，使得Node.js非常轻量级，启动和运行速度很快。</li>
<li><strong>高效性</strong>：Node.js采用事件驱动、非阻塞I/O模型，使得它可以高效地处理大量并发请求。此外，Node.js还支持异步编程，可以更好地利用系统资源。</li>
<li>跨平台性：Node.js可以运行在多种操作系统上，如Windows、Linux、MacOS等。</li>
<li><strong>社区活跃</strong>：Node.js拥有一个庞大的开发者社区，可以方便地获取各种模块、框架和工具，可以快速开发高质量的应用程序。</li>
</ol>
<p>Node.js可以用于构建各种类型的应用程序，如Web应用程序、命令行工具、网络服务、物联网应用程序等。它可以使用JavaScript进行全栈开发，使得开发人员可以使用同一种语言进行前后端开发，提高了开发效率和代码可维护性。</p></li>
<li><p>Node.js 相关漏洞</p>
<p><strong>命令注入</strong>（Command
Injection）是指攻击者利用应用程序没有对用户输入数据进行正确处理的漏洞，将恶意命令注入到应用程序中，从而达到控制系统、窃取敏感信息等目的的攻击行为。</p>
<p><strong>原型污染</strong>（Prototype
Pollution）是指攻击者能够修改JavaScript对象的原型（prototype）属性，从而影响到所有从该原型继承而来的对象。这种攻击方式可能导致应用程序中的数据被篡改、敏感信息泄露等安全问题。</p>
<p><strong>路径穿越</strong>（Path
Traversal）是指攻击者利用应用程序没有对用户输入数据进行正确处理的漏洞，访问应用程序之外的文件或目录。这种攻击方式可能导致攻击者能够读取、修改、删除或上传应用程序之外的文件，从而达到窃取敏感信息或者破坏系统的目的。</p>
<p><strong>内部属性篡改</strong>（Internal Property
Tampering）是指攻击者利用JavaScript的一些高级特性，如Object.defineProperty()方法等，对对象的内部属性进行篡改，从而导致应用程序出现安全漏洞。这种攻击方式可能导致应用程序中的数据被篡改、敏感信息泄露等安全问题。</p></li>
<li><p><strong>原型对象</strong></p></li>
</ul>
<p>每个函数都有一个名为“prototype”的属性，它指向一个对象。这个对象被称为函数的原型对象（prototype
object）。原型对象是一个普通对象，它具有自己的属性和方法。</p>
<h4 id="论文正文">论文正文</h4>
<h5 id="论文1-6">论文1</h5>
<ul>
<li><p><strong>文献信息</strong></p>
<p><a
target="_blank" rel="noopener" href="https://www.usenix.org/conference/usenixsecurity22/presentation/li-song">Mining
Node.js Vulnerabilities via Object Dependence Graph and
Query</a>(<strong>CCF-A</strong>:31st USENIX Security Symposium
2022)</p></li>
<li><p><strong>Node.js 常见漏洞：</strong></p>
<p>命令注入、原型污染、路径穿越和内部属性篡改</p></li>
<li><p><strong>for example</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token class-name">Func</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span>
myFunc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Func</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>source1<span class="token punctuation">)</span>
    myFunc<span class="token punctuation">[</span>source2<span class="token punctuation">]</span> <span class="token operator">=</span> myFunc<span class="token punctuation">.</span>x <span class="token operator">+</span> source1<span class="token punctuation">;</span> <span class="token comment">// internal property tampering</span>
<span class="token function">sink</span><span class="token punctuation">(</span>myFunc<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// taint -style vulnerability like command injection</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p><code>Func()</code>
这个函数有一个原型对象<code>Func.prototype</code>，<strong>myFunc</strong>
这个函数将会继承<code>Func</code>的原型对象，所以<strong>myFunc.x</strong>操纵的是<code>Func.prototype.x</code></p></li>
<li><p><strong>内部属性篡改</strong>：source2可由敌手控制</p>
<ol type="1">
<li>如设置为Func.prototype.x；</li>
<li>设置为<code>__proto__</code> 将会更改原型Func.prototype</li>
</ol></li>
<li><p><strong>污点式漏洞</strong></p>
<ol type="1">
<li>由内部属性篡改知，myFunc.x可被修改为敌手想要的任意值，执行特殊命令</li>
</ol></li>
<li><p><strong>Query</strong></p>
<p>是一个用于查找代码库中<strong>特定模式</strong>的语言，可以用于检查代码中的潜在漏洞、复杂的代码路径、不安全的代码模式等。它并不是专门用于检测
Node.js
程序中漏洞的查询语言，而是可以应用于不同编程语言和平台的代码库。在
Node.js 中，通常使用 ESLint 插件来运行 Query 查询。</p>
<blockquote>
<p><strong>特定模式：</strong>在程序分析中，特定模式是指一组代码结构、逻辑或者特定的数据流关系，用于表示程序中的某种行为或漏洞类型。通过定义这些模式，可以用于检测程序中是否存在该行为或漏洞类型，并提示开发人员进行相应的修复。例如，用于检测
SQL 注入漏洞的特定模式可能包括输入的数据被直接拼接到 SQL
语句中、缺乏输入数据的验证和转义等。特定模式可以作为一种规则库，用于静态分析工具或代码审查工具来扫描代码并发现潜在的安全漏洞</p>
<p><strong>数据流</strong>是指在程序执行过程中，数据的传递和变换的过程。数据流分析是一种静态分析方法，它用于在程序的执行过程中跟踪数据流的路径，以便确定程序中潜在的错误和漏洞。数据流分析可以帮助我们检测出程序中的一些常见问题，如空指针引用、未初始化变量、数组下标越界、内存泄漏等问题。</p>
</blockquote></li>
</ul></li>
<li><p><strong>Application-level Vulnerabilities</strong></p>
<ul>
<li>Adversary-controlled network request to a vulnerable server.<br />
</li>
<li>Adversary-controlled network response to a vulnerable client</li>
</ul></li>
<li><p><strong>Package-level Vulnerabilities</strong></p>
<ul>
<li>包漏洞会导致本身没有漏洞的应用程序出现漏洞</li>
</ul></li>
<li><p><strong>抽象解释</strong>（Abstract
Interpretation）是一种程序分析技术，旨在推导出程序的语义信息，例如变量的类型、取值范围、可能的程序路径等，从而检测程序中的错误和漏洞。抽象解释通过对程序状态的抽象和近似来实现对程序的静态分析，以便能够处理大型程序和更复杂的语言特性。</p>
<p>在抽象解释中，程序状态通常由抽象域（Abstract
Domain）中的元素表示。抽象域是程序状态空间的一个子集，其中每个元素都是原始状态的抽象。例如，可以使用整数区间作为抽象域来表示数值变量的取值范围，使用布尔代数作为抽象域来表示布尔变量的取值。抽象解释使用抽象函数来操作抽象域中的元素，这些函数应该是可定向的，并应该确保抽象状态保持足够精度</p></li>
<li><p><strong>代码属性图（CPG</strong>）是一种综合了抽象语法树（AST）、控制流图（CFG）和程序依赖图（PDG）的数据结构，它可以帮助分析人员更好地理解代码的结构和行为。CPG可以通过将AST、CFG和PDG结合起来，从而捕获代码中的更多细节和复杂性，提供更全面的代码分析和理解</p></li>
<li><p><strong>程序依赖图（Program Dependence
Graph，PDG）</strong>是一种表示程序执行流程和数据依赖关系的图形化表示方法。在PDG中，程序的每个语句表示为节点，每个节点之间通过边连接表示语句间的依赖关系，包括数据依赖、控制依赖和输出依赖。</p>
<p><strong>数据依赖</strong>：如果一个语句使用了另一个语句的输出，那么它们之间存在数据依赖。例如，赋值语句的右侧使用了变量，那么它们之间就存在数据依赖。</p>
<p><strong>控制依赖</strong>：如果一个语句的执行受另一个语句的控制结构影响，那么它们之间存在控制依赖。例如，if语句和while语句的条件语句控制了其内部语句的执行。</p>
<p><strong>输出依赖</strong>：如果一个语句的输出被另一个语句使用，那么它们之间存在输出依赖。例如，函数调用的返回值被另一个语句使用。</p></li>
<li><p><strong>Sanitization
Functions（清洗函数）</strong>是一类函数，用于过滤和转义输入数据，以确保输入数据不包含任何恶意内容。这些函数通常用于防止跨站脚本攻击（XSS）和SQL注入攻击等安全威胁。</p>
<p>例如，如果一个 Web
应用程序需要从用户输入中接收一个字符串，该字符串将被传递给数据库进行查询，那么必须使用一个清洗函数对该字符串进行处理，以防止
SQL
注入攻击。常用的清洗函数包括转义单引号、双引号、反斜杠等特殊字符。</p>
<p>在 Node.js
中，可以使用各种模块和库来实现输入数据的清洗。例如，可以使用
<code>sanitize-html</code> 模块过滤 HTML 标签，或者使用
<code>mysql</code> 模块的 <code>mysql.escape()</code> 函数来转义 SQL
查询中的特殊字符。</p></li>
</ul>
<h4 id="总结-23">总结</h4>
<ul>
<li>关于<strong>代码分析方法设计的图结构</strong>总结
<ul>
<li>抽象语法树（AST）</li>
<li>控制流图（CFG）</li>
<li>代码属性图（CPG）</li>
<li>程序依赖图（Program Dependence Graph，PDG）
<ol type="1">
<li>数据依赖</li>
<li>控制依赖</li>
<li>输出依赖</li>
</ol></li>
</ul></li>
<li><strong>收获：</strong>这篇论文令我意外：因为本文的研究并没有设计人工智能模型
<ol type="1">
<li>如果不加入人工智能模型，我感觉很难做出创新</li>
<li>我对本文的理解就是：在前人做出的基于图的代码分析方法基础上，针对JavaScript这种语言的特性（主要是原型链），提出了对对象（面向对象编程中的一种数据类型，在这种语言中，函数也是对象）建模的一种方法并将前几种图结构结合，作者定义为ODG。</li>
</ol></li>
</ul>
<h3 id="section-34">2023-03-24</h3>
<h4 id="期刊">期刊</h4>
<blockquote>
<ul>
<li><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/xpl/conhome/9842455/proceeding">2022
IEEE 46th Annual Computers, Software, and Applications Conference
(COMPSAC)</a>
<ul>
<li><strong>CCF-C</strong> (软件工程/系统软件/程序设计语言)</li>
</ul></li>
</ul>
</blockquote>
<h4 id="论文1-7">论文1</h4>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9842744">Can Deep
Learning Models Learn the Vulnerable Patterns for Vulnerability
Detection?</a> [<strong>CCF-C</strong>: 2022 IEEE 46th Annual Computers,
Software, and Applications Conference (COMPSAC)]</li>
<li><strong>Date of Conference</strong>: 27 June 2022 - 01 July
2022</li>
</ul>
</blockquote>
<ul>
<li><p><strong>研究问题</strong>：</p>
<ul>
<li>深度学习能否在漏洞检测上有所作为</li>
<li>探索上述问题的可解释性</li>
</ul></li>
<li><p><strong>关键词：</strong>Vulnerability detection, Deep learning,
Atten-tion, Model interpretability</p></li>
<li><p><strong>ML和DL</strong></p>
<blockquote>
<p><strong>机器学习</strong>是人工智能的一个分支，它是一种使用算法和统计模型让计算机自动地从数据中学习规律，并用于预测或分类的方法。它可以分为有监督学习、无监督学习、半监督学习和强化学习等不同类型。</p>
<p><strong>深度学习</strong>是机器学习的一种特定形式，它是一种建立在人工神经网络基础上的机器学习技术。它的主要特点是可以通过构建多层非线性变换的神经网络来提取和学习数据的高阶特征表示，从而实现对复杂模式和规律的识别和预测。深度学习可以应用于图像识别、语音识别、自然语言处理等领域，已经成为人工智能领域的重要分支之一。</p>
<ul>
<li><strong>有监督学习</strong>：在有监督学习中，我们提供带标签的数据集作为输入，并让算法从数据中学习规律，以便将新的数据进行分类或预测。例如，根据房屋的面积、位置、卧室数等特征，预测房价。</li>
<li><strong>无监督学习</strong>：在无监督学习中，我们提供未标记的数据集作为输入，让算法自己发现其中的规律和结构。例如，聚类分析可以将相似的数据点分为一组，从而发现数据中的类别。</li>
<li><strong>半监督学习</strong>：在半监督学习中，我们同时使用带标签和未标记的数据集进行训练，以提高算法的准确性。这种方法通常可以在数据集较小的情况下获得更好的结果。</li>
<li><strong>强化学习</strong>：在强化学习中，算法通过与环境的交互来学习最优行为策略。它与其他机器学习方法不同，因为它是一种试错学习方法，通过反馈机制不断调整策略以实现最优结果。例如，训练机器人在环境中移动和完成任务。</li>
<li><strong>迁移学习</strong>：迁移学习是指将已经学习到的知识迁移到新的任务或领域中。通过利用已经学习到的知识，可以加快新任务的学习速度和提高学习的效果。</li>
<li><strong>增强学习</strong>：增强学习是指在强化学习的基础上，为了实现更好的性能，通过不断改进学习过程和策略来提高算法的表现。</li>
<li><strong>深度学习</strong>：深度学习是一种建立在神经网络上的机器学习技术，可以自动提取和学习数据的高阶特征表示。深度学习广泛应用于计算机视觉、自然语言处理和语音识别等领域。</li>
<li><strong>概率图模型</strong>：概率图模型是一种用于建模复杂数据关系的方法，包括贝叶斯网络和马尔科夫随机场等。它们通常用于无监督学习和半监督学习中，可以对数据进行建模和分析。</li>
</ul>
</blockquote></li>
<li><p><strong>注意力机制</strong></p>
<blockquote>
<p>是一种人工智能中常用的技术，它可以使神经网络更好地处理序列数据，并将重点放在最相关的部分上。</p>
<p>在注意力机制中，网络可以根据输入数据中的不同部分分配不同的注意力权重，以便更好地识别和利用有用的信息。例如，在文本分类中，网络可以根据文本中每个单词的重要性分配不同的注意力权重，以便更好地判断文本的类别。</p>
<p>注意力机制可以用于各种任务，如自然语言处理、语音识别、图像识别等。它已经成为深度学习中的一种常用技术，并在很多实际应用中取得了很好的效果</p>
<ul>
<li><p>序列数据</p>
<blockquote>
<p>序列数据是指按照时间顺序排列的一系列数据，通常用于描述某个事件或过程的演变。序列数据可以是文本、语音、图像等，它们都具有一定的时序性和相关性。</p>
<p>在人工智能中，序列数据经常用于各种任务，如语音识别、自然语言处理、时间序列预测等。为了处理序列数据，通常需要使用一些特殊的技术和模型，例如循环神经网络（RNN）、长短时记忆网络（LSTM）、卷积神经网络（CNN）等。</p>
<p>序列数据的处理和建模是人工智能研究中的重要方向之一，它们可以帮助我们更好地理解和分析各种事件和过程，提高各种任务的准确性和效率。</p>
</blockquote></li>
</ul>
</blockquote></li>
<li><p><strong>模型可解释性</strong></p>
<blockquote>
<p>是指在人工智能和机器学习中，对于一个训练好的模型，我们能够清晰地理解和解释其预测结果的过程和原因。具有良好的可解释性的模型可以帮助我们更好地理解和掌握数据的本质规律，提高对数据的信任和理解度。</p>
<p>在实际应用中，模型的可解释性非常重要。例如，在医疗诊断中，对于一个预测结果，我们需要知道该结果是由哪些因素决定的，以便更好地了解患者的病情和制定治疗方案。在金融风控中，我们需要知道一个信用评估模型如何得出其评估结果，以便更好地预测风险和做出决策。</p>
<p>提高模型的可解释性是一个研究热点和难点，研究人员们正在不断尝试各种方法和技术来实现这个目标。例如，利用可视化技术、特征重要性分析、局部可解释性等方法来提高模型的可解释性。</p>
</blockquote></li>
<li><p><strong>论文正文</strong></p>
<ul>
<li><p><code>Chakraborty et al. [5] claim that DL models learn certain irrelevant features which are harmful to improve the performance of vulnerability detection</code></p></li>
<li><p><strong>基于代码相似性的漏洞检测方法</strong>：</p>
<p>是指通过比较源代码的相似性，发现潜在的漏洞。该方法可以分为静态和动态两种。</p>
<p><strong>静态方法</strong>主要是通过对源代码进行静态分析，找出潜在的漏洞点。其中，代码相似度计算是静态方法中的关键步骤。代码相似度计算方法包括文本相似度、语法树相似度和程序切片等。</p>
<p><strong>动态方法</strong>主要是通过对程序的执行过程进行分析，找出漏洞点。其中，基于程序执行过程的代码相似度计算方法是动态方法的关键步骤。这种方法需要对程序进行插桩，然后记录程序执行的信息，比较程序执行过程中的相似度，最终找出漏洞点。</p></li>
<li><p>基于<strong>代码相似性</strong>的漏洞检测方法和基于<strong>代码模式</strong>的漏洞检测方法都是常见的<strong>自动化</strong>漏洞检测方法。</p>
<blockquote>
<p><strong>模式：</strong>经常出现的一些结构或者行为</p>
<ul>
<li><p><strong>语法分析</strong>：识别代码中的各个元素（如变量、函数、关键字等）以及它们之间的关系</p></li>
<li><p><strong>语义分析</strong>：对代码中的各个元素进行语义解释和推理</p>
<blockquote>
<p>例如，我们需要确定代码中变量的<strong>数据类型、函数的返回值以及各个语句的执行顺序</strong>等信息。</p>
</blockquote></li>
</ul>
<p><strong>比如</strong>缓冲区溢出中的内存访问越界、格式化字符串中的格式化输入等等。模式是由专家手工定义或者通过机器学习从源代码中自动学习得到的。模式匹配的过程通常使用<strong>正则表达式</strong>或者其他<strong>模式匹配算法</strong>，如<strong>图匹配算法</strong>等</p>
<p><strong>相似度：</strong></p>
</blockquote>
<p>基于<strong>代码相似性</strong>的漏洞检测方法主要是通过对源代码进行<strong>语法和语义分析</strong>，比较代码之间的相似度，从而检测潜在的漏洞。该方法的优点是能够准确地检测出源代码中的漏洞，并且能够自动地识别<strong>不同类型</strong>的漏洞。同时，该方法也存在一些问题，比如需要大量的计算资源和时间，还容易出现误报和漏报的情况。</p>
<p>基于<strong>代码模式</strong>的漏洞检测方法主要是通过学习代码中的模式来检测潜在的漏洞。该方法的优点是能够有效地检测出<strong>特定类型</strong>的漏洞，比如缓冲区溢出、代码注入等等。同时，该方法也存在一些问题，比如检测效果受限于训练数据，无法检测出新型漏洞等。</p></li>
<li><p><strong>三种类型的漏洞数据集</strong>：真实世界、半合成和合成</p></li>
<li><p><strong>两类漏洞模型</strong>用于漏洞检测</p>
<ul>
<li>基于序列的模型</li>
<li>基于GNN的模型</li>
</ul></li>
<li><p>方法论</p>
<ul>
<li><p><strong>数据预处理</strong>：数据依赖图（DDG）:数据依赖图是指用图形化的方式展示程序中各个变量之间的依赖关系</p>
<blockquote>
<ol type="1">
<li><p>数据（代码）的预处理：其中涉及较多的编译原理知识：我们分析代码的过程正是模仿了编译器对代码的处理模式。主要理解了以下几点</p>
<p>Ast（抽象语法树）、CFG（控制流图）和DDG（数据依赖图）是程序分析中常用的三种表示程序结构和行为的图形模型。</p>
<blockquote>
<ol type="1">
<li>Ast是基础：
Ast是程序代码的语法表示，是从程序代码中提取出的最基本的语法元素。</li>
<li>CFG基于Ast：CFG是基于Ast构建的，它利用Ast的语法元素作为节点，并使用Ast中的控制语句来构建图形模型。</li>
<li>DDG基于Ast和CFG：DDG是基于Ast和CFG构建的，它既包含Ast中的语法元素，也包含CFG中的控制结构，同时还包含变量和数据之间的依赖关系。</li>
</ol>
</blockquote></li>
</ol>
</blockquote>
<ul>
<li><strong>JavaParser</strong>是一个Java语法树分析器，它可以将Java代码解析成语法树，方便程序员进行各种静态代码分析、重构和优化</li>
<li><code>Labeling the vulnerability-related code lines.</code>难以理解这部分内容</li>
<li><strong>抽象语法树</strong>通常是在源代码经过词法分析和语法分析后生成的，它描述了程序的结构和语义。</li>
<li>通常我们将样本以<strong>向量</strong>的形式作为模型的输入</li>
</ul></li>
<li><p><strong>模型生成</strong>：</p>
<ul>
<li><p>图节点嵌入：指DDG</p></li>
<li><p>高层特征的生成和分类:不同于初始特征</p></li>
</ul></li>
<li><p><strong>模型测试</strong>：模型的可解释性，制定评估标准，本文为DDG节点的注意力得分</p></li>
</ul>
<figure>
<img src="https://s2.loli.net/2023/03/25/H2XGapiwEJjgt3P.png"
alt="image-20230325005007803" />
<figcaption aria-hidden="true">image-20230325005007803</figcaption>
</figure></li>
</ul></li>
<li><p><strong>问题：</strong></p>
<ul>
<li>关于对数据（代码）的预处理：总体上是能理解的，这是对代码静态分析的过程</li>
<li>模型的测试与生成：细节看不懂</li>
</ul></li>
<li><p><strong>实验与讨论</strong></p></li>
<li><p><strong>THREATS TOVALIDITY</strong>：</p>
<ul>
<li>其一是<strong>模型的可解释性</strong>
：现已被推广到恶意代码的检测和安全应用，但是在漏洞检测上还很少</li>
</ul></li>
</ul>
<h4 id="总结-24">总结</h4>
<ul>
<li><p><strong>阅读论文后的总结：</strong></p>
<p>对于文中涉及的<strong>重要概念与技术方法</strong>都查阅了资料进行学习和理解，以上是记录的全过程，以下是其中的一些收获：</p>
<p>本周所阅读的论文探讨的问题：<strong>深度学习是否能学习代码的模式去检测漏洞</strong>；这也正是本文的标题。具体来说包含以下几个方面：</p>
<blockquote>
<ol type="1">
<li>漏洞检测的DL模型的可解释性问题</li>
<li>实现四个注意力模型（两种分类）进行了实验</li>
<li>定义两个评估指标评估模型的可解释性</li>
</ol>
</blockquote>
<p>上周正好提到在静态分析代码时的一种漏洞检测方式正是：<strong>基于代码模式的漏洞检测方法</strong></p>
<p>针对这种方法，主要有<strong>三个步骤环节</strong>：数据的预处理、模型的测试、模型的生成</p>
<p><strong>总的来说</strong>：之前，我只是知道恶意代码分析<strong>有什么方式</strong>，ok,这次我深入了解了代码的分析和处理方法——基于代码模式的方法：学习了它的<strong>整个流程</strong>。</p>
<p>我发现：深度学习在漏洞检测上很重要一点是：引入<strong>注意力机制</strong>去处理源代进而学习特征</p></li>
<li><p><strong>其他收获：</strong>
当检索到相关的论文困难时，检索特定作者名字是个不错的方式，并可以阅读作者所有相关论文。</p></li>
<li><p><strong>下一个目标</strong>
：上周学习了两篇论文，其中一篇是<strong>二进制程序</strong>的漏洞挖掘，另一篇是<strong>web应用</strong>的漏洞挖掘</p>
<p>通过检索发现现在的主要研究集中在二进制程序上，因此我打算<strong>另辟蹊径</strong>，更多地探索在web应用上的漏洞挖掘</p></li>
</ul>
<h3 id="section-35">2023-03-17</h3>
<h4 id="关于一些期刊的了解">关于一些期刊的了解</h4>
<blockquote>
<ul>
<li><strong>ACM Computing Surveys</strong>
是计算机领域的国际顶级期刊<strong>，专注刊登计算机领域的最新综述研究成果，2020-2021年度影响因子10.282，是中科院JCR一区Top期刊。</strong></li>
<li><strong>IEEE COMMUNICATIONS SURVEYS &amp; TUTORIALS</strong>
中科院JCR分区一区TOP</li>
</ul>
</blockquote>
<h4 id="论文1-8">论文1：</h4>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.hindawi.com/journals/scn/2020/8858010/">A
Survey of Automatic Software Vulnerability Detection, Program Repair,
and Defect Prediction Techniques</a>（<strong>CCF-C:</strong>Security
and Communication Networks 2020）</li>
<li>time:Published 30 September 2020</li>
<li>记录我所学习和能理解的知识</li>
</ul>
</blockquote>
<hr />
<ul>
<li>漏洞检测
<ul>
<li>根据静态分析技术：
<ul>
<li>基于代码相似性的漏洞检测方法：clone detection
，相似的程序代码具有相似的漏洞
<ul>
<li>Grammar-Based Clone Detection Methods.
<ul>
<li>代码表征</li>
</ul></li>
<li>Semantic-Based Clone Detection Methods</li>
</ul></li>
<li>基于代码模式的漏洞检测方法：According to whether the program needs
to be run
<ul>
<li>static detection methods</li>
<li>dynamic detection methods,</li>
</ul></li>
<li>静态分析和神经网络训练原理
<ul>
<li>样本代码提取</li>
<li>特征提取
<ul>
<li>漏洞特征提取主要涉及如何选择合适的颗粒度来表示软件程序和漏洞检测</li>
</ul></li>
<li>词向量生成
<ul>
<li>深度学习或神经网络将向量作为输入，我们需要将程序表示为对漏洞检测有语义的向量</li>
</ul></li>
<li>神经网络模型训练和分类<img
src="https://s2.loli.net/2023/03/16/sbr8P15Kqyucd4W.png"
alt="image-20230316205203892" />
<ul>
<li><strong>训练</strong>：训练阶段将从历史代码库中提取的代码向量表示作为输入，其输出是神经网络的微调模型参数</li>
<li><strong>检测</strong>：从新的软件程序中提取的代码向量表示被作为输入</li>
</ul></li>
</ul></li>
<li><strong>动态方法</strong>：与静态方法相比，动态方法分析漏洞是为了获得具体的运行信息，所以分析出来的漏洞一般比较准确，误报率也比较低。</li>
</ul></li>
<li>Dissussion
<ul>
<li>深度学习技术可以减少人为的<strong>特征工程</strong>，在未来的研究过程中，有望取代传统的漏洞检测方法，大幅提高漏洞检测性能。然而，深度学习在漏洞检测方法中面临着许多<strong>缺陷</strong>，其中模型往往是基于程序源代码进行训练的</li>
<li><strong>神经网络结构的优化</strong>和<strong>特征参数的选择</strong>一直是相关从业人员面临的问题。现有的代码漏洞检测技术往往是基于<strong>10倍交叉验证</strong>的训练方法来获得最优参数，这种方式对于大规模的项目数据来说往往会影响训练时间和模型性能。</li>
</ul></li>
</ul></li>
</ul>
<hr />
<ul>
<li>Automatic Software Program Repair
<ul>
<li>Patching Process
<ul>
<li><p>the software fault location phase,</p></li>
<li><p>the patch generation phase,</p></li>
<li><p>Te search-based patch generation method</p></li>
<li><p>Te semantic-based patch generation method</p></li>
<li><p>and the patch evaluation phase.</p></li>
</ul></li>
<li>Grammar-Based Patching Technology
<ul>
<li>Token-LevelLearningandRepairTechnology.</li>
<li>Text-Based Learning and Repair Technology</li>
</ul></li>
<li>Semantic-Based Patching Technology</li>
</ul></li>
<li><code>In the future program repair technology, we can learn from the vulnerability detection technology that combines with AST and PDG technology to enhance the performance of the existing program semantic repair technology and analysis of the impact of feature parameters on the model performance to further promote the applications of deep learning technology in the program repair technology</code></li>
</ul>
<hr />
<ul>
<li>Automatic Software Defect Predicting
<ul>
<li>Within-Project Defect Prediction</li>
<li>Crossproject Defect Prediction</li>
<li>Just-In-Time Defect Prediction</li>
</ul></li>
</ul>
<hr />
<ul>
<li>Future Directions and Challenges
<ul>
<li>Feature Generation.</li>
<li>Model Selection</li>
<li>Datasets.</li>
<li>Performance Evaluation</li>
<li>Feature Parameters</li>
</ul></li>
</ul>
<h4 id="论文2-3">论文2</h4>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3474553">Efficiency and
Effectiveness of web application vulnerability detection approaches: A
Review</a> （<a target="_blank" rel="noopener" href="https://dl.acm.org/toc/csur/2022/54/9">ACM
Computing Surveys</a>：中科院分区一区top）</li>
<li>time:
<ul>
<li>Published: 8 October 2021</li>
<li>Accepted: 1 July 2021</li>
<li>Revised: 1 June 2021</li>
<li>Received: 1 March 2020</li>
</ul></li>
<li>最流行的科学出版物数据库：
<ul>
<li>IEEE Xplore、</li>
<li>ACM数字图书馆、</li>
<li>Elsevier Science Direct、</li>
<li>SpringerLink</li>
<li>Web of Science</li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>web application vulnerability detection (WAVD)</li>
<li>类别
<ul>
<li>输入验证（IPV）漏洞
<ul>
<li>Sql注入</li>
<li>Xss</li>
<li>Ldap注入</li>
<li>remote code execution (RCE)</li>
<li>local or remote file inclusion (LFI/RFI).</li>
</ul></li>
<li>会话管理（SM）漏洞
<ul>
<li>session fixation</li>
<li>session sniffing</li>
<li>cross-site request forgery (CSRF)</li>
</ul></li>
<li>应用逻辑（AL）漏洞）
<ul>
<li>parameter manipulation</li>
<li>weak access control</li>
<li>workflow bypass</li>
<li>workflow violation</li>
</ul></li>
</ul></li>
<li>更详细的类别：Open Worldwide Application Security Project (OWASP)
top 10</li>
<li>AST（Abstract Syntax Tree）指抽象语法树，</li>
</ul>
<blockquote>
<p>是指程序代码在<strong>语法分析阶段</strong>被转换成树形结构的一种形式。在编译器或解释器中，AST
通常用于表示源代码的抽象语法结构，以便于后续的<strong>代码分析和优化</strong>等操作。它是一种中间表示形式，可以更方便地进行代码分析和转换，例如语法检查、代码优化、重构等。同时，由于
AST
只表示程序的抽象语法结构，因此它通常不包含与<strong>程序执行相关的细节信息</strong>，例如变量的具体值、函数调用的具体执行过程等。</p>
</blockquote>
<ul>
<li>The artifacts analyzed by the WAVD approaches<img
src="https://s2.loli.net/2023/03/18/a8nvdR9Zyj46XgI.png"
alt="image-20230318014038238" /></li>
</ul>
<blockquote>
<ul>
<li>模型（Model）：表示系统或应用程序的抽象描述，可以是图形、图表或其他形式。</li>
<li>属性（Attribute）：表示模型或代码元素的特征或性质，例如类的名称、方法的返回类型等。</li>
<li>代码元素（Code
element）：程序代码中的一个组成部分，例如类、方法、变量等。</li>
<li>AEP（Attack Execution
Plan）：指攻击者的攻击执行计划，包括攻击的目标、方法和技术等。</li>
<li>约束或模式（Pattern）：指一组预定义的规则或模板，用于描述和识别软件中的特定问题或漏洞。</li>
<li>指纹（Fingerprint）：指软件或系统中的独特标识符，用于识别和区分不同的软件或系统。例如，每个操作系统和应用程序都有自己的指纹，可以用于识别和区分它们</li>
</ul>
</blockquote>
<ul>
<li>一个在ML 中经常出现的词<strong>F-measure</strong>，</li>
</ul>
<blockquote>
<p>也称为F1-score，是一种用于衡量二元分类模型性能的指标。它结合了准确率（precision）和召回率（recall）两个指标，是它们的调和平均数。具体而言，F1-score可以表示为：</p>
<p>F1-score = 2 * (precision * recall) / (precision + recall)</p>
<p>其中，准确率指被分类器正确分类的正样本数与所有被分类为正样本的样本数之比。召回率指被分类器正确分类的正样本数与所有真实正样本数之比。</p>
<p>F1-score将准确率和召回率综合起来，可以在评价模型性能时同时考虑模型对正样本和负样本的分类能力。在不同模型之间比较时，F1-score可以更全面地反映模型的分类性能，特别是在样本不均衡的情况下。</p>
</blockquote>
<ul>
<li>Dissussion</li>
</ul>
<blockquote>
<p><code>我们发现大多数（105个中的78个）我们确定的主要研究集中在注入漏洞上。许多其他的漏洞，如重定向后的执行、逻辑漏洞、状态侵犯、侧信道、DoS和配置，都没有得到充分的探索。OWASP前10名中列出的一些漏洞，如XML外部实体（XXE）和不安全的反序列化，还没有被许多初级研究覆盖。由于 "一个软件安全系统的安全性取决于其最薄弱的部分"[170]，因此需要更多关于检测这些未被探索的漏洞的研究</code>。</p>
</blockquote>
<ul>
<li><ul>
<li>两个指标：二元分类模型中经常使用的评估指标
<ul>
<li>FPR 和FNR</li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p><code>我们审查的大多数主要研究集中在基于PHP和Java的应用程序上。没有一项研究关注使用Python开发的网络应用，很少有研究关注基于JavaScript的应用。根据市场研究[172,173]，Python和JavaScript正在成为网络应用程序开发中最常用的编程语言。我们需要更多的WAVD研究和测试套件来关注使用Python和JavaScript开发的应用程序</code></p>
</blockquote>
<ul>
<li>总结：
<ul>
<li>这篇论文讨论了三个问题：
<ul>
<li>对WAVD 方法的分类研究</li>
<li>方法的效率和有效性研究（很多内容看不懂）</li>
<li>漏洞检测工具套件的讨论</li>
</ul></li>
<li>主要是注意disscussion中的future work</li>
</ul></li>
</ul>
<h4 id="总结见本地文档">总结：见本地文档</h4>
<h3 id="section-36">2023-03-10</h3>
<h4 id="论文学习">论文学习</h4>
<h5 id="论文1-9">论文1</h5>
<blockquote>
<ul>
<li><a
target="_blank" rel="noopener" href="https://link.springer.com/article/10.1007/s00521-021-06597-0">Applications
of deep learning for mobile malware detection: A systematic literature
review</a>(NCA:人工智能-CCF-C)</li>
<li><code>Received: 27 November 2020 / Accepted: 4 October 2021</code>因为是一片综述文章，所以时间需要注意</li>
<li>橘色片段皆是从原文摘录的信息</li>
</ul>
</blockquote>
<ul>
<li><p>机器学习在恶意代码检测中的应用</p>
<ul>
<li>Malware detection</li>
<li>Malware similarity analysis
<ul>
<li>Variants detection</li>
<li>Families detection</li>
<li>Differences detection</li>
</ul></li>
<li>Malware category detection</li>
</ul></li>
<li><p>混淆</p>
<ul>
<li>静态分析
<ul>
<li>无法应用在使用了混淆技术的恶意代码上</li>
<li><strong>混淆</strong>
<ul>
<li>encryption,</li>
<li>oligomorphic,</li>
<li>polymorphic,</li>
<li>metamorphic</li>
<li>stealth,</li>
<li>and packaging</li>
</ul></li>
</ul></li>
<li>动态分析</li>
<li>混合分析</li>
</ul></li>
<li><p>DL and DL algorithms</p>
<ul>
<li>ANN
<ul>
<li>input layer</li>
<li>hideen layer</li>
<li>output layer</li>
</ul></li>
<li>DL
<ul>
<li>比ANN 有更多样的层数</li>
<li>Recursive neural network (RvNN)</li>
<li>RNN
<ul>
<li>LSTM</li>
</ul></li>
<li>Convolutional neural network (CNN)</li>
<li>Deep generative networks (DGN)</li>
<li>divided deep learning architectures into the three classes
<ul>
<li>generative,</li>
<li>discriminative,</li>
<li>and hybrid</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>目前基于<strong>windows</strong>恶意代码的检测是比较多的</p></li>
<li><p>following research directions and challenges:</p>
<ul>
<li>availability of the open and public datasets,</li>
<li>concept drift concept,</li>
<li>incremental learning,</li>
<li>adversarial learning,</li>
<li>and the problem of class imbalance</li>
</ul></li>
<li><p>Malware detection</p>
<ul>
<li>signature-based,</li>
<li>behavior-based,</li>
<li>heuristic-based,</li>
<li>model checking-based,</li>
<li>deep learningbased,</li>
<li>cloud-based,</li>
<li>mobile-based,</li>
<li>IoT-based techniques</li>
</ul></li>
<li><p>静态分析</p>
<ul>
<li>基于安卓特性</li>
<li>基于操作码</li>
<li>基于程序图</li>
<li>基于符号执行</li>
</ul></li>
<li><p>半监督学习方法在恶意代码检测的应用还比较少</p></li>
<li><p>很少研究关注静态特征和动态特征的结合</p></li>
<li><p>多模式和多视角的深度学习值的注意</p></li>
<li><p>当前研究主要关注其中的一种或两种数据<img
src="https://s2.loli.net/2023/03/09/2myoRwL4iKN7VpJ.png"
alt="image-20230309105101450" /></p></li>
</ul>
<hr />
<ul>
<li><p>在研究malware的深度学习模型时不需要特征选择技术</p></li>
<li><p>实验数据的选取<img
src="https://s2.loli.net/2023/03/09/S2fAOXvIjPBL5Hn.png" /></p></li>
<li><p>深度学习开发平台的选择<img
src="https://s2.loli.net/2023/03/09/mEepQA4lPqbZT3n.png"
alt="image-20230309213948238" /></p></li>
<li><p>Challenge and proposed solutions <img
src="https://s2.loli.net/2023/03/09/K4fhE6TROkwceuj.png"
alt="image-20230309214744642" /></p></li>
<li><p>Dissusion（创新点）</p>
<ul>
<li><p><code>the integration of reinforcement learning with deep learning approaches and the application of these models on malware detection is considered as a future research direction</code></p></li>
<li><p>静态特征与动态特征的结合还很少人做</p></li>
<li><p>将不同的模型融合到一个模型是个不错的想法；其次，<code>Also, we observed that some machine learning types such as multi-task learning, multi-modal learning, and multiview learning were neglected, but they can be applied effectively in mobile malware detection problem.</code></p></li>
<li><p><code>准确度和F-measure是广泛使用的评价参数，交叉验证是最受欢迎的验证方法</code>：
不太理解这个问题。感觉是：使用什么参数去评估实验效果？</p></li>
<li><p>寻找最优的算法，目前研究主要集中在DNN和CNN</p></li>
<li><p>模型和和算法区分</p></li>
</ul>
<blockquote>
<ul>
<li>模型：描述解决问题的函数</li>
<li>算法：机器学习中的“算法”是在数据上运行以创建机器学习“模型”的过程,e.g.:
<ul>
<li>线性回归算法的结果是一个由具有特定值的稀疏向量组成的模型。</li>
<li>决策树算法的结果是一个由具有特定值的 if-then 语句树组成的模型。</li>
<li>神经网络 / 反向传播 /
梯度下降算法一起产生一个由具有特定值的向量或权重矩阵和特定值的图结构组成的模型。</li>
</ul></li>
</ul>
</blockquote>
<ul>
<li>Better maintenance of malware datasets and sustainable platforms for
hosting malware datasets We identified the following research directions
to pave the way for further research and explained them in the
Discussion section:</li>
<li>The development of unsupervised deeplearning approaches for malware
detection</li>
<li>The development of semi-supervised deep learning models for malware
detection</li>
<li>The development of reinforcement learning-based deep learning
techniques for malware detection</li>
<li>More hybrid features-based techniques</li>
<li>A framework for better</li>
<li>benchmarking of deep learning-based approaches and better
experimental design to compare more DL algorithms to reach more general
results</li>
<li>Better maintenance of malware datasets and sustainable platforms for
hosting malware datasets</li>
<li>More datasets should be used in experimental design to compare the
performance of ML/DL algorithms to reach more reliable results</li>
</ul></li>
</ul>
<h5 id="论文2-4">论文2</h5>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9964330">A Survey of
Adversarial Attack and Defense Methods for Malware Classification in
Cyber Security</a>（中科院JCR分区一区TOP:IEEE COMMUNICATIONS SURVEYS
&amp; TUTORIALS）</li>
<li>时间：<code>Manuscript received 3 May 2022; revised 4 September 2022; accepted 4 November 2022. Date of publication 28 November 2022; date of current version 24 February 2023</code></li>
<li>橘色片段皆是从原文摘录的信息</li>
</ul>
</blockquote>
<ul>
<li><p><strong>Index Terms</strong>—Cyber security, malware, malware
classification, adversarial examples, adversarial robustness.</p></li>
<li><p><code>Attackers propose various  attack methods to generate adversarial malware examples to bypass ML-based malware classifiers.</code></p>
<ul>
<li><code>For white-box attacks, gradient information is used to guide the generation of adversarial perturbations [33], [34], [35].</code></li>
<li><code>For black-box attacks, some researchers train a substitute model to fit the black-box victim classifier and then leverage white-box methods [36], [37], [38].</code></li>
<li><code>Others only use prediction results to manipulate original examples and generate adversarial examples [39], [40], [41], [42].</code></li>
<li><code>Researchers also propose defense methods to improve the robustness of ML models against adversarial attacks, such as adversarial training [43][44],ensemble learning [45], [46], GAN-baseddefense</code></li>
</ul></li>
<li><p><code>Some researchers propose to preprocess input data by identifying and removing adversarial examples [49].</code></p></li>
<li><p><code>Some defense methods select subsets of features in order to increase the difficulty of adversarial malware attacks [19], [50].</code></p></li>
<li><p><code>Besides, adversarial training and ensemble learning methods are introduced to improve the adversarial robustness of ML-based malware classifiers [16], [34], [51], [52].</code></p></li>
<li><p>general process of ML-based malware classification<img
src="https://s2.loli.net/2023/03/11/KHhlPGFpWxN9XBM.png"
alt="image-20230311003702766" /></p>
<ul>
<li>Data Preprocessing,
<ul>
<li><strong>Data augmentation</strong> and <strong>equalization
techniques</strong> can be used in this phase to train stronger malware
classifiers</li>
<li><strong>Unpacking techniques</strong> can also balance training
data, which leads to more convincing experimental results.</li>
</ul></li>
<li>Feature Collection,</li>
<li>静态特征： raw bytes, operation codes, function calls, etc.</li>
<li>动态特征： Application Programming Interface (API) calls, network
traffic, hardware-based features, etc.</li>
<li>Feature Extraction,
<ul>
<li>High-level features are extracted to select <strong>important
features</strong>, reduce feature size, and construct input features for
the classification model.</li>
<li><strong>vectorization techniques</strong> (such as byte embedding
and word embedding) and some feature compression methods (such as
malware images and feature selection) can be leveraged.</li>
</ul></li>
<li>Classification,
<ul>
<li>Classification: ML-based models are chosen as malware classifiers to
make predictions on input features.Basic ML models can be used as
malware classifiers, such as Support Vector Machine (SVM), Logistic
Regression (LR), Random Forest (RF), etc. Some DL models are also used,
such as Deep Neural Network (DNN), Convolutional Neural Network (CNN),
Recurrent Neural Network (RNN), etc.</li>
</ul></li>
<li>Decision Making</li>
<li>分类的两种方式
<ul>
<li>Binary-Classification: A given software example is deter- mined as
malicious or benign, which is also called malware detection in many
studies.</li>
</ul>
<ol start="2" type="1">
<li>Multi-Classification: A given malware example is classi- fied into
one malware family.</li>
</ol></li>
<li>一些模型示例<img
src="https://s2.loli.net/2023/03/11/TfvanXKsJGAYb2u.png"
alt="image-20230311002016915" /></li>
<li>comparison<img
src="https://s2.loli.net/2023/03/11/afCWghNbxU2Rm1S.png"
alt="image-20230311002646769" /></li>
<li>分类器 Challenges
<ul>
<li>Classifier Aging Problem</li>
<li>Data Bias Problem：</li>
<li>在特征提取的时候虚拟环境会被恶意代码识别，因此而隐藏自己的恶意行为
<ul>
<li>解决：Parallel Adversarial Network (PAN)</li>
</ul></li>
</ul></li>
<li>攻击<img src="https://s2.loli.net/2023/03/11/qUeps4tnJLkh8QS.png"
alt="image-20230311012141298" />
<ul>
<li>White-box Attacks: Attackers have full knowledge of the victim
model, including training data, model structure, parameters, gradient
information, and predictions.</li>
</ul></li>
<li>two kinds of adversarial attack methods:
<ul>
<li>Targeted Attacks: Attackers mislead the victim model to produce a
chosen classification result.</li>
<li>Untargeted Attacks: Attackers mislead the victim model to produce a
wrong classification result.</li>
</ul></li>
<li>基于机器学习的对抗攻击
<ul>
<li>White-Box
<ul>
<li>L-BFGS attack</li>
<li>FGSM attack</li>
<li>Least-likely class attack</li>
<li>PGD attack</li>
<li>DeepFool attack</li>
<li>JSMAattack</li>
<li>C&amp;W attack:</li>
</ul></li>
<li>Black-Box
<ul>
<li>Substitution attack</li>
<li>Boundary attack</li>
<li>Optimizationattack</li>
<li>SimBA attack</li>
<li>AdvGAN</li>
<li>Zoo attack</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>ADVERSARIAL ATTACK METHODS ON ML-BASED MALWARE CLASSIFIERS<img
src="https://s2.loli.net/2023/03/11/EmiQnNMTpRodask.png"
alt="image-20230311014242325" /></p></li>
<li><p>攻击方法面临的挑战：</p>
<ul>
<li>Query-Efficiency</li>
<li>Inverse-Mapping Problem：不太理解</li>
</ul></li>
<li><p>防御：improve the robustness of classifiers in the ML domain.
<img src="https://s2.loli.net/2023/03/11/AGjrIKfH96ET1WZ.png"
alt="image-20230311015415990" /></p>
<ul>
<li>Adversarial Training:
<ul>
<li>FGSM-based adversarial training:</li>
<li>PGD-based adversarial training</li>
<li>Free adversarial training</li>
<li>Fast adversarial training</li>
<li>YOPO adversarial training</li>
<li>Rob-GAN:</li>
</ul></li>
<li>Defensive Distillation</li>
<li>Randomization-Based Defense:</li>
<li>Adversarial Example Detection:</li>
<li>Ensemble Learning:</li>
</ul></li>
<li><p>挑战总结：</p>
<ul>
<li><strong>Evolution</strong> of Attackers
<ul>
<li>现在有效的防御会被不断进步的攻击所攻破</li>
</ul></li>
<li>Provability and Interpretability
<ul>
<li>建议提出可解释、可证明的ML(DL)模型</li>
</ul></li>
</ul></li>
<li><p><strong>FUTURE</strong> WORK DIRECTIONS</p>
<ul>
<li>Attacker:
<ul>
<li>Generating Usable Adversarial Examples:
保留恶意软件原始功能是至关重要的</li>
<li>Better Inverse-Mapping Manipulations:</li>
<li>Aiming at Stronger Classifiers:
如果有更强的分类器，那么评估攻击就会更加有效果</li>
</ul></li>
<li>Defender
<ul>
<li>Robustness and Accuracy</li>
<li>Large-Scale Malware Classification Datasets</li>
<li>Adapting to Real-World Settings:</li>
<li>Virtual Analysis Environments:</li>
<li>Immunology-Inspired Defense Framework</li>
<li>Interpretable Models and Provable Robustness:</li>
</ul></li>
</ul></li>
</ul>
<h4 id="总结-25">总结</h4>
<ul>
<li><p>发现<a
target="_blank" rel="noopener" href="https://dblp.uni-trier.de/">dblp</a>这个数据库挺好用的（感觉几乎都是计算机领域的文章）</p>
<ul>
<li>其次有个浏览器插件挺好用，能在文章后面显示CCF 的等级</li>
<li>总的来说，感觉自己<strong>搜索能力和搜索效率</strong>提高了不少，更能找到自己需要的东西</li>
</ul></li>
<li><p>因为不知道从哪里继续，于是找了两篇顶刊上的综述，希望能得到<strong>启发</strong>，同时梳理一下我的<strong>脉络</strong></p>
<ul>
<li>其实之前也看了点综述论文，但是没有看顶刊上的</li>
</ul></li>
<li><p>这两篇论文都是属于综述类型</p>
<ul>
<li>第一篇是详细讲解了<strong>ML在恶意代码检测与分类上的应用</strong></li>
<li>第二篇是介绍<strong>基于恶意代码分类器的对抗样本的防御和攻击</strong></li>
</ul></li>
<li><p>收获：</p>
<ul>
<li><p>首先是对<strong>恶意代码与对抗样本知识</strong>的积累与巩固</p></li>
<li><p>其次是让我对我的研究方向有更<strong>清晰的认识</strong>，基于上述两篇文章，我用了自己的方式描述出了<strong>我的所学和理解</strong>。</p>
<ul>
<li><p>画了一个图展示了我现在对课题的理解<img
src="https://s2.loli.net/2023/03/11/DdovuJ7WVq4scAz.png"
alt="Malware&amp;Adversary" /></p></li>
<li><p>对<strong>全局的分析</strong>：</p>
<ul>
<li>首先是研究内容由两部分组成：恶意代码分类器+对抗样本的生成
<ul>
<li>恶意代码分类器：
<ul>
<li>不同平台上的恶意代码（windows,安卓.etc），选择其一</li>
<li>对输入的样本进行特征提取：有三种方式，每种方式能够提取不同的特征，三者选一即可，混合方式目前研究的少。（选择依据）</li>
<li>深度学习还是传统的机器学习模型：传统的机器学习模存在一些缺陷
<ul>
<li>深度学习算法（选择依据）</li>
</ul></li>
</ul></li>
<li>对抗样本的生成是需要基于前一步构造的恶意代码分类器的，就比如特征是静态？动态？混合？这一步就会影响攻击算法的选择
<ul>
<li>白盒攻击还是黑盒攻击：取决于对分类模型已知多少信息
<ul>
<li>攻击算法（选择依据）</li>
<li>攻击方法：
<ul>
<li>只是使得对抗样本错误分类</li>
<li>指定类别错误分类</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li>这整个过程还存在很多的<strong>细节</strong>：
<ul>
<li>数据样本的选择应该尽可能覆盖的范围大</li>
<li>对数据的处理方式</li>
<li>恶意代码中的混淆技术会使得我们对它的特征分析更加困难</li>
<li>特征很多，需要选择关键的特征</li>
<li><strong>创新与挑战</strong>（是否可以作为我们寻求的创新点）
<ul>
<li>数据处理</li>
<li>恶意代码分类器
<ul>
<li>概念漂移：恶意代码日新月异，模型也需要重新训练</li>
<li>数据偏差问题</li>
<li>混淆技术和恶意代码排斥虚拟的分析环境问题</li>
</ul></li>
<li>攻击挑战
<ul>
<li>查询效率</li>
<li>更强大的分类器</li>
<li>增加的扰动不能更改恶意软件本身的结构和功能</li>
</ul></li>
<li>防御挑战
<ul>
<li>增强鲁棒性</li>
<li>训练可解释、可证明的模</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>问题：</p>
<ul>
<li>对防御这方面，我暂时还了解的比较少</li>
<li>对于训练模型算法的选择，还需要我先把机器学习（ML） 、深度学习（DL
）学完才能更深入的接触</li>
<li>另一方面，恶意代码的分析也是个复杂的过程</li>
</ul></li>
<li><p>下一个<strong>目标</strong>：</p>
<ul>
<li>对应作者提出的<strong>问题与挑战</strong>，查阅相关资料</li>
<li>学习整个研究内容中的其他细节</li>
<li>除去细节，现在对这个研究内容的整个过程还是比较熟悉。需要<strong>每个环节</strong>多加思考，提出一些奇思妙想与假设、猜测并验证。（ok，其实我现在就已经有一些想法了）</li>
</ul></li>
<li><p>对于各个环节，我现在的一些想法（由于目前知识储备不够，有些可能就是异想天开）：</p>
<ul>
<li>对于对抗样本的攻击防御：还可以这样做，针对现有的防御方法，我们想办法攻破它；针对现有的攻击方法，采取合适的方式进行防御。</li>
<li>能否构造一个分类器:适用于检测Windows平台和Android平台上的恶意代码
<ul>
<li>或者创造一种对抗样本的生成方式适用于多个平台上的恶意代码</li>
</ul></li>
<li>恶意代码的特征多样，能否发现一种新的特征，使得检测的准确性和鲁棒性更高
<ul>
<li>或者说，对于恶意代码在虚拟环境中隐藏自己恶意行为的现象，找到一种新的分析环境解决这个问题</li>
</ul></li>
<li>关于模型算法上的问题还需要我进一步掌握相关的知识</li>
<li>我感觉，只要熟悉了整个流程，并且有了一定的知识储备，就能提出很多问题。</li>
</ul></li>
</ul>
<h3 id="section-37">2023-03-03</h3>
<h4 id="machine-learning-学习">Machine learning 学习</h4>
<ul>
<li><a
href="https://jf710001011.github.io/2023/03/04/ml07/">学习记录</a></li>
</ul>
<h4 id="总结-26">总结</h4>
<ul>
<li><p>问题：</p>
<ul>
<li>最近感觉有<strong>懈怠</strong>，花的时间不多；但是都是一样的感觉，当一件事没碰它的时候，总是不想干，但是一旦着手去做，就会沉浸其中，毕竟是自己选择的喜欢做的事。
<ul>
<li>下午与老师探讨一番，关于科研中该如何去看论文的问题：<strong>枝干与叶子</strong>，确定叶子，再反溯回枝干。</li>
</ul></li>
</ul></li>
<li><p>基于上述问题，因此需要<strong>重新规划一番</strong>，画出<strong>一些时间点</strong>，督促自身。</p>
<ul>
<li><p>首先论文看的点还是不够细致到一个具体问题，继续多看论文。</p></li>
<li><p>机器学习还是得继续，找准跟我研究内容相关的部分</p></li>
<li><p>时间点：</p>
<ul>
<li><p>04-01前找到那个点，确定自己需要<strong>解决的问题</strong>。</p></li>
<li><p>06-01前：将<strong>机器学习</strong>学完（就跟着视频全部学完，感觉也不多吧），如下这三部分，大概150个短视频，同时积累<strong>恶意代码</strong>知识。<img
src="https://s2.loli.net/2023/03/04/8ZOLdhBt5IsR9me.png"
alt="image-20230304025037998" /></p></li>
<li><p>07-01前：寻找到<strong>问题的解决方案</strong>。</p></li>
</ul></li>
</ul></li>
<li><p>感觉自己还是很想能发出一篇不错的论文：</p>
<ul>
<li>一方面认为这是证明自己在研究生阶段<strong>有所学、有所获</strong>的一个证明。</li>
</ul></li>
<li><p>另一方面自己确实想在人工智能、安全的前沿领域有更多的了解，应该会对自己<strong>以后的职业</strong>（从事web应用和软件的恶意代码）有更多影响。</p></li>
</ul>
<h3 id="section-38">2023-02-17</h3>
<h4 id="机器学习">机器学习</h4>
<ul>
<li><a
href="https://jf710001011.github.io/2023/02/18/ml06/">多元线性回归的梯度下降</a></li>
</ul>
<h4 id="论文学习-1">论文学习</h4>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0167404822001572#bib0028">Adversarial
malware sample generation method based on the prototype of deep learning
detector</a>（4）,相关记录：2022-12-30，2022-12-09，2022-10-28</p></li>
<li><p>认为自己有了一定的<strong>沉淀</strong>，回去重温，应该会有收获，并将<strong>重要的点做下记录</strong></p></li>
<li><p>本文一个<strong>重要的发现或者思想</strong>：当我们最大化输出层中一个单元的激活值时，我们可以在模型的输入空间中得到一个原型样本。这<strong>启发</strong>了作者基于原型样本去生成对抗样本。</p>
<ul>
<li>首先<strong>理解原型概念</strong>很重要：The prototype is a typical
example of the selected out- put class</li>
<li>out-put class?，暂时不懂这个词</li>
</ul></li>
<li><p>对抗样本<strong>第一次被提出</strong>的时间</p></li>
<li><p>对抗样本的产生方法：FGSM,I-FGSM,C&amp;W。这些需要深入了解</p></li>
<li><p>深度学习的事后可解释性？</p></li>
<li><p>引入了<strong>中间样本</strong>的概念</p></li>
<li><p><code>Activation maximization</code>这个方法似乎很重要</p></li>
<li><p>阅读到了第3部分，模型设计与对抗样本的生成</p>
<ul>
<li><p>对于这两个问题，作者的考虑如下</p>
<ul>
<li>对抗样本应该达到什么样的效果</li>
<li>敌手即模型本身需满足什么条件，比如需要具备什功能、又需要给予什么限制</li>
<li>很重要的一点是：对于生成对抗样本的方法，作者联系了对于图像生成对抗样本，了解了差异之后，随机即在前人基础上做出改进以实现自己的实验目的</li>
</ul>
<hr /></li>
<li><p>本文对抗样本是基于windows
系统下的恶意软件，因此对于二进制文件的操作需要很了解。因此说基于的背景也是关键的一环。</p></li>
</ul></li>
</ul>
<h4 id="总结-27">总结</h4>
<ul>
<li>本周仍然是学习了机器学习，主要学习了特征缩放和特征工程，以及新的模型：逻辑回归</li>
<li>在阅读论文上，经过一些沉淀，对论文的理解是更深刻，所以逐渐的会去想摸清作者的思路，去做这些步骤的原因</li>
<li>但是还是基于专业知识不够，无法对文中的内容提出问题或者自己的见解。</li>
</ul>
<h3 id="section-39">2023-02-10</h3>
<h4 id="机器学习-1">机器学习</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://liuhaihuaaacc.gitee.io/2023/02/11/ml04/">几个实验记录</a></li>
<li><a
target="_blank" rel="noopener" href="https://liuhaihuaaacc.gitee.io/2023/02/11/ml05/">理论学习记录</a></li>
</ul>
<h4 id="web恶意代码学习">web恶意代码学习</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://liuhaihuaaacc.gitee.io/2023/02/09/the-pentester-blueprint/">学习记录</a></li>
</ul>
<h4 id="总结-28">总结</h4>
<ul>
<li>问题：因为本周还想再完成一些内容，因此迟发了一点汇报</li>
<li>收获：
<ul>
<li>本周主要是在之前Maching Learning学习的基础上进行了实验</li>
<li>首先是 对jupyter
notebook环境使用不熟，在执行代码的时候出现很多报错，折腾了挺多时间</li>
<li>整个过程主要是在 <strong>jupyter notebook</strong>环境下学习
<strong>使用python</strong>实现几个需求
<ul>
<li>使用多个数学py库进行数学计算与绘制坐标图、等高线图和3D图</li>
</ul></li>
<li>在这个过程中，
<ul>
<li>进一步深入学习了使用代价函数寻找参数拟合直线之间的关系</li>
<li>代价函数与与学习速率 之间的关系</li>
<li>代价函数在最初的下降与最后逼近最小值时的下降步伐</li>
</ul></li>
</ul></li>
</ul>
<h3 id="section-40">2023-02-03</h3>
<h4 id="maching-learning的学习">maching learning的学习</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://liuhaihuaaacc.gitee.io/2022/12/03/ml03/">笔记记录</a></li>
</ul>
<h4 id="web安全的学习">web安全的学习</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://liuhaihuaaacc.gitee.io/2022/12/20/web-dvwa/">笔记记录</a></li>
</ul>
<h4 id="总结-29">总结</h4>
<ul>
<li><p>收获：</p>
<ul>
<li>本周主要学习了机器学习相关的知识：教程讲的很详细，因此学习起来还是比较顺畅。</li>
<li>学习的内容主要如下</li>
</ul>
<figure>
<img src="https://s2.loli.net/2023/02/03/KC4xS1hIiDwLlt3.png"
alt="image-20230203192902076" />
<figcaption aria-hidden="true">image-20230203192902076</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2023/02/03/klj2abI8hsL9P1T.png"
alt="image-20230203192945805" />
<figcaption aria-hidden="true">image-20230203192945805</figcaption>
</figure>
<ul>
<li>之前通过看论文零散学习的时候，对这些概念都有一定了解，但是此番系统学习，则让我理解的<strong>更加深刻</strong>，且更多地知道了<strong>推导过程。</strong></li>
</ul></li>
<li><p>下一个目标：</p>
<ul>
<li>在之前部署的jupter notebook 中使用python
简单<strong>实现本周所学习的梯度下降算法</strong></li>
<li>并继续后续的maching
learning学习，<strong>开始学习多特征的模型</strong></li>
</ul></li>
</ul>
<h3 id="section-41">2023-01-19</h3>
<p><a
target="_blank" rel="noopener" href="https://www.researchgate.net/publication/269935591_Explaining_and_Harnessing_Adversarial_Examples">Explaining
and Harnessing Adversarial
Examples</a>（3）；相关记录：2023-01-13，2023-01-06</p>
<ul>
<li><p>存留的问题</p>
<ul>
<li>如何理解模型平均化不足和正则化不足</li>
<li>如何理解正则化收益</li>
</ul></li>
<li><p>一些知识点&amp;结论</p>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/horacle/p/13171057.html">梯度</a></p>
<ul>
<li>深度学习模型可以学习一些函数来抵抗对抗性攻击，而浅层模型则没有这种功能。
<ul>
<li>针对在训练集上对抗样本没有达到0错误率，作者提出了两种方法去改进实验去下降对对抗样本分类的错误率。</li>
</ul></li>
<li>针对对抗训练这一点。作者的实验结果表明
<ul>
<li>用原来的模型生成的对抗样本作用在原来的模型上，错误率是89.4%，但是作用在使用对抗样本训练的模型上，错误率是17.9%。用对抗样本训练的模型去生成对抗样本，作用在原来的模型上，错误率是40.9%，作用在用对抗样本训练的模型上，错误率是19.6</li>
</ul></li>
<li>梯度：对各个自变量求偏导，得到的结果写成向量形式即为梯度。
<ul>
<li>所有下降方向中，梯度下降最多</li>
<li>使用梯度寻找最优参数</li>
</ul></li>
<li>文中提出的：针对FGSM——快速生成对抗样本的方法，作者认为：生成对抗样本更应该关注的是扰动的方向而不是扰动的数目</li>
<li>实验证明使用FGSM算法确实可以加快对抗样本的生成</li>
</ul>
<figure>
<img src="https://s2.loli.net/2023/01/19/2IUpWdmPcQwC7zS.png"
alt="image-20230119194933202" />
<figcaption aria-hidden="true">image-20230119194933202</figcaption>
</figure>
<ul>
<li><strong>损失函数</strong>用来评价模型的<strong>预测值</strong>和<strong>真实值</strong>不一样的程度，损失函数越好，通常模型的性能越好。不同的模型用的损失函数一般也不一样。</li>
<li><strong>5 ADVERSARIAL TRAINING OF LINEAR MODELS VERSUS
WEIGHT</strong> 这一节有点难读懂：涉及正则化知识</li>
<li>实验论证了RBF网络对对抗样本的抵抗性:实验过程还是使用快速梯度下降方法生成对抗样本，RBF网络是很难被对抗样本愚弄的</li>
<li>最后一个实验针对
对抗样本能在不同架构的训练模型之间泛化，依旧是基于作者开头提到的线性观点下进行实验。
<ul>
<li>实验结果发现，线性模型产生的对抗样本在其他线性模型中的预测成功率大于非线性模型产生的对抗样本。</li>
<li>因此，线性因素在对抗样本的泛化中占主要因素</li>
</ul></li>
</ul>
<h4 id="总结-30">总结</h4>
<ul>
<li>本周，在学习深度学习知识的基础上，分析了实验与相应实验结论的对应。
<ul>
<li>论证过程是与结论一一对应的，但是当出现一些问题时，作者采用的改进方法的原因不清楚。</li>
<li>之前一直尝试在阅读论文中学习积累知识，但是这样学习太零碎了，没法成体系。至今为止，专业知识、数学知识还是摆在面前最大的问题。</li>
<li>接下来的学习还是集中以上两块，论文阅读进度会减慢。</li>
<li><a
target="_blank" rel="noopener" href="https://blog.csdn.net/WangHY_XCJ/article/details/109401368">论文笔记</a>，看了一篇这种论文笔记，我能达到这种水平就是很大进步了。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="section-42">2023-01-13</h3>
<h4 id="论文学习-2">论文学习</h4>
<p><a
target="_blank" rel="noopener" href="https://www.researchgate.net/publication/269935591_Explaining_and_Harnessing_Adversarial_Examples">Explaining
and Harnessing Adversarial Examples</a>（2）；相关记录：2023-01-06</p>
<ul>
<li><h6 id="概念知识积累"><strong>概念知识积累</strong></h6>
<ul>
<li><p>MNIST 数据集：</p>
<ul>
<li><p>是一个手写体数字的图片数据集，该数据集来由美国国家标准与技术研究所（National
Institute of Standards and Technology
(NIST)）发起整理，一共统计了来自250个不同的人手写数字图片，其中50%是高中生，50%来自人口普查局的工作人员。该数据集的收集目的是希望通过算法，实现对手写数字的识别。</p></li>
<li><h6 id="mnist数据集简介"><a
target="_blank" rel="noopener" href="https://blog.csdn.net/tony_vip/article/details/118735261">Mnist数据集简介</a></h6></li>
<li><p>maxout 激活函数</p>
<ul>
<li><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/176988745">Maxout激活函数以及特点？</a></li>
<li>在深度学习网络中加入一层激活函数层,包含一个参数k.这一层相比ReLU,sigmoid等,其特殊之处在于增加了k个神经元,然后输出激活值最大的值。</li>
<li><strong>优点</strong>：Maxout的拟合能力非常强，可以拟合任意的凸函数。Maxout具有ReLU的所有优点，线性、不饱和性。同时没有ReLU的一些缺点。如：神经元的死亡。</li>
<li><strong>缺点</strong>：从上面的激活函数公式中可以看出，每个神经元中有两组(w,b)参数，那么参数量就增加了一倍，这就导致了整体参数的数量激增。</li>
</ul></li>
<li><p>训练集分类误差1%，验证集分类误差11%：高方差问题，即存在过拟合；</p>
<ul>
<li>训练集分类误差15%，验证集分类误差16%：高偏差问题，即存在欠拟合；</li>
<li>训练集分类误差15%，验证集分类误差30%：高方差、高偏差问题；</li>
<li>训练集分类误差0.5%，验证集分类误差1%：低方差、低偏差问题；</li>
</ul></li>
</ul></li>
<li><p>DROPOUT</p>
<p><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38200980">深度学习中Dropout原理解析</a></p>
<ul>
<li><p>在机器学习的模型中，如果模型的参数太多，而训练样本又太少，训练出来的模型很容易产生过拟合的现象</p>
<ul>
<li>如果模型过拟合，那么得到的模型几乎不能用。为了解决过拟合问题，一般会采用模型集成的方法，即训练多个模型进行组合。但是费时。</li>
<li>Dropout（解决过拟合）说的简单一点就是：我们在前向传播的时候，让某个神经元的激活值以一定的概率p停止工作，这样可以使模型泛化性更强，因为它不会太依赖某些局部的特征。</li>
</ul>
<figure>
<img src="https://s2.loli.net/2023/01/13/73N2V1Im46GipSa.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li></li>
</ul></li>
</ul></li>
<li><p>优化问题： <a target="_blank" rel="noopener" href="https://hujichn.github.io/">[Ji Hu's
Blog]</a></p>
<ul>
<li>约化(Reducibility)：一个问题A可以约化为问题B的含义是，可以用问题B的解法解决问题A。</li>
<li>e.g.:例如求解一元一次方程这个问题可以约化为求解一元二次方程，即可以令对应项系数不变，二次项的系数为0，将A的问题的输入参数带入到B问题的求解程序去求解。</li>
<li>约化还具有传递性，A可以化约为B，B可以约化为C，那么A也可以约化为C</li>
<li><strong>P Problem</strong>:
对于任意的输入规模n，问题都可以在n的多项式时间内得到解决(这个知识第二次接触了，在有例子的情况下很容易理解)
<ul>
<li><strong>NP(Non-deterministic Polynomial) Problem</strong>:
可以在多项式的时间里验证一个解的问题:比如n个数中间找到最大值，或者n个数排序之类的。</li>
<li><strong>NPC(Non-deterministic Polynomial Complete) Problem</strong>:
满足两个条件 (1)是一个NP问题
(2)所有的NP问题都可以约化到它:例如求问图中起点到终点是否有一条小于100个单位长度的路线，随便选一条，如果算出来路径小于100，那么就猜到了一个解，也就是说如果你运气足够好的话就可以在多项式时间内解决这个问题。当然猜的前提是问题存在解。</li>
<li><strong>NP-Hard Problem</strong>:
满足NPC问题的第二条，但不一定要满足第一条</li>
</ul></li>
</ul></li>
<li><p>softmax回归是logistic回归的一般形式，logistic 回归用于二分类，而
softmax 回归用于多分类</p></li>
<li><p>L-BFGS: 优化算法</p></li>
<li><p>RBF网络：与生俱来能抵抗对抗样本</p></li>
</ul></li>
<li><p>论文观点</p>
<ul>
<li>作者基于对抗样本对模型的影响是由于模型线性，发现了一种对抗样本更为快速的生成方式</li>
</ul></li>
</ul>
<h4 id="总结-31">总结</h4>
<ul>
<li>本周继续阅读上周的论文，主要的任务仍然是对文中所涉及的概念、算法进行学习。这些已经积累的差不多了。</li>
<li>下周目标：要想清楚知道作者是如何论证他所提出的观点的、以及作者为何要做那些实验操作。还必须学习相关的概率统计知识。
<ul>
<li>因此下周就以此为目标：思考作者
<ul>
<li>如何提出这些观点，并基于这些假设，如何一步步得出他的研究成果。</li>
</ul></li>
</ul></li>
<li>这篇论文的价值意义之一：突破机器学习的相关障碍，以便在以后论文阅读中能够把更多精力花在作者思路上。</li>
</ul>
<h3 id="section-43">2023-01-06</h3>
<ul>
<li>置信度
<ul>
<li><strong>e.g</strong>.,如果在一次大选中某人的支持率为55%，而<strong>置信水平0.95上的置信区间</strong>是（50%,60%），那么他的<strong>真实支持率</strong>有百分之九十五的机率落在百分之五十和百分之六十之间，因此他的真实支持率不足一半的可能性小于百分之2.5（假设分布是对称的）。</li>
</ul></li>
</ul>
<h4 id="论文学习-3">论文学习</h4>
<p><a
target="_blank" rel="noopener" href="https://www.researchgate.net/publication/269935591_Explaining_and_Harnessing_Adversarial_Examples">Explaining
and Harnessing Adversarial Examples</a>（ICLR
2015）：上期论文引用的文章</p>
<ul>
<li><p>摘要</p>
<ul>
<li>前人认为模型受到对抗样本的影响是由非线性和过拟合造成的</li>
<li>作者认为：是跟<strong>线性</strong>关系很大。并且基于此，提出了一种更快生成对抗样本的方法。
<ul>
<li>高维空间中的线性行为就能够引起对抗样本</li>
</ul></li>
</ul></li>
<li><p>结论：</p>
<ul>
<li><p>对抗样本能够在不同模型<strong>泛化</strong>，是因为对抗样本的扰动与模型的权重向量高度对齐的结果。（暂时不理解</p></li>
<li><p><code>The direction of perturbation, rather than the speciﬁc point in space, matters most. Space is not full of pockets of adversarial examples that ﬁnely tile the reals like the rational numbers</code>（如何理解</p></li>
<li><p>对抗性训练可以导致<strong>正则化</strong></p></li>
<li><p><strong>易于优化</strong>的模型容易受到干扰</p></li>
<li><p><strong>线性模型</strong>缺乏抵抗对抗扰动的能力</p></li>
<li><p><strong>RBF网络</strong>对对抗样本有抗干扰能力</p></li>
</ul></li>
<li><p><strong>知识积累</strong></p>
<ul>
<li><code>Early attempts at explaining this phenomenon focused on nonlinearity and overfitting.</code></li>
<li>正则化：防止算法过度拟合</li>
<li>线性：易于训练模型</li>
<li>非线性：抵抗对抗样本</li>
<li>对抗样本与原始样本非常接近：人眼无法感知区分</li>
<li><strong>关键词</strong>：线性</li>
<li>单个输入特征的精度是有限的：</li>
<li>权重：每种机器学习算法都基于一个假设：数据分布的变化都是有规律的。机器学习模型要做的就是要<strong>逼近这种规律</strong>。而调整权重实现的就是逼近的效果。</li>
<li>逻辑回归：解决二分类问题。基于线性回归，<code>sigmod函数</code></li>
<li><code>softmax 函数</code>：对分类结果赋予概率，而不是非黑即白</li>
<li>欠拟合：模型在训练集上就误差过大</li>
<li>过拟合：模型在训练集上表现良好，但是在测试集上与在训练上差距过大。</li>
<li>RBF网络：RBF作为激活函数的神经网络</li>
</ul></li>
</ul>
<h4 id="总结-32">总结</h4>
<ul>
<li>这篇论文是上周学习论文的一篇背景论文，与之前论文一样都探讨了改进生成对抗样本的方法，但是这篇论文与之前的论文有很大<strong>不同</strong>。
<ul>
<li>本文深入神经网络模型结构，挖掘的是什么因素导致对抗样本对模型产生影响的。</li>
<li>对抗样本在不同模型能够泛化的原因</li>
<li>挖掘的是更加本质的问题</li>
<li>而<strong>之前阅读</strong>的论文重点：
<ul>
<li>在不同分类领域，生成对抗样本的方法。</li>
<li>如何抵抗对抗样本</li>
</ul></li>
<li><strong>基于上述原因</strong>
<ul>
<li>文中有非常多机器学习、概率统计和矩阵论的术语。阅读起来很困难，已经很久没有阅读一篇论文这么吃力了。</li>
<li>因此本周在尝试精读本文到一半时已经读不下去了。转而先去学习阅读过程中提到的所有专业术语、算法、技术。所以对作者如何得出结论的并不了解。</li>
</ul></li>
</ul></li>
<li>下一个目标：
<ul>
<li>继续阅读本文，感觉熟悉这篇论文之后收获会很大。</li>
</ul></li>
</ul>
<h3 id="section-44">2022-12-30</h3>
<p><strong>相关记录</strong> ：2022-12-09、2022-10-28</p>
<p><a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0167404822001572#bib0028">Adversarial
malware sample generation method based on the prototype of deep learning
detector</a>（3）</p>
<h4 id="如何看懂一篇学术论文">如何看懂一篇学术论文</h4>
<ul>
<li><p><strong>为什么</strong>要进行这项研究，这项研究在解决什么问题</p></li>
<li><p>在解决这个问题<strong>之前</strong>，这一领域做过什么努力？之前的工作有什么<strong>局限</strong>？在作者看来，<strong>下一步</strong>需要做什么？</p></li>
<li><p>在研究中作者想回答什么问题</p></li>
<li><p>解决手段：作者要<strong>怎么做</strong></p></li>
<li><p>为每个实验画出一个图表，画出作者到底做了什么。里面包含你全面<strong>理解研究工作</strong>所需要的所有细节</p></li>
<li><p>写下一段或几段话，<strong>总结</strong>每个实验、每幅图解和每张表格的结果</p></li>
<li><p>你认为这些结果<strong>说明了什么问题</strong>？</p></li>
<li><p>作者认为结果意味着什么？你<strong>同意作者的看法吗</strong>？你能不能想出<strong>其他的方式</strong>解读结果？作者有没有意识到他们的研究存在任何<strong>弱点</strong>？你有没有发现任何作者<strong>遗漏的问题</strong>？他们建议<strong>下一步</strong>怎么做？你同意吗？</p></li>
</ul>
<blockquote>
<p><strong>尝试以上述方式去阅读论文</strong></p>
</blockquote>
<h4 id="论文学习-4">论文学习</h4>
<p><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/585456510">对抗鲁棒性学习资料汇总</a></p>
<ul>
<li><p><strong>摘要</strong>：</p>
<ul>
<li><p>针对 windows pe 文件，对抗样本的生成不能破坏它的结构和功能</p>
<ul>
<li><p>松弛空间内插入扰动</p></li>
<li><p>对抗样本问题在图像分类领域有很多的研究，但是跟本文针对的PE文件，有多不同，这些差异会造成对抗样本的<strong>效率和对模型的愚弄率</strong></p>
<ul>
<li><p>因此针对两者差异，本文<strong>解决了这些问题</strong>去生成质量高的对抗样本</p></li>
<li><p>方式：将原型样本（具有代表性的正常样本）中的字节添加到恶意软件中去产生对抗样本</p></li>
</ul></li>
</ul></li>
</ul></li>
<li><p><strong>前置知识</strong>：</p>
<ul>
<li>cyberattacks</li>
<li>深度学习检测模型避免了特征工程的加入</li>
<li>windows 平台的恶意软件占比大</li>
<li>windows pe 并不需要考虑增加扰动的程度</li>
<li>本文基于<strong>白盒模型</strong>（知道模型需要的参数和模型的结构）</li>
</ul></li>
<li><p><strong>背景</strong></p>
<ul>
<li><p>生成对抗样本的两种方式</p>
<ul>
<li>将二进制文件转化为图像</li>
<li>将二进制文件的字节作为向量嵌入样本</li>
</ul></li>
<li><p><strong>问题：</strong> 对windows pe
文件的操控是非常困难的</p></li>
<li><p>可以通过对原型样本的分析，去修改输入样本以达到我们期待的输出结果</p></li>
<li><p><code>since the target of the attack is a binary model classifying the input files as benign or malicious, we assume that the output layer of the model is a sigmoid unit, which is equivalent to a Softmax unit with two outputs.</code></p></li>
<li><p><code>But in our method, as an intermediate sample, the prototype does not need to be subject to any restrictions, but only to maximize the output of the activation of the model’s output layer</code></p></li>
<li><p>生成对抗样本的优化问题：可以使用梯度算法解决</p>
<ul>
<li>数学知识众多：<a
target="_blank" rel="noopener" href="https://www.zhihu.com/question/264189719">如何理解梯度下降</a></li>
</ul></li>
</ul></li>
<li><p><strong>实验</strong>：</p>
<ul>
<li>数据集：
<ul>
<li>一部分用于训练模型</li>
<li>另一部分用于产生对抗样本</li>
</ul></li>
<li>模型
<ul>
<li>基于 MalConv</li>
<li>改进：
<ul>
<li>将训练样本的大小缩写，改进训练效率</li>
</ul></li>
</ul></li>
<li>结果：与前人的工作相比
<ul>
<li>愚弄率最高</li>
<li>生成对抗样本的时间比两种更少；相比之下生成时间更多的情况下，愚弄率却更高</li>
<li>虽然本文提出的模型是针对与白盒模型，但是实验证明在一定程度上对黑盒模型同样有效。</li>
<li>参考原型去产生对抗样本可以保留文件更多有效的信息</li>
<li>迭代机制提高效率</li>
</ul></li>
<li>作者的下一步工作
<ul>
<li>继续探索细粒度的修改策略产生对抗样本</li>
<li>探索本文提出的方法对其他检测模型的影响</li>
<li>探索基于白盒的模型对于黑盒模型的影响（转移性）</li>
</ul></li>
</ul></li>
</ul>
<h4 id="web-恶意代码学习记录">web 恶意代码学习记录</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://liuhaihuaaacc.gitee.io/2022/12/17/web-wen-jian-shang-chuan-lou-dong-yuan-li/">文件上传漏洞原理</a></li>
<li><a
target="_blank" rel="noopener" href="https://liuhaihuaaacc.gitee.io/2022/12/20/web-upload-labs/">文件上传漏洞实验</a></li>
</ul>
<h4 id="总结-33">总结</h4>
<ul>
<li><strong>收获</strong>
<ul>
<li>这篇文章读过多次，这次是最深入学习的一次。带着上述提到的文献阅读策略有一定效果。会感觉到理解的<strong>更加透彻</strong>。</li>
<li>对于科研，首先要对<strong>前人的相关研究</strong>有足够学习，基于前人的研究去改进方法、去解决前人留下的问题和不足。同时利用前人的研究成果也会使自己的研究成果更具有说服性。</li>
<li>现在对于对抗样本的<strong>知识积累</strong>是不少的，阅读相关的文献、文章，都更加轻松</li>
</ul></li>
<li><strong>问题</strong>
<ul>
<li>我不知道我具体该去研究哪些点，所以以<strong>通篇精读</strong>的策略去学习文献。</li>
<li>不理解文中的<strong>事后可解释性</strong></li>
<li>对于前人的工作研究学习不够（需要更多的像现在这样全篇细读）</li>
<li>积累的<strong>算法</strong>不够、算法对于解决和优化问题至关重要</li>
<li>如果让我<strong>复现这个实验</strong>，我感觉很困难，这个实验过程我理解的不到位。</li>
</ul></li>
<li><strong>下一个目标</strong>
<ul>
<li>阅读以下论文
<ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1412.6572">Explaining and Harnessing
Adversarial Examples</a></li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1606.04435">Adversarial Perturbations
Against Deep Neural Networks for Malware Classification</a></li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1702.05983">Generating Adversarial
Malware Examples for Black-Box Attacks Based on GAN</a></li>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3134600.3134642">Malware
Detection in Adversarial Settings: Exploiting Feature Evolutions and
Confusions in Android Apps</a></li>
</ul></li>
</ul></li>
</ul>
<h3 id="section-45">2022-12-09</h3>
<h4 id="论文再学习">论文再学习</h4>
<p>​ <a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0167404822001572#bib0028">Adversarial
malware sample generation method based on the prototype of deep learning
detector</a>（2）</p>
<ul>
<li><p>对抗样本问题是一种<strong>约束优化问题</strong></p></li>
<li><p>生成对抗样本的<strong>方式</strong>（本文重要的一部分）：在二进制文件的特定位置嵌入一些字节</p>
<ul>
<li>在节与节之间</li>
<li>文件末尾的字节</li>
<li>新增加部分的字节</li>
</ul></li>
<li><p>机器学习中的<strong>可解释性问题</strong>（在多篇文献中看到，这也是AI中讨论研究的一个热点）</p>
<ul>
<li>我们无法掌握模型作出预测的依据，也不知道它什么时候会出现错误。因此解决模型的可解释性问题很关键。</li>
<li>对于特定的数据和某种特定的任务，特定经验的人群拥有对于特定模型最大程度上的理解</li>
</ul>
<hr />
<ul>
<li>训练前:数据分析吗，尽可能地了解数据</li>
<li>训练过程中：打造一个可解释的模型。<strong>决策树</strong>是可解释的。
<ul>
<li>决策树：一种分类方法
<ul>
<li>基于节点的属性值去分类</li>
</ul></li>
</ul></li>
<li>训练后的可解释性
<ul>
<li>敏感性分析：删除某个数据，看对模型的影响程度</li>
<li>基于梯度的方法：看输入的哪一部分属性值对模型影响最大</li>
</ul></li>
<li>可解释性问题解决的是人类对模型的信任问题</li>
</ul>
<hr /></li>
<li><p><strong>激活最大化（AM）:</strong>在神经网络中，每个神经元会提取特定的特征，这样就能使特定的神经元得到输入偏好。我们需要为这些神经元找到这些特定的输入。而AM可以将这一过程可视化。</p></li>
<li><p>梯度下降算法：函数极值问题</p>
<ul>
<li>追求目标函数的导数寻求函数最小化</li>
<li>寻找使得目标函数最小化时自变量的值</li>
</ul></li>
<li><p>关于<strong>实验过程</strong></p>
<ul>
<li>实验数据的获得，实验数据的代表性</li>
<li>在多种情况下进行实验，并与前人的实验研究进行对比，以谋求改进</li>
</ul></li>
</ul>
<h4 id="总结-34">总结</h4>
<ul>
<li><strong>收获</strong>：
<ul>
<li>学习了如何对windows PE文件生成对抗样本</li>
<li>衡量生成对抗样本的评估标准：恶意软件在检测模型中的逃避率</li>
<li>AI模型中的可解释性问题及其他AI知识</li>
<li>我们需要学习积累多种算法，改进并应用到自己的科研实验中</li>
</ul></li>
<li>下一个<strong>目标</strong>
<ul>
<li>目前感觉收获还是不多。，需要继续对文献的细节深入，这一过程应该需要积累。</li>
</ul></li>
</ul>
<h3 id="section-46">2022-12-02</h3>
<h4 id="博文相关学习">博文相关学习</h4>
<ul>
<li><strong>网络安全博文</strong>
<ul>
<li><a
target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/column/83592">绿盟科技研究通讯</a></li>
</ul></li>
<li>概念漂移：
<ul>
<li>随着时间推移，测试数据和训练数据不一致，导致测试数据分类错误（例如，恶意代码检测中，恶意代码出现变种的现象，此时模型不能再适用</li>
</ul></li>
<li>对抗样本：
<ul>
<li>通过对输入样本增加微小的扰动，使得学习模型输出错误的结果。</li>
</ul></li>
<li>针对上述两个概念：
<ul>
<li>区别是否有人工干扰</li>
</ul></li>
</ul>
<h4 id="系统学习machine-learning">系统学习machine learning</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://liuhaihuaaacc.gitee.io/2022/12/03/ml03/">传送门</a>（记录学习过程</li>
</ul>
<h4 id="总结-35">总结</h4>
<ul>
<li>查了挺多资料、看了一些博文，然后自身针对论文中的许多细节，首先问题在于对于机器学习技术的掌握，因此接下来的学习都会以<strong>机器学习</strong>作为重点。</li>
<li>在之前的阅读论文中，对于机器学习技术的了解，都是比较零碎的，系统学习这块知识是当务之急。</li>
<li>以及在真正的科研实验中，训练模型等实践过程都需要这门技术。</li>
<li>就像在看论文时发现没有很系统的机器学习知识基础无法继续深入研究一样，同时也需要不断深入论文的细节中去<strong>发现更多的问题</strong>，然后去学习、去解决疑惑。</li>
<li>根据之前看论文的顺序，将会对这篇论文开始细节研究： <a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0167404822001572">Adversarial
malware sample generation method based on the prototype of deep learning
detector</a></li>
</ul>
<h3 id="section-47">2022-11-25</h3>
<h4 id="论文学习-5">论文学习</h4>
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9833659">Transcending
TRANSCEND: Revisiting Malware Classification in the Presence of Concept
Drift</a>（CCF-A会议:IEEE S&amp;P）</p>
<ul>
<li><p>关键词</p>
<ul>
<li><p>malware</p></li>
<li><p>machine learning</p></li>
<li><h6
id="concept-drift恶意软件会随着防御的增强而进化演变成偏离原本的训练分布一个全新的概念且本文于此展开">Concept
Drift：恶意软件会随着防御的增强而进化演变成偏离原本的训练分布（一个全新的概念，且本文于此展开）</h6></li>
</ul></li>
<li><p>首先<strong>TRANSCEND</strong>
是解决检测恶意代码分类模型中的概念漂移问题中的一种系统</p></li>
<li><p>机器学习在分类领域、计算机视觉、自然语言处理取得良好表现的前提假设：<code>However, a great deal of this success is conditional on one central assumption: that the training and test data are drawn identically and independently from the same underlying distribution</code></p></li>
<li><p>现有的两种解决概念漂移的两种方法</p>
<ul>
<li><code>The first is to design systems which are intrinsically more *resilient* to drift by developing more robust feature spaces</code></li>
<li><code>A second solution is to *adapt* to the drift, for example by updating the model using incremental retraining or online learning [30], [50], or rejecting drifting points.</code></li>
</ul></li>
<li><p>注意这个新概念： <strong>conformal prediction
theory</strong>。</p></li>
<li><p>the state-of-the-art approaches for classification with
<strong>rejection</strong></p></li>
<li><p>Dataset shift的分类</p>
<ul>
<li><em>Covariate shift</em></li>
<li><em>label shift</em></li>
</ul></li>
<li><p><em>conformal evaluator</em></p></li>
<li><p>本文通过对TRANSDENCE</p></li>
</ul>
<h3 id="section-48">2022-11-18</h3>
<h4 id="论文学习-6">论文学习</h4>
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9484718">DL-FHMC: Deep
Learning-Based Fine-Grained Hierarchical Learning Approach for Robust
Malware Classification</a>（TDSC-2022）</p>
<ul>
<li>关键词：<strong>恶意代码、深度学习、静态分析、鲁棒性、机器学习、物联网</strong></li>
<li>对抗样本：<strong>AEs</strong></li>
<li>恶意代码分类在对抗样本上的研究与<strong>图像分类</strong>在对抗样本上的研究有许多相似之处</li>
<li>本文所做的<strong>贡献</strong>
<ul>
<li>分析DL-SSMC 在恶意代码检测和分类情况下的鲁棒性</li>
<li>提出了DL-FHMC系统进行恶意代码分类</li>
<li>研究了DL-FHMC在对抗攻击下的鲁棒性</li>
</ul></li>
<li><strong>CFG</strong>(控制流程图)在恶意代码检测中的作用</li>
<li>GEA与Sub-GEA</li>
<li><strong>数据集</strong>的采用</li>
<li>对比了多种<strong>学习算法</strong>并进行了评估
<ul>
<li>RF(随机森林)</li>
<li>DNN(深度神经网络)</li>
<li>RNN(卷积神经网络)</li>
</ul></li>
<li>DL-SSMC系统的设计与评估</li>
</ul>
<h4 id="总结-36">总结</h4>
<ul>
<li><strong>收获:</strong>
<ul>
<li>一篇好的文献研究的问题和解决的问题<strong>不止一项</strong></li>
<li>上周所看的文献研究的是<strong>安卓环境</strong>，这次的研究的是在<strong>物联网系统</strong>中，因此可以基于这一点展开研究。</li>
<li>关于CCF-A类论文的<strong>论文结构设计</strong>
<ul>
<li>首先是摘要：不用多提</li>
<li>然后是 <strong>introduction</strong>:
总体介绍研究内容与一些研究背景(或者说<strong>related
works</strong>)</li>
<li>再是具体介绍自己的成果:
<ul>
<li>实验设计</li>
<li>实验评估</li>
</ul></li>
<li>最后总结讨论不足之处</li>
</ul></li>
</ul></li>
<li><strong>问题：</strong>
<ul>
<li>本周没有完成两篇文献阅读的任务，主要是第一篇就感觉挺难的。</li>
<li>仍然无法深入文中的<strong>实验细节。</strong></li>
<li>对作者提出的一些<strong>创新性的概念和方法</strong>，有些难以理解</li>
<li>知道看论文是每周必要的且需坚持的，现在的目标就是深入挖掘对抗样本与恶意代码检测这块内容，但是感觉最近<strong>没什么进展。</strong></li>
</ul></li>
<li><strong>下一个目标：</strong>
<ul>
<li>需要找一些文献中的感兴趣的点深入研究，应该会很耗时间，不能一直停留在只能理解文章大概，需要深入细节，否则感觉没有进步。</li>
<li>感觉也需要适当看点中文的文献解乏。</li>
</ul></li>
</ul>
<h3 id="section-49">2022-11-11</h3>
<h4 id="论文学习-7">论文学习</h4>
<p><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/search/searchresult.jsp?queryText=malware%20malicious&amp;highlight=true&amp;returnFacets=ALL&amp;returnType=SEARCH&amp;matchPubs=true&amp;refinementName=Publication%20Title&amp;refinements=PublicationTitle:IEEE%20Transactions%20on%20Information%20Forensics%20and%20Security&amp;refinements=PublicationTitle:IEEE%20Transactions%20on%20Dependable%20and%20Secure%20Computing">在TIFS和TDSC上的恶意代码检测相关文章检索</a></p>
<p><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/search/searchresult.jsp?queryText=adversarial%20example&amp;highlight=true&amp;returnType=SEARCH&amp;matchPubs=true&amp;refinementName=Publication%20Title&amp;pageNumber=1&amp;refinements=PublicationTitle:IEEE%20Transactions%20on%20Information%20Forensics%20and%20Security&amp;refinements=PublicationTitle:IEEE%20Transactions%20on%20Dependable%20and%20Secure%20Computing&amp;returnFacets=ALL">在TIFS和TDSC上的对抗样本的相关文章检索</a></p>
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9477038">Backdoor
Attack on Machine Learning Based Android Malware
Detectors</a>（CCF-A:TDSC-2022，作者：斯威本科技大学博士）</p>
<p><strong>关键词</strong>：恶意代码、后门攻击、安卓、对抗样本、机器学习</p>
<ul>
<li><p>注意到恶意代码研究<strong>安卓平台</strong>的较多</p></li>
<li><p>AI安全中的<strong>数据投毒攻击</strong></p>
<ul>
<li>跟对抗样本的关系是什么</li>
<li>数据投毒攻击分类
<ul>
<li>模型偏斜：污染训练数据（应该就是对抗样本</li>
<li>反馈武器化</li>
<li>本文中所谈的后门攻击<strong>：</strong>
<ul>
<li>对于不包含触发器的输入input，后门模型表现得与干净模型一样正常</li>
<li>一旦秘密<strong>触发器Trigger</strong>（只有攻击者知道）出现在输入中，后门模型就会被错误引导去执行攻击者的子任务</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>在<strong>图像分类领域</strong>有同样的问题：但是解决的方式不能照搬照抄</p></li>
<li><p>本文所谈到的后门攻击指：使用<strong>对抗样本</strong>污染训练数据</p></li>
<li><p>本文从<strong>攻击角度</strong>讨论安卓平台的恶意代码检测问题</p></li>
<li><p>研究背景：先前攻击方式的三个缺陷，同时也是本文解决的问题。</p>
<ul>
<li>训练数据需要非常多的对抗样本</li>
<li>需要计算每个对抗样本的扰动</li>
<li>所有的代码都会被错误检测</li>
</ul></li>
<li><p>涉及的专业知识：</p>
<ul>
<li>APK程序结构</li>
<li>基于机器学习的恶意代码检测模型</li>
<li>后门中毒攻击</li>
</ul></li>
<li><p>四种典型的安卓恶意代码检测器</p>
<ul>
<li>Drebin</li>
<li>DroidCat</li>
<li>MaMaDroid</li>
<li>DroidAPIMiner</li>
</ul></li>
<li><p><code>Machine learning models are prone to carefully crafted adversarial samples</code>(文章原话)</p></li>
<li><p>最后也验证了噪声对模型是没有影响的</p></li>
<li><p><strong>label reversing method.</strong></p>
<ul>
<li>标签即为分类的结果</li>
<li>特征为进行标签的依据</li>
</ul></li>
<li><p>防御方式</p>
<ul>
<li>Adversarial Training:</li>
<li>Ensemble Learning</li>
</ul></li>
<li><p>如果该方法对良性样本不影响，而只影响恶意样本的分类，那么会使得攻击的隐蔽性更好</p></li>
</ul>
<hr />
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9762803">MsDroid:
Identifying Malicious Snippets for Android Malware
Detection</a>（TDSC-2022，作者来自浙大）</p>
<ul>
<li>问题提出：
<code>it is challenging to (1) stay robust towards real-world scenarios and (2) provide interpretable explanations for experts to analyse.</code>
<ul>
<li>注意到又提出了关于<strong>可解释性</strong>的问题</li>
</ul></li>
<li>本文的研究是首次将<strong>GNN模型</strong>应用于安卓恶意代码的静态分析上的研究，提出了一种名为MSDroid的恶意代码检测系统</li>
<li>使用了图作为代表安卓代码片段的数据机构</li>
<li>系统的框架:python 实现
<ul>
<li>Pre-processing</li>
<li>BSS-generation</li>
<li>GNN-based detection</li>
<li>Malware Explanation</li>
</ul></li>
<li>研究了恶意代码家族分类问题</li>
<li>利用app中的<strong>语义信息</strong>来提取特征</li>
<li><strong>图形表示学习技术</strong>的利用</li>
<li><strong>最后：</strong>本文所研究的是一个检测系统，提出了使用代码片段去取代整个代码来识别恶意软件、使用图表示学习技术。技术含量十足，吃力读完整篇后仍然有非常多的疑问，同时也学习到了更多先进前沿技术方法。</li>
</ul>
<h4 id="总结-37">总结</h4>
<ul>
<li><strong>收获：</strong>
<ul>
<li>在这些顶刊上的文献从开头对研究问题的引出到实验设置、实验评估和结果探讨都是感觉如此的严谨和细致。（虽然不能完全看懂，但是能够感受到如此，相比于其他一些文献）</li>
<li>基于现阶段所阅读文献来看,安卓、对抗样本、后门攻击在基于机器学习的恶意代码检测模型中是热点</li>
</ul></li>
<li><strong>问题：</strong>
<ul>
<li>基于收获的第一点：由于对于写出一篇好的文章需要如此高的综合能力，因此现阶段很多细节不懂。不能完全领略到文章的美妙。</li>
<li>难以在英文文献中直接<strong>检索</strong>出恶意代码中关于对抗样本的文章</li>
</ul></li>
<li><strong>下一个目标：</strong>
<ul>
<li>针对第二篇文章中的问题，这篇文章还要细细琢磨</li>
<li>很明显的是顶刊的文献读起来比普通期刊的文章更加吃力、但是也更加耐人寻味。</li>
<li>针对以上问题：或许我觉得我需要更系统地学习研究方法、研究思路、实验方法。</li>
</ul></li>
</ul>
<h3 id="section-50">2022-11-04</h3>
<h4 id="论文学习-8">论文学习</h4>
<p><a
target="_blank" rel="noopener" href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CDFD&amp;dbname=CDFDLAST2022&amp;filename=1020405886.nh&amp;uniplatform=NZKPT&amp;v=xjiG-vadnpzkvu94KN5K6owyE63keKSbdc119t_5nEfUR2a8ZsLu8ytcab9C2gM2">对抗样本技术在恶意软件检测和自动驾驶应用中的研究</a>（湖大-博士论文）</p>
<ul>
<li>在<strong>cvpr2019</strong>
会议（人工智能顶会）中，直接关于对抗样本的论文有<code>67</code>篇，与对抗样本间接相关的有<code>58</code>篇；同样在网络与信息安全领域，被网安顶刊收入的相关文章中被引用的就有<code>上百</code>篇</li>
<li>潜在威胁：不良分子利用人工智能技术窃取用户隐私，而<strong>对抗样本</strong>技术可以欺骗不法分子的智能分析系统，从而避免损失</li>
</ul>
<figure>
<img src="https://s2.loli.net/2022/11/04/N71cSsw3yvhUYdE.png"
alt="image-20221104100213942" />
<figcaption aria-hidden="true">image-20221104100213942</figcaption>
</figure>
<ul>
<li><strong>防御性研究</strong>
<ul>
<li>修改训练过程或输入样本</li>
<li>修改检测或判定网络</li>
<li>采用外部网络结构</li>
</ul></li>
<li>如果在<strong>自动驾驶</strong>领域发生此类攻击将是灾难性的</li>
<li>本文在<strong>恶意代码检测</strong>领域提出了一种对抗性纹理恶意软件干扰攻击方法（ATMPA）</li>
<li>提出了一种恶意软件可视化自动检测方法（Visual-AT）</li>
<li><strong>人工神经网络</strong>：类似于人类大脑突触的连接结构</li>
<li><strong>对抗样本评价指标</strong>：
<ul>
<li>成功率</li>
<li>鲁棒性</li>
<li>转移性（对其他模型的攻击效果）</li>
<li>干扰值（合适的大小）：太小不足以生成对抗样本，太大会被人眼识别</li>
<li>从<strong>相反</strong>的方向来说：利用对抗样本可以提高模型的抗干扰能力</li>
</ul></li>
<li>如何利用对抗样本技术来提高<strong>恶意软件的检测效率与检测精度</strong>，是目前该领域值得进一步研究的问题</li>
</ul>
<h4 id="总结-38">总结</h4>
<ul>
<li><strong>问题和思考</strong>：
<ul>
<li>我认为非常难的一部分在于<strong>实验</strong>上，其中涉及众多全面的专业知识和必要的数学知识，以及实验设计和分析、评估实验等都是一个相当大的难题。故于我现在而言，要发表一篇不错的论文，任重而道远</li>
</ul></li>
<li><strong>上周问题解决与收获</strong>：
<ul>
<li>目标2：恶意代码的检测是个热门研究问题，而使用机器学习和深度学习来检测恶意代码必然需要训练模型，有<strong>模型</strong>那么必然会牵扯上对抗样本。总的来说就是：恶意代码检测中的对抗样本问题。且根据<strong>前人</strong>对对抗样本的研究，关于恶意代码检测领域的文章不少。</li>
<li>在恶意代码检测中的对抗样本问题<strong>更为明显</strong>，因为对一个测试用例的分类错误可能会造成巨大的损失</li>
</ul></li>
</ul>
<figure>
<img src="https://s2.loli.net/2022/11/04/HUNEe4LpGr1fwkO.png"
alt="image-20221104152820692" />
<figcaption aria-hidden="true">image-20221104152820692</figcaption>
</figure>
<ul>
<li><strong>下一个目标</strong>：将从以下三点继续研究</li>
<li>基于生成的对抗样本训练出<strong>鲁棒性更高的模型</strong>也是个值得研究的问题</li>
<li>注意到<strong>对抗样本的生成</strong>也是一个值得研究的点</li>
<li>关于该领域的研究可以从对对抗样本的<strong>攻击或防御</strong>方面继续深挖，结合上周已经总结出的近10种攻击或防御手段</li>
</ul>
<h3 id="section-51">2022-10-28</h3>
<h4 id="论文学习-9">论文学习</h4>
<p><a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0167404822001572">Adversarial
malware sample generation method based on the prototype of deep learning
detector</a>（<strong>CCF B</strong>computer and security）</p>
<ul>
<li>在多篇文章中注意到很多人研究的一个问题：<strong>基于深度学习的恶意代码检测模型的可解释性</strong>(也许中文翻译并不准确)，我觉得这个问题很<strong>难以理解</strong>，不是很懂在研究什么。暂时的理解是，解释：<strong>为什么这种深度学习模型对恶意代码的检测是否准确。</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9186721">Can We Trust
Your Explanations? Sanity Checks for Interpreters in Android Malware
Analysis</a>这篇也是</li>
<li>本文提出了一种基于原生深度学习的生成恶意代码样本的新方法</li>
<li>本文讨论的对象是windows系统下的pe文件（可执行文件）</li>
<li>这种方法有助于理解深度学习模型的全局可解释性</li>
<li>对抗样本生成方法
<ul>
<li>分成无目标攻击和有目标攻击</li>
<li>FGSM,I-FGSM,C&amp;W attatck</li>
<li>白盒测试与黑盒测试之分</li>
</ul></li>
<li>为了防止让人类感知出图像差异，增加的扰动必须有限制</li>
<li>一种方式是将二进制文件转化为图像，一种是将二进制文件的字节转化为灰度图像</li>
</ul></li>
</ul>
<h4 id="他人博文学习">他人博文学习</h4>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/42667844">对抗样本</a></p>
<p><a
target="_blank" rel="noopener" href="https://baidinghub.github.io/2020/04/03/%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89%E4%BB%A5%E7%BB%BC%E8%BF%B0%E5%85%A5%E9%97%A8/#%E4%B8%80%E3%80%81%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF">对抗样本2</a></p>
<ul>
<li><p>AI attack</p></li>
<li><p>攻击分类</p>
<ul>
<li>白盒攻击</li>
<li>黑盒攻击</li>
<li>真实世界攻击</li>
<li>有目标攻击</li>
<li>无目标攻击</li>
</ul></li>
<li><p>威胁模型</p>
<ul>
<li>假正例攻击和假反例攻击</li>
<li>白盒攻击和黑盒攻击</li>
<li>有目标和无目标</li>
<li>单步攻击和迭代攻击</li>
</ul></li>
<li><p>扰动</p>
<ul>
<li>个体攻击和普适性攻击</li>
<li>优化扰动和普适性攻击</li>
</ul></li>
<li><p>基准：评价标准</p></li>
<li><p>对抗攻击方法(许多方法需要深度探索才能理解,需要很多<strong>数学知识</strong>解释)</p>
<ul>
<li><p>L-BFGS</p></li>
<li><p>FGSM</p></li>
<li><p>FGVM</p></li>
<li><p>RAND-FGSM</p></li>
<li><p>BIM</p></li>
<li><p>ILLC</p></li>
<li><p>JSMA</p></li>
<li><p>DeepF00l</p></li>
<li><p>CPPN EA FOOL</p></li>
<li><p>C&amp;W's attack(攻击蒸馏防御网络)</p></li>
<li><p>ZOO</p></li>
<li><p>Universal Perturbation(普适性攻击方法)</p></li>
<li><h6 id="one-pixel-attack">One Pixel Attack</h6></li>
<li><p>Feature Adversary</p></li>
<li><p>Hot/Cold</p></li>
<li><p>Natural GAN</p></li>
<li><p>Model-based Ensembling Attack</p></li>
<li><p>Ground-Truth Attack</p></li>
</ul></li>
<li><p>对抗防御方法</p>
<ul>
<li>网络蒸馏</li>
<li>对抗训练：训练对抗样本</li>
<li>对抗识别</li>
<li>输入重建</li>
<li>鲁棒的分类器</li>
<li>网络验证</li>
<li>集成防御</li>
</ul></li>
<li><p>问题与挑战</p>
<ul>
<li>迁移性</li>
<li>存在性</li>
</ul></li>
</ul>
<h4 id="总结-39">总结</h4>
<p><strong>问题：</strong></p>
<ul>
<li>本周<strong>结课科目</strong>较多，需要完成多篇小论文，科研时间有限。</li>
<li>关于对抗样本的<strong>认识</strong>还需要进一步提升。</li>
</ul>
<p><strong>收获：</strong></p>
<ul>
<li>对抗样本的研究是一个细致的问题，但是目前研究的还是<strong>很深</strong></li>
<li>这周所读的英文文献还是比较流畅，也许<strong>阅读能力</strong>提升了？</li>
<li>两个好用的文献<strong>数据库</strong>：
<ul>
<li><a target="_blank" rel="noopener" href="https://www.sciencedirect.com/">sciencedirect</a></li>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/">ACM</a>（这个好像学校没花钱购买）</li>
</ul></li>
<li>感觉阅读他人文献是一种享受</li>
</ul>
<p><strong>下一个目标：</strong></p>
<ul>
<li>关于对抗样本的研究还需要花更多时间</li>
<li>关于<strong>对抗样本</strong>与<strong>恶意代码检测</strong>这两者如何结合的问题需要解决</li>
</ul>
<h3 id="section-52">2022-10-21</h3>
<h4 id="关于研究背景的补充">关于研究背景的补充</h4>
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/8949524">A
Comprehensive Review on Malware Detection Approaches</a>（IEEE
ACCESS）</p>
<ul>
<li><p>利用恶意代码进行网络犯罪，造成巨大经济损失</p></li>
<li><p>基于特征的检测方法和基于启发式的检测方法对于检测已经发现的恶意代码家族有很好的效果，但是对于未知的恶意代码很不理想，尤其是前一种方法。</p></li>
<li><p>其次现在的恶意代码已经能够以内核态运行造成更大的破坏，这种恶意代码被称之为（<code>next-generation</code>），它可以轻松绕过防火墙和杀毒软件。并且，这种恶意代码能同时呈现出多种特征。</p></li>
</ul>
<figure>
<img src="https://s2.loli.net/2022/10/20/oy7NGkhxLuIfSFW.png"
alt="传统恶意代码和新一代代码对比" />
<figcaption aria-hidden="true">传统恶意代码和新一代代码对比</figcaption>
</figure>
<ul>
<li>随着时间的推移，研究人员提出了基于行为、基于启发式、基于模型检测的<strong>检测方法</strong>。通过这些方法，数据挖掘和机器学习也开始应用在恶意代码检测上。<strong>新的方法</strong>有：基于深度学习、基于移动设备、基于物联网的检测。</li>
<li>对于未知且复杂的恶意软件，基于行为、基于模型检测和基于云的方法<strong>表现更好</strong>，基于深度学习、基于移动设备和基于物联网的方法则在上述恶意软件的一部分中使用</li>
<li>不能绝对的说哪种方法更好，不同的情形、不同的方法有不同优势和缺陷,没有方法能检测所有新一代且复杂的malware。因此，建立一种高效的的检测方法是个挑战，是个非常值得研究的问题。</li>
<li><strong>研究问题探讨</strong>
<ul>
<li>设计一种能检测所有malware的算法不存在</li>
<li>恶意代码检测理论上是一个难题，并且恶意代码开发者使用混淆技术，使得检测更加困难
<ul>
<li>其中谈到的<code>P和NP问题</code>难以理解</li>
<li>混淆技术：
<ul>
<li>Encryption</li>
<li>Oligomprphic</li>
<li>Polymorphic</li>
<li>Metamorphoic</li>
<li>Stealth</li>
<li>Packaing</li>
</ul></li>
</ul></li>
</ul></li>
<li>检测技术
<ul>
<li>检测过程
<ul>
<li>分析
<ul>
<li>静态和动态分析</li>
<li>逆向工程</li>
</ul></li>
<li>特征提取
<ul>
<li>数据挖掘</li>
<li><code>n-gram模型</code>：使用静态和动态属性创建特征；增加了特征空间；降低了模型的性能</li>
<li><code>基于图的模型</code>：顶点表示系统调用，边表示系统调用之间的关系。</li>
<li>数据集：
<ul>
<li><strong>NSL-KDD dataset</strong></li>
<li><strong>Drebin dataset</strong></li>
<li><strong>Microsoft malware classification challenge
dataset</strong></li>
<li><strong>ClaMP</strong></li>
<li><strong>AAGM datase</strong></li>
<li><strong>EMBER dataset</strong></li>
</ul></li>
<li>著名的机器学习算法：
<ul>
<li>BN</li>
<li>NB</li>
<li>C4.5 decision tree variant (J48),</li>
<li>LMT</li>
<li>RF</li>
<li>KNN</li>
<li>MLP</li>
<li>SLR</li>
<li>SVM</li>
<li>SMO</li>
</ul></li>
</ul></li>
<li>分类</li>
</ul></li>
</ul></li>
</ul>
<h4 id="如何开展科研">如何开展科研</h4>
<ul>
<li>同时阅读两类文献
<ul>
<li><strong>综述性文献</strong>，需非常仔细地阅读和理解</li>
<li>最新两三年度内相关的研究论文，了解前沿和进展，掌握自己的问题的研究历史和现状、在学科发展中占据什么样的地位。</li>
</ul></li>
<li>文献<strong>检索</strong>平台
<ul>
<li>Google scholar</li>
<li>DOI</li>
<li>SCI-HUB</li>
<li>Web Of Science</li>
</ul></li>
<li>找出最顶级、权威的论文</li>
<li>阅读的阶段
<ul>
<li>通过摘要看是否有感兴趣的东西，了解作者做了什么（内容目录、结论、简介）</li>
<li>该方向包括哪些研究内容？或者这个方向主要解决哪些问题？</li>
<li>针对这些问题，前人采用了哪种方法？</li>
<li>不同的研究团队采用了哪些不同的解决方案？各种方法各具有哪些优点？</li>
<li>目前该方向的最新研究进展如何？</li>
</ul></li>
</ul>
<h4 id="论文学习-10">论文学习</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://t.cnki.net/kcms/detail?v=7X1a-1n3lSlo7e8SD7MIrB4FNnqSB7t_ePAoPyb7UoHmdjy7X1BnKGJRTP-uE0xthwgZy7oAvyPeohpt27IF1AemI04TB997jyRzzpbNlx1tRRBs7PwTDS05-d4AuiQsZVkR1WkGtsg=&amp;uniplatform=NZKPT">深度学习赋能的恶意代码攻防研究进展</a>《计算机学报-方滨兴》
<ul>
<li>本文讨论了深度学习在恶意代码攻击与防御上的研究现状</li>
<li>其中在恶意代码查杀与恶意代码检测上的研究值得关注，其中多处提到<strong>对抗样本攻击</strong></li>
<li>恶意代码存在形式：二进制文件、Javascript、PowerShell等</li>
</ul></li>
<li><a
target="_blank" rel="noopener" href="https://www.sohu.com/a/295737605_468736">关于对抗样本恢复的研究</a>
<ul>
<li>专业性强、研究深入</li>
</ul></li>
<li><a
target="_blank" rel="noopener" href="https://www.secrss.com/articles/19040">深度学习中对抗样本的防御和攻击</a>
<ul>
<li>深度神经网络
<ul>
<li>DNN</li>
<li>CNN</li>
<li>GAN</li>
<li>RNN</li>
<li>AE</li>
</ul></li>
</ul></li>
<li><a
target="_blank" rel="noopener" href="https://www.webofscience.com/wos/woscc/summary/4740b22c-08f3-4131-8b78-4427230ddc73-575ff030/relevance/1">malware综述检索</a></li>
</ul>
<h4 id="他人博文学习-1">他人博文学习</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/86794447">一文看懂人工智能、机器学习、深度学习与神经网络之间的区别与关系</a>
<ul>
<li>强化学习：基于反馈机制</li>
<li>迁移学习：将该技术方法应用于不同但相关的问题</li>
</ul></li>
<li></li>
</ul>
<h4 id="恶意代码-二进制学习记录">恶意代码-二进制（学习记录）</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://liuhaihuaaacc.gitee.io/2022/10/12/pma03-lab1/">恶意代码分析实验1传送门</a></li>
</ul>
<h4 id="总结-40">总结</h4>
<ul>
<li><p><strong>问题</strong></p>
<ul>
<li>目前确定了研究方向，了解了研究背景，但是不明确<strong>下一步</strong>具体该做些什么？</li>
<li>阅读文献还远远不够，意识到自己仍处在一个距离研究领域中心非常边缘的位置</li>
<li>内心的一个感觉是：无论进度怎么往前推，其实也会发现前面做的工作也还是不够，在后续中，仍然会重复之前的工作。</li>
</ul></li>
<li><p><strong>收获</strong></p>
<ul>
<li><p>各种技术、方法、模型眼花缭乱，需要不断积累这些专业知识。</p></li>
<li><p>现阶段没有必要在一些<strong>细节</strong>上纠结：了解本文提出了什么问题，用什么研究方法解决了该问题，以及得出了什么结论即可，我想。</p></li>
<li><p>如果不知道学什么，那就看论文吧。文献里会有答案</p></li>
<li><p>之前并不知道综述和常规文献的区别，本周通过阅读了几篇<strong>综述（</strong>综述可以更加快速全面地了解到研究领域的现状），对自己的研究领域有了更加深入的了解（其中尤其是认识到了研究问题的<strong>难点</strong>、<strong>意义</strong>、<strong>挑战</strong>）</p></li>
</ul></li>
<li><p><strong>下周目标</strong></p>
<ul>
<li>将上周及之前阅读论文涉及到的专业知识、方法、模型更加深入地学习</li>
<li>至少再阅读两篇综述文献和两篇该研究领域的文献</li>
<li>其中，尤其是再深入了解<strong>对抗样本</strong>这块内容</li>
</ul></li>
</ul>
<h3 id="section-53">2022-10-14</h3>
<h4 id="研究背景调查">研究背景调查</h4>
<ul>
<li>随着互联网快速发展，恶意代码数量也呈爆发式增长。2020年瑞星“云安全”系统共截获病毒样本总量1.48亿，病毒感染次数3.52亿次，恶意代码已经成为网络安全的<strong>重要威胁</strong>之一。</li>
<li>恶意软件检测的传统手段有<strong>静态分析和动态分析</strong>两种方式
<ul>
<li>静态分析是指包括检查可执行文件和但不查看具体指令的一些技术</li>
<li>研究运行的恶意代码</li>
<li>但在实际应用中，受代码混淆和加壳技术的影响，这两种检测方法都存在检测结果重复性和滞后性严重等问题，同时在检测精度上也无法达到网络通信安全运行的要求。</li>
</ul></li>
<li>在利用<strong>机器学习</strong>模型检测恶意代码方面，不少学者（Laikarish,Wang,Jodavi,AL-Taharva，马洪亮，赵梓旭等人提出了不同的特征提取方法来检测恶意代码。尽管以上基于基于机器学习模型的恶意代码检测方法有较高的检测率，但是由于需要复杂的特征提取。因此机器学习方法有一定局限性。</li>
<li>在利用<strong>深度学习</strong>模型检测恶意代码方面，因为深度学习算法，无需像机器学习通过特征工程提取特征。深度学习算法网络，可以自动提取输入数据的特征。因此许多学者利用深度学习迷行对恶意代码进行检测，极大简化了训练过程，但是深度学习模型在对抗场景下其存在抗攻击能力较差问题</li>
<li>但是学习模型本身存在安全性问题，模型的有效性，取决于训练数据和测试数据遵循相同的分布假设，这种假设很可能遭到攻击者的破坏，损坏模型的安全性。攻击者在输入样本上施加微小的扰动便能被迫使分类模型作出错误的预测，这种方式称为<strong>对抗样本攻击</strong>。在恶意代码领域，攻击者利用模型的不足，生成恶意代码样本，达到绕过恶意代码检测器的目的。</li>
</ul>
<h3 id="section-54">2022-10-07</h3>
<h4 id="如何开展科研-1">如何开展科研</h4>
<ul>
<li><strong>本质：</strong>发现问题、分析问题、解决问题</li>
<li>清楚一些问题:
<ul>
<li>我们是否清楚了科研问题</li>
<li>是否可以提出更加本质的科学问题</li>
<li>我课题的核心问题是什么</li>
</ul></li>
<li>方法：创新
<ul>
<li>学习：科技前沿、领域的历史</li>
<li>研究：从一个方面深深地钻进去</li>
<li>猜想：引领科技前沿</li>
</ul></li>
</ul>
<h4 id="他人博文学习-2">他人博文学习</h4>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/forum/topic/0203811848092790259?fid=0101592429757310384">详解基于机器学习的恶意代码检测技术</a></p></li>
<li><p><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/352004681">恶意代码检测的本质性思考</a></p></li>
<li><p><a
target="_blank" rel="noopener" href="https://github.com/rshipp/awesome-malware-analysis/blob/main/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%A4%A7%E5%90%88%E9%9B%86.md">恶意软件分析大合集</a></p></li>
<li><p><a
target="_blank" rel="noopener" href="https://github.com/0e0w/Malware#0x01-%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E8%B5%84%E6%BA%90">深入理解恶意代码与病毒样本</a></p></li>
<li><p><a
target="_blank" rel="noopener" href="https://github.com/ByteHackr/Machine-Learning-For-Cyber-Security/blob/master/README_ch.md#-papers">网络安全中机器学习大合集</a></p></li>
<li><p><a
target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-266139.htm">恶意代码分析方向的基础技能表</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/hija/MalwareDataScience">Malware Data
Science-Read Diary</a></p></li>
</ul>
<h4 id="研究切入点">研究切入点</h4>
<ul>
<li><strong>改进</strong>检测方法
<ul>
<li><a
target="_blank" rel="noopener" href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2022&amp;filename=WXJY202206001&amp;uniplatform=NZKPT&amp;v=r6asokm-xQskr3fuo9nqvOKih3U9ByxGh9mQzX8eK9OhtX-76EmqGMWUhA1UoUuU">基于挤压激励网络的恶意代码家族检测方法</a></li>
<li><a
target="_blank" rel="noopener" href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CAPJ&amp;dbname=CAPJLAST&amp;filename=TXXB20220919005&amp;uniplatform=NZKPT&amp;v=plc0SX0ZHq2RYg8LJ86IqmTEHDpdTiSWWW_gx-tpcJMG8aa_eyQpHgG3IayvwrsT">对抗训练驱动的恶意代码检测方法</a></li>
</ul></li>
<li>采用某种前沿技术提出新的恶意代码分类方法
<ul>
<li><a
target="_blank" rel="noopener" href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2022&amp;filename=WHDY202201002&amp;uniplatform=NZKPT&amp;v=UbBTdaZR2oDC2Jr8iBshj49HqhCHkKDPQ4i1CvzlLreIVhO50WjwZ4lfbz2jhjxX">基于深度学习的PowerShell恶意代码家族分类研究</a></li>
</ul></li>
<li>改进算法抵抗恶意代码攻击
<ul>
<li><a
target="_blank" rel="noopener" href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2022&amp;filename=JSJZ202201073&amp;uniplatform=NZKPT&amp;v=zTBVG7QweyKmoY1Z5XHFz0OH7gvcCqjp2OPXhvyQlgHh0JxF03f1xDsusRWLi8I8">基于改进深度森林的抗恶意代码攻击算法仿真</a></li>
</ul></li>
<li>针对一个技术细节问题提出解决方案
<ul>
<li><a
target="_blank" rel="noopener" href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2022&amp;filename=XXAQ202112006&amp;uniplatform=NZKPT&amp;v=S2TpplvyzmzvkIUEBP95m5RsxLjdHFjAChs-PD2LAYN8AoVdGL2VSWDalRjuLZVH">基于删除PE文件头的恶意代码内存取证方法</a></li>
</ul></li>
</ul>
<h4 id="web-恶意代码学习">web 恶意代码学习</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://liuhaihuaaacc.gitee.io/2022/10/03/xss-wen-jian-bao-han-lou-dong-yuan-li/">传送门</a></li>
</ul>
<h4 id="malware学习">Malware学习</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://liuhaihuaaacc.gitee.io/2022/10/08/pma-dong-tai-fen-xi/">传送门</a></li>
</ul>
<h4 id="machine-learning">Machine Learning</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://liuhaihuaaacc.gitee.io/2022/10/08/ml02/">传送门</a></li>
</ul>
<h4 id="总结-41">总结</h4>
<ul>
<li>积累，厚积才能薄发</li>
</ul>
<h3 id="section-55">2022-09-30</h3>
<h4
id="补充为什么选择恶意代码分析与检测这个方向">补充：为什么选择恶意代码分析与检测这个方向</h4>
<ul>
<li>这个研究方向与本人擅长的知识和技术：C/C++,Python,操作系统等较为契合，且该方向在学术上也较为光明</li>
<li>强烈的兴趣</li>
<li>同样考虑到毕业选择工作，而该方向在实际工作和工程中同样比较火热</li>
</ul>
<h4 id="论文期刊">论文期刊</h4>
<ol type="1">
<li><h6
id="can-we-trust-your-explanations-sanity-checks-for-interpreters-in-android-malware-analysistifs"><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9186721">Can We Trust Your
Explanations? Sanity Checks for Interpreters in Android Malware
Analysis</a>（TIFS）:</h6>
<ul>
<li>在基于机器学习的恶意软件分析中，提出了许多解释方法进行预测，但是这种解释方法不能得到统一，因此基于稳定性、稳健性和有效性这三个指标对解释方法进行健全性检查，帮助对恶意代码的分析。</li>
<li>许多专业术语不太了解，没看完全篇，吃力（必要技术和前沿技术的学习还不够）</li>
</ul></li>
</ol>
<h4 id="他人博文学习-3">他人博文学习</h4>
<ol type="1">
<li><a
target="_blank" rel="noopener" href="https://whale3070.github.io/2022/02/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">机器学习与恶意代码分析</a>（该博文暂时失效）</li>
</ol>
<h4 id="恶意代码分析技术学习">恶意代码分析技术学习</h4>
<p><strong>注：</strong> <em>传送门</em>
链接的内容均由本人逐字敲打来记录这段时期的具体所学（下同）</p>
<ul>
<li><a
target="_blank" rel="noopener" href="https://liuhaihuaaacc.gitee.io/2022/10/01/practical-malware-analysis/">传送门</a></li>
</ul>
<h4 id="web方向的恶意代码学习">web方向的恶意代码学习</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://liuhaihuaaacc.gitee.io/2022/09/26/python-kai-fa-xss-sao-miao-qi/">传送门</a></li>
</ul>
<h4 id="机器学习的学习">机器学习的学习</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://liuhaihuaaacc.gitee.io/2022/10/01/machine-learning00/">传送门</a></li>
</ul>
<h4 id="总结-42">总结</h4>
<ul>
<li><p><strong>问题：</strong>这段时间，由于课堂上等各种大作业、ppt演讲的出现，以及刚入门这个较为未知的领域，因此研究方向上进展缓慢。</p></li>
<li><p><strong>未来计划：</strong>继续以上三项的学习。</p></li>
<li><p><strong>下个目标：</strong></p>
<ul>
<li>在本周期已经入门的基础上，加快研究进度</li>
<li>阅读英文顶级期刊的能力提升一个档次</li>
</ul></li>
</ul>
<h3 id="section-56">2022-09-06</h3>
<h4 id="ai-security">AI security</h4>
<ul>
<li><p>AI for Security</p></li>
<li><p>Security of AI</p>
<ul>
<li>Model Security
<ul>
<li>inference Security</li>
<li>training Security</li>
</ul></li>
<li>data security</li>
</ul></li>
</ul>
<h4 id="网安方向分类">网安方向分类</h4>
<ul>
<li><figure>
<img
src="https://cdn.jsdelivr.net/gh/A1phaMan7/pictureBed/img/202209061944309.jpg"
alt="v2-d7e84da65c80ef6580e22380cbf1918f_720w" />
<figcaption
aria-hidden="true">v2-d7e84da65c80ef6580e22380cbf1918f_720w</figcaption>
</figure></li>
</ul>
<h4 id="恶意代码分析检测">恶意代码分析检测</h4>
<ul>
<li><p>恶意代码分析是一种解剖恶意代码的艺术，了解恶意代码是如何工作的、如何识别他，以及如何战胜和消除它</p></li>
<li><p><strong>关键词：</strong> 恶意代码、逆向、汇编</p></li>
<li><p>资料</p></li>
</ul>
<ol type="1">
<li><figure>
<img
src="https://cdn.jsdelivr.net/gh/A1phaM7/pictureBed/img/202209091459035.png"
alt="恶意代码分析实战" />
<figcaption aria-hidden="true">恶意代码分析实战</figcaption>
</figure></li>
<li><p>论文期刊</p>
<ol type="1">
<li><h6
id="a-hybrid-malicious-code-detection-method-based-on-deep-learning"><a
target="_blank" rel="noopener" href="http://www.covert.io/research-papers/deep-learning-security/A%20Hybrid%20Malicious%20Code%20Detection%20Method%20based%20on%20Deep%20Learning.pdf">A
hybrid malicious code detection method based on deep
learning</a></h6></li>
<li><h6
id="malicious-code-detection-based-on-cnns-and-multi-objective-algorithm"><a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0743731518308529">Malicious
code detection based on CNNs and multi-objective algorithm</a></h6></li>
<li><h6
id="malicious-code-detection-based-on-image-processing-using-deep-learning"><a
target="_blank" rel="noopener" href="https://dl.acm.org/doi/abs/10.1145/3194452.3194459">Malicious code
detection based on image processing using deep learning</a></h6></li>
<li><h6
id="efficient-malicious-code-detection-using-n-gram-analysis-and-svm"><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/abstract/document/6041963/">Efficient
malicious code detection using n-gram analysis and SVM</a></h6></li>
<li><h6
id="static-analysis-of-executables-to-detect-malicious-patterns"><a
target="_blank" rel="noopener" href="https://www.usenix.org/event/sec03/tech/full_papers/christodorescu/christodorescu_html">Static
analysis of executables to detect malicious patterns</a></h6></li>
<li><h6
id="malicious-code-detection-under-5g-hetnets-based-on-a-multi-objective-rbm-model"><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/abstract/document/9318423/">Malicious
code detection under 5G HetNets based on a multi-objective RBM
model</a></h6></li>
<li><h6 id="n-gram-based-detection-of-new-malicious-code"><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/abstract/document/1342667/">N-gram-based
detection of new malicious code</a></h6></li>
<li><h6 id="malicious-code-detection-using-active-learning"><a
target="_blank" rel="noopener" href="https://link.springer.com/chapter/10.1007/978-3-642-01718-6_6">Malicious
code detection using active learning</a></h6></li>
<li><h6
id="a-novel-solutions-for-malicious-code-detection-and-family-clustering-based-on-machine-learning"><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/abstract/document/8863895/">A novel
solutions for malicious code detection and family clustering based on
machine learning</a></h6></li>
<li><h5
id="feature-representation-and-selection-in-malicious-code-detection-methods-based-on-static-system-calls"><a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S016740481100068X">Feature
representation and selection in malicious code detection methods based
on static system calls</a></h5></li>
<li><p>（著名通讯软件telegram使用的协议mtproto）<a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9833666">Four Attacks and a
Proof for Telegram</a>（IEEE S&amp;P）</p></li>
<li><h6
id="malicious-code-family-classification-based-on-multi-feature-fusion-fractional-kalman-filter"><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9137472/">Malicious Code
Family Classification Based on Multi-feature Fusion Fractional Kalman
Filter</a></h6></li>
<li><h6
id="static-detection-of-malicious-code-in-programs-using-semantic-techniques"><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9393121/">Static Detection of
Malicious Code in Programs Using Semantic Techniques</a></h6></li>
<li><h6
id="classification-of-malicious-code-based-on-grayscale-texture-fingerprint"><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9532020/">Classification Of
Malicious Code Based On Grayscale Texture Fingerprint</a></h6></li>
<li><h6
id="a-web-page-malicious-code-detect-approach-based-on-script-execution"><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/5362882/">A Web Page
Malicious Code Detect Approach Based on Script Execution</a></h6></li>
</ol></li>
<li><p>博客</p>
<ol type="1">
<li><a
target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/column/91034/tag-0">博主主页</a></li>
<li><a
target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1967938">[AI安全论文]
Powershell恶意代码检测论文总结及抽象语法树（AST）提取</a></li>
<li><a
target="_blank" rel="noopener" href="https://blog.csdn.net/eastmount/category_9193519.html">系统安全与恶意代码分析</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.zhihu.com/topic/20027317/hot">知乎软件逆向</a></li>
</ol></li>
</ol>
<h4 id="联邦学习">联邦学习</h4>
<blockquote>
<p>解决数据孤岛， <a
target="_blank" rel="noopener" href="https://github.com/FederatedAI/FATE">FATE开源框架</a></p>
</blockquote>
<ul>
<li><p>关键词：数据孤岛、数据安全、分布式</p></li>
<li><p>无数据交换，天然隐私保护</p></li>
<li><p>分类</p>
<ul>
<li><p>横向</p></li>
<li><p>纵向</p></li>
<li><p>迁移</p></li>
</ul></li>
<li><p>安全和隐私攻击</p>
<ul>
<li>CIA:机密性、完整性、可用性</li>
<li>投毒攻击</li>
<li>对抗攻击</li>
<li>参与者GAN攻击</li>
<li>推理攻击</li>
</ul></li>
</ul>
<h4 id="网络安全态势感知-基于收集的信息进行风险预测">网络安全态势感知：
基于收集的信息进行风险预测</h4>
<h4 id="网络安全攻防对抗">网络安全攻防对抗</h4>
<h4
id="软件定义网络与安全软件定义网络优化安全检测与防护">软件定义网络与安全（软件定义网络优化、安全检测与防护）</h4>
<h4
id="区块链与安全区块链应用和优化共识安全网络安全">区块链与安全（区块链应用和优化、共识安全、网络安全）</h4>
<h4
id="网络流量分析高性能网络报文处理数据分析">网络流量分析（高性能网络报文处理、数据分析）</h4>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Jf710001011</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://Jf710001011.github.io/2022/09/05/academic-progress/">https://Jf710001011.github.io/2022/09/05/academic-progress/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="/about" target="_blank">Jf710001011</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Academic/">
                                    <span class="chip bg-color">Academic</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'U2qj9LBn7UhJFyVyb1bYDa9w-gzGzoHsz',
        appKey: 'Tg6wRvRlIfODtULeHu4P96zh',
        notify: 'true' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'en',
        placeholder: 'just go go'
    });
</script>

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2022/09/26/python-kai-fa-xss-sao-miao-qi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="python开发xss扫描器">
                        
                        <span class="card-title">python开发xss扫描器</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            xss扫描器、xss
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-09-26
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Cybersecurity/" class="post-category">
                                    Cybersecurity
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Web/">
                        <span class="chip bg-color">Web</span>
                    </a>
                    
                    <a href="/tags/Python/">
                        <span class="chip bg-color">Python</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/08/24/shen-tou-ce-shi-xia/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="渗透测试基础（下）">
                        
                        <span class="card-title">渗透测试基础（下）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            penetration
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-08-24
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Cybersecurity/" class="post-category">
                                    Cybersecurity
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Web/">
                        <span class="chip bg-color">Web</span>
                    </a>
                    
                    <a href="/tags/Xss/">
                        <span class="chip bg-color">Xss</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




                            <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023</span>
            
            <span id="year">2023</span>
            <a href="/about" target="_blank">Jf71o0x1o1l</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">230.3k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2023";
                    var startMonth = "2";
                    var startDate = "16";
                    var startHour = "24";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
            <span id="icp"><img src="/medias/icp.png" style="vertical-align: text-bottom;" />
                <a href="/null" target="_blank">津ICP备Jf710001011号</a>
            </span>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Jf710001011" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:lhhyp2333@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


                                <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

                                    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


                                        <script
                                            src="/libs/materialize/materialize.min.js"></script>
                                        <script
                                            src="/libs/masonry/masonry.pkgd.min.js"></script>
                                        <script
                                            src="/libs/aos/aos.js"></script>
                                        <script
                                            src="/libs/scrollprogress/scrollProgress.min.js"></script>
                                        <script
                                            src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
                                        <script
                                            src="/js/matery.js"></script>

                                        <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

                                            <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

                                                
                                                    <script
                                                        src="/libs/others/clicklove.js"
                                                        async="async"></script>
                                                    
                                                        
                                                            <script async
                                                                src="/libs/others/busuanzi.pure.mini.js"></script>
                                                            

                                                                

                                                                        

                                                                                
                                                                                        
                                                                                            <script
                                                                                                type="text/javascript"
                                                                                                color="0,0,255"
                                                                                                pointColor="0,0,255"
                                                                                                opacity='0.7'
                                                                                                zIndex="-1"
                                                                                                count="99"
                                                                                                src="/libs/background/canvas-nest.js"></script>
                                                                                            

                                                                                                

                                                                                                            
                                                                                                                <script
                                                                                                                    type="text/javascript"
                                                                                                                    src="/libs/background/ribbon-dynamic.js"
                                                                                                                    async="async"></script>
                                                                                                                

                                                                                                                    
                                                                                                                        <script
                                                                                                                            src="/libs/instantpage/instantpage.js"
                                                                                                                            type="module"></script>
                                                                                                                        
                                                                                                                            <script
                                                                                                                                type="text/javascript">
                                                                                                                                    //只在桌面版网页启用特效
                                                                                                                                    var windowWidth = $(window).width();
                                                                                                                                    if (windowWidth > 768) {
                                                                                                                                        document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>');
                                                                                                                                    }
                                                                                                                                </script>
                </body>

</html>