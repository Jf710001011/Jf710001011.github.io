<!DOCTYPE HTML>
<html lang="en">




<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Academic Progress, Hunter|Hacker|Coder|Artist">
    <meta name="description" content="信念与认知">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>


    <title>Academic Progress | Jf71o0x1o1l</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Jf71o0x1o1l" type="application/atom+xml">
</head>


    

                <body>
                    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Jf71o0x1o1l</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Jf71o0x1o1l</div>
        <div class="logo-desc">
            
            信念与认知
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

                        



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/6.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Academic Progress</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Academic/">
                                <span class="chip bg-color">Academic</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Cybersecurity/" class="post-category">
                                Cybersecurity
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2022-09-26
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>Update Date:&nbsp;&nbsp;
                    2024-01-21
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    36.6k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>Read Count:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="论文合集置顶">论文合集（置顶）</h3>
<p>描述：我看过的全部论文</p>
<p><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/search/searchresult.jsp?queryText=malware%20malicious&amp;highlight=true&amp;returnFacets=ALL&amp;returnType=SEARCH&amp;matchPubs=true&amp;refinementName=Publication%20Title&amp;refinements=PublicationTitle:IEEE%20Transactions%20on%20Information%20Forensics%20and%20Security&amp;refinements=PublicationTitle:IEEE%20Transactions%20on%20Dependable%20and%20Secure%20Computing">在TIFS和TDSC上的恶意代码检测相关文章检索</a></p>
<p><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/search/searchresult.jsp?queryText=adversarial%20example&amp;highlight=true&amp;returnType=SEARCH&amp;matchPubs=true&amp;refinementName=Publication%20Title&amp;pageNumber=1&amp;refinements=PublicationTitle:IEEE%20Transactions%20on%20Information%20Forensics%20and%20Security&amp;refinements=PublicationTitle:IEEE%20Transactions%20on%20Dependable%20and%20Secure%20Computing&amp;returnFacets=ALL">在TIFS和TDSC上的对抗样本的相关文章检索</a></p>
<p><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/585456510">对抗鲁棒性学习资料汇总</a></p>
<hr />
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9186721">Can We Trust
Your Explanations? Sanity Checks for Interpreters in Android Malware
Analysis</a>(<strong>CCF-A</strong>:TIFS)</li>
<li><a
target="_blank" rel="noopener" href="https://t.cnki.net/kcms/detail?v=7X1a-1n3lSlo7e8SD7MIrB4FNnqSB7t_ePAoPyb7UoHmdjy7X1BnKGJRTP-uE0xthwgZy7oAvyPeohpt27IF1AemI04TB997jyRzzpbNlx1tRRBs7PwTDS05-d4AuiQsZVkR1WkGtsg=&amp;uniplatform=NZKPT">深度学习赋能的恶意代码攻防研究进展</a>《计算机学报-方滨兴》</li>
<li><a
target="_blank" rel="noopener" href="https://www.sohu.com/a/295737605_468736">关于对抗样本恢复的研究</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.secrss.com/articles/19040">深度学习中对抗样本的防御和攻击</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0167404822001572">Adversarial
malware sample generation method based on the prototype of deep learning
detector</a>（<strong>CCF-B</strong>:computer and security）</li>
<li><a
target="_blank" rel="noopener" href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CDFD&amp;dbname=CDFDLAST2022&amp;filename=1020405886.nh&amp;uniplatform=NZKPT&amp;v=xjiG-vadnpzkvu94KN5K6owyE63keKSbdc119t_5nEfUR2a8ZsLu8ytcab9C2gM2">对抗样本技术在恶意软件检测和自动驾驶应用中的研究</a>（湖大-博士论文）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9762803">MsDroid:
Identifying Malicious Snippets for Android Malware
Detection</a>（<strong>CCF-A</strong>:TDSC-2022，作者来自浙大）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9477038">Backdoor
Attack on Machine Learning Based Android Malware
Detectors</a>（<strong>CCF-A</strong>:TDSC-2022，作者：斯威本科技大学博士）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9484718">DL-FHMC: Deep
Learning-Based Fine-Grained Hierarchical Learning Approach for Robust
Malware Classification</a>（<strong>CCF-A</strong>:TDSC-2022）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9833659">Transcending
TRANSCEND: Revisiting Malware Classification in the Presence of Concept
Drift</a>（CCF-A会议:IEEE S&amp;P）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9186721">Can We Trust
Your Explanations? Sanity Checks for Interpreters in Android Malware
Analysis</a>
<code>&lt;span style='background:##ffb86c;font-family:FiraCode;'&gt;</code>（TIFS）</li>
<li><a
target="_blank" rel="noopener" href="https://t.cnki.net/kcms/detail?v=7X1a-1n3lSlo7e8SD7MIrB4FNnqSB7t_ePAoPyb7UoHmdjy7X1BnKGJRTP-uE0xthwgZy7oAvyPeohpt27IF1AemI04TB997jyRzzpbNlx1tRRBs7PwTDS05-d4AuiQsZVkR1WkGtsg=&amp;uniplatform=NZKPT">深度学习赋能的恶意代码攻防研究进展</a>《计算机学报-方滨兴》</li>
<li><a
target="_blank" rel="noopener" href="https://www.sohu.com/a/295737605_468736">关于对抗样本恢复的研究</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.secrss.com/articles/19040">深度学习中对抗样本的防御和攻击</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0167404822001572">Adversarial
malware sample generation method based on the prototype of deep learning
detector</a>（<strong>CCF会议 B</strong>-computer and security）</li>
<li><a
target="_blank" rel="noopener" href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CDFD&amp;dbname=CDFDLAST2022&amp;filename=1020405886.nh&amp;uniplatform=NZKPT&amp;v=xjiG-vadnpzkvu94KN5K6owyE63keKSbdc119t_5nEfUR2a8ZsLu8ytcab9C2gM2">对抗样本技术在恶意软件检测和自动驾驶应用中的研究</a>（湖大-博士论文）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9762803">MsDroid:
Identifying Malicious Snippets for Android Malware
Detection</a>（<strong>CCF-A</strong>:TDSC-2022，作者来自浙大）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9477038">Backdoor
Attack on Machine Learning Based Android Malware
Detectors</a>（<strong>CCF-A</strong>:TDSC-2022，作者：斯威本科技大学博士）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9484718">DL-FHMC: Deep
Learning-Based Fine-Grained Hierarchical Learning Approach for Robust
Malware Classification</a>（<strong>CCF-A</strong>:TDSC-2022）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9833659">Transcending
TRANSCEND: Revisiting Malware Classification in the Presence of Concept
Drift</a>（<strong>CCF-A会议</strong>:IEEE S&amp;P）</li>
<li><a
target="_blank" rel="noopener" href="https://link.springer.com/article/10.1007/s00521-021-06597-0">Applications
of deep learning for mobile malware detection: A systematic literature
review</a>(NCA:人工智能-<strong>CCF-C</strong>)</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9964330">A Survey of
Adversarial Attack and Defense Methods for Malware Classification in
Cyber Security</a>（<strong>中科院JCR分区一区TOP</strong>:IEEE
COMMUNICATIONS SURVEYS &amp; TUTORIALS）</li>
<li><a target="_blank" rel="noopener" href="https://www.hindawi.com/journals/scn/2020/8858010/">A
Survey of Automatic Software Vulnerability Detection, Program Repair,
and Defect Prediction Techniques</a>（<strong>CCF-C:</strong>Security
and Communication Networks 2020）</li>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3474553">Efficiency and
Effectiveness of web application vulnerability detection approaches: A
Review</a> （<a target="_blank" rel="noopener" href="https://dl.acm.org/toc/csur/2022/54/9">ACM
Computing Surveys</a>：<strong>中科院分区一区top</strong>）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9842744">Can Deep
Learning Models Learn the Vulnerable Patterns for Vulnerability
Detection?</a> [<strong>CCF-C</strong>: 2022 IEEE 46th Annual Computers,
Software, and Applications Conference (COMPSAC)]</li>
<li><a
target="_blank" rel="noopener" href="https://www.usenix.org/conference/usenixsecurity22/presentation/li-song">Mining
Node.js Vulnerabilities via Object Dependence Graph and
Query</a>(<strong>CCF-A</strong>:31st USENIX Security Symposium
2022)</li>
<li><a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0167404822004072?via%3Dihub">MFXSS:
An effective XSS vulnerability detection method in JavaScript based on
multi-feature model</a>(<strong>CCF-B</strong>:Computers &amp;
Security)</li>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3488932.3497769">On
Measuring Vulnerable JavaScript Functions in the
Wild</a>(<strong>CCF-C:</strong>17th AsiaCCS 2022: Nagasaki, Japan)</li>
<li><a
target="_blank" rel="noopener" href="https://www.ndss-symposium.org/ndss-paper/fuzzilli-fuzzing-for-javascript-jit-compiler-vulnerabilities/">FUZZILLI:
Fuzzing for JavaScript JIT Compiler
Vulnerabilities</a>(<strong>CCF-A</strong>会议：NDSS 2023)</li>
<li><a
target="_blank" rel="noopener" href="https://www.ndss-symposium.org/ndss-paper/auto-draft-207/">Probe
the Proto: Measuring Client-Side Prototype Pollution Vulnerabilities of
One Million Real-world Websites</a>(<strong>CCF-A</strong>会议：NDSS
2022)</li>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3468264.3468542">Detecting
Node.js prototype pollution vulnerabilities via object lookup
analysis</a>(<strong>CCF-A</strong>:ESEC/SIGSOFT FSE 2021)</li>
<li><a
target="_blank" rel="noopener" href="https://www.computer.org/csdl/proceedings-article/sp/2023/933600b059/1NrbYrQrQ2I">Scaling
JavaScript Abstract Interpretation to Detect and Exploit Node.js
Taint-style Vulnerability</a>: <strong>CCF-A</strong>会议：IEEE S&amp;P
2023</li>
<li><a
target="_blank" rel="noopener" href="https://www.usenix.org/conference/14th-usenix-security-symposium/finding-security-vulnerabilities-java-applications-static">Finding
Security Vulnerabilities in Java Applications with Static
Analysis</a>（<strong>CCF-A:</strong>USENIX Security Symposium
2005）</li>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3554732">An In-depth Study
of Java Deserialization Remote-Code Execution Exploits and
Vulnerabilities.</a>(<strong>CCF-A</strong>:软件工程顶刊：ACM
Transactions on Software Engineering and Methodology, Volume 32)</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/10172888">Improving
Java Deserialization Gadget Chain Mining via Overriding-Guided Object
Generation</a>（程序语言<strong>CCF-A</strong>:2023 IEEE/ACM 45th
International Conference on Software Engineering (ICSE)）</li>
<li><code>A Composite Discover Method for Gadget Chains in Java Deserialization Vulnerability</code></li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/10202660">Tabby:
Automated Gadget Chain Detection for Java Deserialization
Vulnerabilities</a>（<strong>CCF-B</strong>会议：DSN2023）</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/10188756">Improving
Precision of Detecting Deserialization Vulnerabilities with Bytecode
Analysis</a>（计算机网络<strong>CCF-B</strong>:31st IWQoS 2023）</li>
<li><a
target="_blank" rel="noopener" href="https://secsys.fudan.edu.cn/ce/78/c26976a642680/page.htm">Efficient
Detection of Java Deserialization Gadget Chains via Bottom-up Gadget
Search and Dataflow-aided Payload
Construction</a>（<strong>CCF-A</strong>: IEEE S&amp;P）</li>
</ol>
<h3 id="section">2024-01-20</h3>
<h4 id="论文">论文</h4>
<ol type="1">
<li><a
target="_blank" rel="noopener" href="https://www.usenix.org/conference/14th-usenix-security-symposium/finding-security-vulnerabilities-java-applications-static">Finding
Security Vulnerabilities in Java Applications with Static
Analysis</a>（<strong>CCF-A:</strong>USENIX Security Symposium 2005）：
旧文重读</li>
</ol>
<h4 id="正文">正文</h4>
<ol type="1">
<li>Java<code>字节码级别</code>分析而不是在<code>源码级别</code>分析：The
use of <strong>bytecode-level analysis</strong> obviates the need for
the source code to be accessible. This is especially important
<strong>since</strong> libraries whose source is unavailable are used
extensively in Java applications.</li>
<li>应用于分析<strong>其他形式的字节码</strong>：Our approach can be
applied to other forms of bytecode such as MSIL, thereby enabling the
analysis of C# code [37]
<ol type="1">
<li>MISL: stands for Microsoft Intermediate Language, a bytecode format
that serves as a crucial step in the execution of C# code.</li>
</ol></li>
<li>precise context-sensitive pointer analysis</li>
<li><strong>Contributions</strong>
<ol type="1">
<li>A unified analysis framework：可以分析多种类型的漏洞</li>
<li>A powerful static analysis：
<ol type="1">
<li>utilizes fully <code>contextsensitive pointer analysis</code>
result</li>
<li>We improve the state of the art in pointer analysis by
<code>improving the objectnaming scheme</code>.</li>
</ol></li>
<li>A simple user interface
<ol type="1">
<li>Our system provides a GUI auditing interface implemented on top of
Eclipse, thus allowing users to perform security audits quickly during
program development</li>
</ol></li>
</ol></li>
</ol>
<h4 id="总结">总结</h4>
<ol type="1">
<li>这篇论文是顶会上使用静态分析技术研究java应用程序漏洞检测的鼻祖了，由于年代太久远了，看完开篇总述就没必要看了</li>
<li></li>
</ol>
<h3 id="section-1">2024-01-13</h3>
<ol type="1">
<li><p>Ja</p></li>
<li><p>va学习</p>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2024/01/13/hyperskill/#toc-heading-1">Reading
user's input with Scanner</a></li>
<li><a
href="https://jf710001011.github.io/2024/01/13/hyperskill/#toc-heading-2">Data
types and their sizes</a></li>
<li><a
href="https://jf710001011.github.io/2024/01/13/java-blackhorse/#toc-heading-1">Hello
Wordld</a></li>
<li><a
href="https://jf710001011.github.io/2024/01/13/java-blackhorse/#toc-heading-2">高级语言的编译运行</a></li>
<li><a
href="https://jf710001011.github.io/2024/01/13/java-blackhorse/#toc-heading-3">Jre和Jdk</a></li>
</ol></li>
<li><p>Tabby分析</p>
<ol type="1">
<li>项目结构分析，项目树，<a
href="https://jf710001011.github.io/2023/12/09/tabby-fen-xi/#toc-heading-2">项目结构</a></li>
</ol></li>
<li><p>总结</p>
<ol type="1">
<li>找到一种更有效分析这个框架的工具和分析方法</li>
</ol></li>
</ol>
<h3 id="section-2">2024-01-06</h3>
<h4 id="tabby框架学习">tabby框架学习</h4>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/12/09/tabby-fen-xi/#toc-heading-10">tabby/core/data/TabbyValue.java</a></li>
</ol>
<h4 id="论文-1">论文</h4>
<ol type="1">
<li><a
target="_blank" rel="noopener" href="https://secsys.fudan.edu.cn/ce/78/c26976a642680/page.htm">Efficient
Detection of Java Deserialization Gadget Chains via Bottom-up Gadget
Search and Dataflow-aided Payload
Construction</a>（<strong>CCF-A</strong>: IEEE S&amp;P）</li>
</ol>
<h4 id="正文-1">正文</h4>
<ol type="1">
<li>序列化和反序列化的意义：Java serialization and deserialization
greatly facilitate the cooperation and collaboration of different Java
systems (e.g., server and client), allowing different Java programs to
conveniently <strong>exchange and share data and code</strong></li>
<li><code>Java Object Injection (JOI).</code></li>
<li>反序列化漏洞的危害：
<ol type="1">
<li>remote code execution (RCE)</li>
<li>denial of service (DoS)</li>
</ol></li>
<li>现状：<code>ODDFuzz</code> statically searches for possible gadgets
via a Depth First Search (DFS) strategy, and then dynamically fuzzes the
target program as a greybox for verifying gadget chains</li>
<li>top-down static approach:path explosion</li>
<li>两个指标：effectiveness and efficiency</li>
<li>ODDFuzz additionally introduced <code>dynamic fuzzing</code> for
reducing false positives</li>
<li>现存问题
<ol type="1">
<li>path explosion</li>
<li>In particular, the finegrained data flows between
<code>different object fields</code> in each gadget, leading to the
imprecision of object structure and thus an incorrect payload.</li>
</ol></li>
<li>JDD (Java Deserialization Vulnerability Detector)的特点
<ol type="1">
<li>JDD first searches for possible <code>gadget fragments</code> and
then chains fragments together from sinks to sources.
<ol type="1">
<li>观察1： a <code>top-down search</code> repeats the analysis of the
same low-level gadget fragment when a top-level gadget changes, leading
to a huge redundancy and a waste of analysis time</li>
<li>解决：bottom-up search <code>reuse existing gadget fragments</code>
discovered in previous vulnerabilities, which further speeds up the
search process.</li>
</ol></li>
<li>object <code>field relations</code> via a novel data structure,
called Injection Object Construction Diagram (IOCD)</li>
</ol></li>
<li>summarize the contributions
<ol type="1">
<li>JDD solves the <code>path explosion problem</code> of static search
for chained gadgets via a <code>bottom-up approach</code> that discovers
intermediate gadget fragments and then chains them together from sinks
to sources</li>
<li>Injection Object Construction Diagram (IOCD)</li>
<li>Java Naming and Directory Interface (<code>JNDI</code>) injection is
a commonly used technique in JOI attacks</li>
</ol></li>
<li>JDD的两个目标
<ol type="1">
<li>Uses static analysis to find potential gadget chains in the victim
server</li>
<li>Dynamically generates exploitable injection objects to verify the
exploitability of gadget chains</li>
</ol></li>
<li>Challenge I: Static Path
Explosion：？我能理解DFS重复分析fragment，也能理解自上而下的分析方式可以解决这个问题;<strong>但是bottom-up的实际路径计算方式不能理解</strong>
<ol type="1">
<li>top-down(DFS):<img
src="https://s2.loli.net/2024/01/06/VNc3ZrjFJ4S8YPi.png"
alt="image-20240106025500862" /></li>
<li>bottom-up<img
src="https://s2.loli.net/2024/01/06/8AWJjNcE3lnTeBU.png"
alt="image-20240106025608557" /></li>
</ol></li>
<li>Challenge II:
注入对象涉及变量的层次关系：不能仅仅认为是继承的级别关系，涉及的两个变量也可能是平行并列的关系
<ol type="1">
<li>作者为此而实现了：<code>Dataflow-aided Construction of Injection Object Construction Diagram (IOCD)</code>.</li>
</ol></li>
<li>Identifying Deserialization Entry Points
<ol type="1">
<li>deserialization methods provided by Java language,e.g.,
readObjectNoData(), readExternal() and readObject()</li>
<li>interfaces provided by popular Java deserialization protocols, e.g.,
Map.put() for Hessian protocol.</li>
</ol></li>
<li>Related work
<ol type="1">
<li>GadgetInspector</li>
<li>Tabby</li>
<li>SerHybrid [4] proposed to automate the verification of exploitable
gadget chains through the construction of <code>heap abstractions</code>
for generating injection objects.</li>
<li><code>GCMiner</code> [1] incorporated an overriding-guided object
generation strategy to automate verification during fuzzing.</li>
<li>ODDFuzz</li>
<li>black-box scanning tools
<ol type="1">
<li>Marshalsec [32]</li>
<li>Java Deserialization Scanner</li>
</ol></li>
</ol></li>
</ol>
<h4 id="总结-1">总结</h4>
<ol type="1">
<li>总的来说，这类研究与纯静态分析是有很大不同的。看完这篇论文，能想到与之最像的那必定是文中多次提到的
<code>ODDFUZZ</code>
<ol type="1">
<li>JDD与ODDFUZZ都是采用了混合分析（静态分析+动态分析）的方式去检测反序列化漏洞，手法非常类似
<ol type="1">
<li>静态分析：
<ol type="1">
<li>建立图</li>
<li>污点分析寻找利用链</li>
</ol></li>
<li>动态分析（<strong>并没有系统学习过</strong>）：
<ol type="1">
<li>可能需要借助一定的数据结构（例如本文IOCD）</li>
<li>生成注入对象，触发利用链验证利用链的有效性，减少假阴性</li>
</ol></li>
</ol></li>
</ol></li>
<li>我着重阅读了<strong>静态分析</strong>部分
<ol type="1">
<li><strong>疑惑1</strong>：类层次结构（嵌入型还是并列型）研究的意义：我猜测就是类似指针分析的效果，提升分析的精度</li>
<li>创新之处是：
<ol type="1">
<li>自底向上的分析方法，解决DFS产生的路径爆炸问题</li>
<li>提出了Gadget chain
fragment的概念（非常有想法），并最终将fragment组合成一条完整的gadget
chain</li>
</ol></li>
</ol></li>
<li>一图总结本文<img
src="https://s2.loli.net/2024/01/06/lH61cKJqYy5GX9R.png"
alt="image-20240106061533385" />
<ol type="1">
<li>从目标程序寻找fragment（未分析过）+从已经分析出的fragment（重复使用分析结果）得出fragment
collection</li>
<li>将fragment 组合成利用链</li>
<li>收集约束：存在一定<strong>疑惑</strong>，暂时的理解是自底向上分析时，要触发当前方法因该满足的<strong>条件</strong></li>
<li>生成注入对象（暂时不清楚原理）</li>
<li>利用IOCD数据结构辅助验证利用链的有效性</li>
</ol></li>
<li>动态分析（也称模糊测试
<code>fuzzing</code>），在漏洞检测中确实扮演着非常关键的角色，对于静态分析研究者而言，是一种拓宽思路的技术。但我的研究仍暂以静态分析为重点</li>
</ol>
<h3 id="section-3">2023-12-30</h3>
<h4 id="自动化检测框架学习">自动化检测框架学习</h4>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/12/09/java/#toc-heading-57">Java
网络编程</a>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/12/09/java/#toc-heading-58">网络编程基础</a></li>
<li><a
href="https://jf710001011.github.io/2023/12/09/java/#toc-heading-59">网络编程的核心套接字Socket</a></li>
<li><a
href="https://jf710001011.github.io/2023/12/09/java/#toc-heading-60">Socket实现Http服务器</a></li>
</ol></li>
<li><a
href="https://jf710001011.github.io/2023/12/09/tabby-fen-xi/#toc-heading-9">tabby/core/data/TabbySt0atus.java</a></li>
</ol>
<h3 id="section-4">2023-12-23</h3>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/12/09/java/#toc-heading-52">新特性</a>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/12/09/java/#toc-heading-53">Java8
Stream 流</a></li>
<li><a
href="https://jf710001011.github.io/2023/12/09/java/#toc-heading-54">Optional最佳指南</a></li>
<li><a
href="https://jf710001011.github.io/2023/12/09/java/#toc-heading-55">lambda
表达式</a></li>
<li><a
href="https://jf710001011.github.io/2023/12/09/java/#toc-heading-56">Java14
新特性</a></li>
</ol></li>
<li><a
href="https://jf710001011.github.io/2023/12/09/static-analysis-ii/#toc-heading-10">格理论下的数据流分析基础</a></li>
</ol>
<h3 id="section-5">2023-12-16</h3>
<ol type="1">
<li>学习：<a
href="https://jf710001011.github.io/2023/12/09/java/#toc-heading-43">常用工具类</a></li>
<li>学习：<a
href="https://jf710001011.github.io/2023/12/09/static-analysis-ii/#toc-heading-4">数据流分析及其应用</a></li>
</ol>
<h3 id="section-6">2023-12-09</h3>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/12/09/java/#toc-heading-40">Java异常机制</a><img
src="https://s2.loli.net/2023/12/10/KSwbyaQUW3T6ZVM.png"
alt="image-20231209225321575" /></li>
<li><a
href="https://jf710001011.github.io/2023/12/09/static-analysis-ii/">静态分析再研究</a><img
src="https://raw.githubusercontent.com/Jf710001011/pictureBed/main/img/image-20231209225337843.png"
alt="image-20231209225337843" /></li>
</ol>
<h3 id="section-7">2023-12-02</h3>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/08/26/java/#toc-heading-36">Java
IO</a></li>
<li>tabby 源码分析
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/10/28/tabby-fen-xi/#toc-heading-7">tabby/core/data/FileLocation.java</a></li>
<li><a
href="https://jf710001011.github.io/2023/10/28/tabby-fen-xi/#toc-heading-8">tabby/core/data/TabbyRule.java</a></li>
</ol></li>
</ol>
<h3 id="section-8">2023-11-19</h3>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/10/28/tabby-fen-xi/#toc-heading-9">tabby分析</a>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/10/28/tabby-fen-xi/#toc-heading-2">run.sh</a></li>
<li><a
href="https://jf710001011.github.io/2023/10/28/tabby-fen-xi/#toc-heading-4">tabby/core/Analyser.java</a></li>
<li><a
href="https://jf710001011.github.io/2023/10/28/tabby-fen-xi/#toc-heading-5">tabby/core/scanner/CallGraphScanner.java</a></li>
</ol></li>
<li>找到一个不错的分析思路<img
src="https://s2.loli.net/2023/11/18/w4cLOvbhnT8qfPR.png"
alt="image-20231118230811392" /></li>
</ol>
<h3 id="section-9">2023-11-11</h3>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2022/09/05/academic-progress/">Tabby/core/container分析</a><img
src="https://s2.loli.net/2023/11/12/bZ4omvGEiWakn1s.png"
alt="image-20231112124458950" /></li>
</ol>
<h4 id="总结-2">总结</h4>
<ol type="1">
<li>首先是对数据（类、方法和类之间的关系）的存储，其次是对数据的使用，内存中查找不到，则从Neo4j图数据库中读取</li>
<li>对规则的存储和读取，包括类规则和方法规则</li>
</ol>
<h3 id="section-10">2023-11-04</h3>
<h4 id="tabby项目分析">Tabby项目分析</h4>
<ol type="1">
<li>本周主要分析的是：项目的<strong>核心模块：</strong>负责收集待分析的文件或依赖库，解析
Java 代码，生成 Soot 模型，进行污点分析，发现可能存在的漏洞
<ol type="1">
<li>tabby 的核心模块是 Tabby
的核心功能所在。该模块主要由以下几个类组成：
<ul>
<li><strong>FileCollector：</strong>负责收集待分析的文件或依赖库。</li>
<li><strong>Parser：</strong>负责解析 Java 代码，生成 Soot 模型。</li>
<li><strong>TaintAnalysis：</strong>负责进行污点分析，发现可能存在的漏洞。</li>
</ul></li>
</ol></li>
<li><a
href="https://jf710001011.github.io/2023/10/28/tabby-fen-xi/#toc-heading-6">笔记记录</a></li>
</ol>
<h4 id="总结-3">总结</h4>
<ol type="1">
<li><code>Tabby</code> 的设计思路主要有以下几点：
<ul>
<li>基于 Soot 实现，支持 Java 代码的静态分析。</li>
<li>支持多种漏洞挖掘方法，包括反序列化链挖掘、信息泄露检测、代码漏洞检测等。</li>
<li>支持多种输出格式，包括 HTML、CSV 等</li>
</ul></li>
<li>Tabby 的代码组织主要分为以下几个模块：
<ul>
<li><strong>核心模块：</strong>负责收集待分析的文件或依赖库，解析 Java
代码，生成 Soot 模型，进行污点分析，发现可能存在的漏洞。</li>
<li><strong>输出模块：</strong>负责生成报告，展示漏洞信息。</li>
<li><strong>配置模块：</strong>负责配置 Tabby 的运行参数。</li>
</ul></li>
<li>写出这样的项目真的挺难啊：有思路和方法，但是实现出来不容易。</li>
</ol>
<h3 id="section-11">2023-10-28</h3>
<h4 id="论文1">论文1</h4>
<ol type="1">
<li><a
target="_blank" rel="noopener" href="https://www.infocomm-journal.com/cjnis/CN/10.11959/j.issn.2096-109x.2022009">基于混合分析的Java反序列化利用链挖掘方法</a></li>
</ol>
<h5 id="正文-2">正文</h5>
<ol type="1">
<li>反序列化漏洞三要素：
<ol type="1">
<li>污染源：攻击者可控的变量；</li>
<li>入口函数：反序列化时自动调用的接口函数；</li>
<li>危险函数：能够执行命令的函数。</li>
</ol></li>
<li>另外，如果只通过声明类型构造简单调用图，然后在调用图中寻找从入口函数到危险函数的调用链作为反序列化利用链。这种做法将存在大量的误报：
<ol type="1">
<li><strong>一是</strong>因为根据声明类型构造的调用图不准确，调用关系在实际运行的过程中可能不存在；</li>
<li><strong>二是</strong>即使调用链存在，如果污点源无法传播到危险函数，调用链也将无法利用</li>
</ol></li>
</ol>
<h4 id="tabby项目分析-1">Tabby项目分析</h4>
<ol type="1">
<li>源自这篇论文：<a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/10202660">Tabby: Automated
Gadget Chain Detection for Java Deserialization
Vulnerabilities</a>（<strong>CCF-B</strong>会议：DSN2023）</li>
<li>代码中的<strong>注释</strong>即为我的分析过程</li>
<li><a
href="https://jf710001011.github.io/2023/10/28/tabby-fen-xi/#toc-heading-1">Tabby分析-记录</a></li>
</ol>
<h4 id="总结-4">总结</h4>
<ol type="1">
<li>本周主要是开启对唯一一篇CCF-B中的<strong>项目源码进行分析</strong>
<ol type="1">
<li>全部自己实现是个非常困难的事，需要个参照</li>
<li>这是第一次对整个项目进行分析</li>
</ol></li>
<li>下周结束这个项目分析</li>
</ol>
<h3 id="section-12">2023-10-21</h3>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/08/26/java/#toc-heading-30">Java反序列化漏洞底层探究
记录</a>，包括以下内容<img
src="https://s2.loli.net/2023/10/21/etCgaulSrUR7PMz.png"
alt="image-20231021225016323" />
<ol type="1">
<li>两种方式触发漏洞</li>
<li>利用反射实现利用链</li>
<li>序列化和反序列化流程分析</li>
<li>经典利用链分析</li>
</ol></li>
</ol>
<h4 id="总结-5">总结</h4>
<ol type="1">
<li>探究底层原理发现了更多漏洞检测的细节问题，主要是针对这些问题去改进</li>
<li>我的一个<strong>新想法</strong>：一条完整的利用链包括
<code>source()-&gt;中间函数--&gt;sink()</code>
<ol type="1">
<li>一对
<code>(source,sink)</code>,有非常多的路线，而我们只是找出有效的利用链。而从source()出发经过的各个中间方法我们无法确定能否到达source,<strong>反其道行之</strong>从sink()出发,逐步向source靠近，将这些可达sink的函数进行<strong>标记</strong>，就可以减少无效的利用链分析</li>
<li>正如1中所述，主要需要考虑从
<code>sink向上标记到第几层</code>，总的来说
<code>前向和后向分析</code>可以同时进行提高效率</li>
</ol></li>
</ol>
<h3 id="section-13">2023-10-14</h3>
<h4 id="论文1-1">论文1</h4>
<ol type="1">
<li><code>A Composite Discover Method for Gadget Chains in Java Deserialization Vulnerability</code>（10th
QuASoQ / 6th SEED@APSEC 2022: Virtual）</li>
</ol>
<h5 id="正文-3">正文</h5>
<ol type="1">
<li><p>对基于指纹检测的Java反序列化漏洞检测方法</p>
<p>Java反序列化过程可能存在安全漏洞,通过构造恶意序列化数据可以实施远程代码执行等攻击。为了检测这种漏洞,可以使用基于指纹的方法。</p>
<p>基本思路是收集已知的可利用的反序列化gadget代码特征,构建一个
<code>指纹库</code>。在运行时监控应用的反序列化流量,用指纹库去匹配查看是否包含已知的危险gadget。<strong>匹配到</strong>则表明可能存在可利用的反序列化漏洞。</p>
<p>这种方法的优点是可以快速检测已知模式的漏洞利用,不需要复杂的代码审计。缺点是指纹库需要维护更新,对未知的0day攻击效果不佳。</p></li>
<li><p>3个漏洞检测工具</p>
<ol type="1">
<li><strong>Ysoserial:</strong></li>
<li><strong>Marshalsec:</strong>
Marshalsec主要用于生成有效负载，但不包括小工具链的发现功能。</li>
<li><strong>Java Deserialization Scanner:</strong>
这是一个用于检测Java反序列化漏洞的插件，它可以与广泛使用的渗透测试工具Burp
Suite集成。该插件利用Ysoserial生成有效负载，用于对反序列化漏洞的目标进行渗透测试和漏洞验证。</li>
</ol></li>
<li><p>Gadget Inspector</p></li>
<li><p><code>fingerprinting-based detection can only detect the presence of known gadget chains in the program,but not unknown gadget chains in the program.</code></p></li>
<li><p><code>In 2020, Rasheed[13] proposed a hybrid analysis strategy to avoid false positives. It uses static analysis results as a guide for fuzzing.</code></p></li>
</ol>
<h4 id="论文2">论文2</h4>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=wPbW6zQ52w8">Automated
Discovery of Deserialization Gadget Chains</a></li>
</ol>
<h5 id="正文-4">正文</h5>
<ol type="1">
<li><p><code>ysoserial</code> project and
<code>Marshalsec</code>:<code>is a similar project which supports a wider breadth of              12 deserialization libraries, but is again a tool which largely includes known gadget chains.</code></p></li>
<li><p>The <code>NCC Group Burp Pluginis</code> another 14 Burp Suite
plugin but which is mainly based on the JSON payloads from Muñoz and
Mirosh’s work.</p></li>
<li><p><code>joogle</code></p></li>
<li><p><code>The ASM (Objectweb ASM)</code> library is a popular and
widely-used Java bytecode manipulation framework. It allows developers
to analyze and modify Java classes at the bytecode level. ASM provides a
low-level, efficient, and flexible way to work with Java class files,
making it an essential tool for various applications, including:</p>
<ol type="1">
<li><strong>Bytecode Generation:</strong> Developers can use ASM to
generate Java class files programmatically. This is useful for code
generation, code transformation, and dynamic class creation.</li>
<li><strong>Code Analysis:</strong> ASM can be used to analyze existing
Java class files. It allows you to inspect the structure of classes,
methods, fields, and instructions, making it valuable for tools like
code analyzers and documentation generators.</li>
<li><strong>Code Transformation:</strong> ASM enables the modification
of existing class files, allowing you to inject code, add or remove
methods, and change class structures. This is often used in frameworks
and libraries that need to instrument or modify classes during
runtime.</li>
<li><strong>Performance Enhancements:</strong> Some applications use ASM
to optimize Java bytecode for better performance. This can include
inlining, method call optimizations, and other bytecode-level
improvements.</li>
<li><strong>Java Agents:</strong> ASM is commonly used in Java agents,
which are Java programs that can be dynamically attach to running Java
applications to instrument and monitor them. Agents can be used for
profiling, logging, and other runtime analysis.</li>
<li><strong>Aspect-Oriented Programming (AOP):</strong> ASM is sometimes
used in AOP frameworks to weave aspect code into classes at the bytecode
level. This allows developers to separate cross-cutting concerns, such
as logging or security, from the main application logic.</li>
</ol>
<p>ASM is known for its small footprint, high performance, and the
ability to work with different versions of Java class files. It offers
both a simple and a more complex API, making it suitable for a wide
range of use cases, from simple class file generation to advanced
bytecode manipulation.</p>
<p>If you are working on projects that require Java bytecode
manipulation, ASM is a powerful and versatile library that can help you
achieve your goals. It's often used in conjunction with other tools and
libraries for specific tasks like code generation, optimization, or
instrumentation.</p></li>
<li><p>How Gadget Inspector <strong>Works</strong></p>
<ol type="1">
<li>Class and Method Hierarchy Enumeration</li>
</ol></li>
</ol>
<h4 id="总结-6">总结</h4>
<ol type="1">
<li><p>在查询语言上进行优化使用 <code>Codeql</code>:</p>
<p>CodeQL查询语言是CodeQL用于编写代码分析查询规则的语言,具有以下主要特点:</p>
<ol type="1">
<li>基于逻辑查询:查询以类似SQL的逻辑语句组织,例如选择、联接等。</li>
<li>支持面向对象:可以直接作用于类、对象、方法等。</li>
<li>路径敏感:可以精确捕获代码执行路径。</li>
<li>数据流分析:可以跟踪数据流动,寻找问题。</li>
<li>支持聚合:可以聚合和分组结果。</li>
<li>丰富的APIs:提供访问AST、控制流图、调用关系等程序结构信息的API。</li>
<li>可扩展:可以导入其他语言写的库。</li>
<li>可组合:查询可以组合使用。</li>
<li>注释支持:可以在查询中加入注释说明。</li>
<li>良好的IDE支持:如VS Code插件。</li>
</ol></li>
<li><p>一个检测工具需要满足的<strong>特点</strong>参考-设计指南：</p>
<ol type="1">
<li>确定类路径上存在的 gadget
链漏洞：工具应该能够检测类路径中可能存在的潜在 gadget 链漏洞。</li>
<li>评估漏洞的影响：工具应该能够评估这些漏洞的影响，包括可能导致的安全问题，如
RCE、SSRF 和 DoS。</li>
<li>提供保守的影响评估：工具应该提供限制性的、谨慎的漏洞影响评估，以确保不低估漏洞的危害程度。</li>
<li>适用于整个类路径：工具应该能够轻松操作应用程序的整个类路径，无论应用程序中使用的编程语言是什么。如果应用程序使用多种源语言，工具应该能够在
Java 字节码上运行。</li>
<li>理解不同反序列化库：工具应该能够理解和适应不同的反序列化库，了解每个库对
gadget 链的限制，以便更好地检测漏洞。</li>
</ol></li>
<li><p>下一个计划：</p>
<ol type="1">
<li>研究几个经典的反序列化漏洞案例，把握漏洞特征，针对特定的问题，设计对应的解决策略</li>
<li>重点在设计方法调用图和数据流图上</li>
</ol></li>
</ol>
<h3 id="section-14">2023-10-07</h3>
<h4 id="java反射">Java反射</h4>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/08/26/java/#toc-heading-29">JAVA反射记录</a><img
src="https://s2.loli.net/2023/10/07/W6hYOL2gpAGuaZ3.png"
alt="image-20231007221736659" /></li>
<li>JAVA反射是JAVA一个非常重要的特性，机制复杂，出现安全的问题也更加复杂，是一个非常值得关注的点</li>
</ol>
<h4 id="论文1-2">论文1</h4>
<ol type="1">
<li><p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/10188756">Improving
Precision of Detecting Deserialization Vulnerabilities with Bytecode
Analysis</a>（计算机网络<strong>CCF-B</strong>:31st IWQoS 2023）</p>
<ol type="1">
<li><p>作者：广州大学网络空间安全学院</p></li>
<li><p>Index Terms：</p>
<p>Security and Protection,</p>
<p>Web Servers,</p>
<p>Program Analysis,</p>
<p>Java.</p></li>
</ol></li>
</ol>
<h5 id="正文-5">正文</h5>
<ol type="1">
<li><p><code>JNDI（Java Naming and Directory Interface）</code>注入是一种安全漏洞，通常出现在Java应用程序中，特别是那些使用JNDI来连接和管理命名和目录服务的应用程序中。JNDI是Java中用于访问命名和目录服务的API，允许应用程序查找和访问各种资源，如数据库连接、消息队列等。</p>
<p>JNDI注入
<code>发生在</code>攻击者能够控制或影响JNDI查找的输入时。攻击者可以通过恶意构造的JNDI名称或URL，迫使应用程序加载和执行不安全的类或代码。这可能导致严重的安全问题，包括远程代码执行、信息泄露或拒绝服务攻击。</p>
<p>通常，JNDI注入漏洞的利用方式包括将恶意的JNDI名称传递给应用程序，然后应用程序试图查找这个名称，最终执行了攻击者控制的恶意代码。</p></li>
<li><p><code>Static analysis based on bytecode analysis, such as GadgetInspector [1] and GadgetSearch [2], is the most popular measure to detect deserialization vulnerabilities</code></p></li>
<li><p><code>Java反射（Reflection）</code>是一种高级编程技术，允许在运行时检查、获取和操作类、对象、方法、字段等程序元素的信息。反射提供了一种强大的机制，使开发人员能够在运行时获取类的信息、创建对象、调用方法和访问字段，而不需要在编译时知道这些信息。</p>
<p>以下是Java反射的一些关键概念和用法：</p>
<ol type="1">
<li><strong>Class类：</strong> 在Java中，每个类都有一个对应的
<code>Class</code>对象，用于表示类的信息。你可以使用
<code>Class</code>类的静态方法 <code>forName</code>来获取一个类的
<code>Class</code>对象。</li>
<li><strong>获取类信息：</strong> 通过
<code>Class</code>对象，你可以获取类的名称、父类、接口、构造方法、方法、字段等信息。这使得你可以在运行时了解类的结构。</li>
<li><strong>创建对象：</strong>
反射允许你在运行时创建对象，即使你不知道类的名称，也可以使用
<code>Class</code>对象的 <code>newInstance</code>方法来实现。</li>
<li><strong>调用方法：</strong>
使用反射，你可以在运行时调用类的方法。<code>Method</code>类表示一个方法，你可以使用它来调用方法，传递参数，并获取方法的返回值。</li>
<li><strong>访问字段：</strong>
通过反射，你可以获取和修改对象的字段值。<code>Field</code>类表示一个字段，你可以使用它来读取和写入字段的值。</li>
<li><strong>访问构造方法：</strong>
使用反射，你可以获取类的构造方法并创建对象的实例。<code>Constructor</code>类表示一个构造方法，你可以使用它来实例化对象。</li>
<li><strong>动态代理：</strong>
反射还用于实现动态代理，允许你在运行时创建代理对象来控制对目标对象的访问。</li>
<li><strong>注解处理：</strong>
反射也常用于处理注解，你可以通过反射获取类、方法或字段上的注解，并根据注解的信息执行相应的逻辑。</li>
</ol>
<p>反射通常在某些高级应用程序、框架和工具中使用，例如ORM（对象关系映射）、依赖注入、动态代码生成等。</p></li>
<li><p><code>代理对象（Proxy Object）</code>是在软件设计中常用的一种模式，用于
<code>控制</code>对其他对象的访问。代理对象充当了其他对象的接口，以控制对这些对象的访问，通常用于添加额外的功能或控制访问权限。代理对象可以在不改变原始对象的情况下对其进行增强或包装。</p>
<p>代理对象通常有以下几种类型：</p>
<ol type="1">
<li><strong>静态代理：</strong>
在编译时创建的代理对象，开发人员需要手动编写代理类。静态代理通常用于实现特定功能，如日志记录或权限控制。</li>
<li><strong>动态代理：</strong>
在运行时创建的代理对象，无需手动编写代理类，可以根据需要动态生成。Java中的动态代理通常使用
<code>java.lang.reflect.Proxy</code>类和
<code>InvocationHandler</code>接口实现。</li>
<li><strong>远程代理：</strong>
用于在不同地址空间中控制对远程对象的访问。远程代理允许本地程序像访问本地对象一样访问远程对象。</li>
</ol>
<p>代理对象的一些常见应用场景包括：</p>
<ul>
<li><strong>AOP（面向切面编程）：</strong>
代理对象可以用于实现横切关注点，例如日志记录、性能监控、事务管理等，而不需要在每个方法中编写相同的代码。</li>
<li><strong>延迟加载：</strong>
代理对象可以用于延迟加载对象，只有在需要时才真正创建和初始化对象，以提高性能。</li>
<li><strong>权限控制：</strong>
代理对象可以用于控制对某些操作的访问权限，根据用户的角色或权限级别来限制操作。</li>
<li><strong>远程调用：</strong>
代理对象可用于在分布式系统中执行远程方法调用，以便在不同的计算机上执行操作。</li>
</ul>
<p>代理对象的设计模式有助于提高代码的可维护性和可扩展性，因为它们将关注点分离并允许在不影响原始对象的情况下添加或修改功能。代理对象通常是面向对象编程中的重要概念，经常与其他设计模式如装饰器模式、适配器模式等一起使用。</p></li>
<li><p><strong>问题</strong>：这个漏洞是因为在反序列化过程中，动态代理类
<code>AnnotationInvocationHandler</code>中的
<code>equalsImpl</code>()方法使用了反射，但成员"memberMethods"被标记为"<code>transient</code>"，反序列化无法控制它。这导致了一些静态分析工具认为这种反射是不受控制的，可能会导致潜在的安全问题。</p></li>
<li><p><code>JRE7u21</code> deserialization vulnerability.</p></li>
<li><p>那些不会推断本地变量和参数类型的常规静态分析工具会错误地将这样具有不正确参数的反射视为可控制的反射，从而产生许多错误结果</p></li>
</ol>
<h4 id="总结-7">总结</h4>
<ol type="1">
<li><p><code>JAVA反射</code>
拓宽了我的思路，能够发现更多的安全问题和提供了更多改进优化的思路</p></li>
<li><p>本文注意到了<strong>三个问题</strong>并提出了三个
<code>提高检测精度</code>的方法</p>
<ol type="1">
<li><p><code>CROSS-FUNCTION MEMBERS DATA FLOW TRACKING</code></p>
<p><strong>P</strong>:在JRE7u21反序列化漏洞中，成员"memberMethods"具有"transient"修饰符，这在反序列化中是不可控制的，因此常规的静态分析认为这个反射不可控制。</p>
<p><strong>S</strong>:在分析每个方法的数据流之前，需要初始化污点源（taint
sources）和一个成员数据流表格。这个表格用于保存在执行过程中对象成员的变化以及谁改变了这些成员的信息</p></li>
<li><p><code>LOCAL VARIABLES AND ARGUMENTS TYPES INFERENCE</code></p>
<p>P:动态反射需要特定类型的参数数组来执行危险操作，而常规静态分析工具如果无法正确推断本地变量和参数的类型，可能会误判反射为可控制的</p>
<p>S:在操作栈和表中的每个元素中保存
<code>类型信息</code>,包括确切类型和可能类型</p></li>
<li><p><code>CALL CHAIN SUBJECT INFERENCE BASED ON INHERITANCE RELATIONSHIPS</code></p>
<p><strong>P</strong>:如果存在一个调用链，其中在子类A、超类和子类B之间存在"this"或"super"方法调用，而且类A和类B之间没有继承关系，那么这个调用链可以被认为是不可能存在的调用链。</p>
<p><strong>S</strong>:
在方法调用中确定继承关系，剔除无效的调用链</p></li>
</ol></li>
<li><p>另一方面在研究一些静态分析工具的 <code>源码</code></p></li>
</ol>
<h3 id="section-15">2023-09-30</h3>
<h4 id="论文信息">论文信息</h4>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/10202660">Tabby:
Automated Gadget Chain Detection for Java Deserialization
Vulnerabilities</a>（<strong>CCF-B</strong>会议：DSN2023）<img
src="https://s2.loli.net/2023/09/30/7pMQi4mDtWCb5P8.png"
alt="image-20230930164833918" /></li>
</ol>
<h4 id="正文-6">正文</h4>
<h5 id="background">background</h5>
<ol type="1">
<li><p>Existing state-of-the-art analysis tools (e.g.,
<code>Spotbugs</code> [8], <code>CodeQL</code> [9])</p></li>
<li><p><strong>难点</strong>：</p>
<ol type="1">
<li><strong>控制流难以追踪</strong>：针对Java反序列化漏洞，其中一个根本原因是难以追踪控制流。与其他漏洞（如SQL注入或XSS）不同，无法仅仅依靠输入分析来检测漏洞。必须关注数据在输入后传递到源方法后的控制流，以确定是否会执行到危险的汇聚方法。这种控制流的复杂性增加了漏洞的发现和分析难度。</li>
<li><strong>多样性和复杂性</strong>：另一个根本原因是Java反序列化漏洞的多样性和复杂性。利用这些漏洞需要构造复杂的“小工具链”（gadget
chain），这些链由许多类对象的巧妙组合组成。由于Java的多态性和继承机制，存在大量潜在的小工具链。这增加了查找和利用这些漏洞的复杂性。同时，现有的分析工具通常无法有效地处理这些库中的漏洞，因为这些库通常非常广泛且数量众多。</li>
<li>此外，研究人员通常在手动追踪小工具链或
<code>自定义</code>现有工具方面面临困难，因为后者要么不提供对自定义分析的支持，要么要求对每个新的自定义都进行源代码的重复分析。此外，自定义分析通常需要精细的调整，当需要为每个自定义重新分析源代码时，这将变得
<code>耗时且容易出错</code>。因此，一个重大的技术挑战在于创建中间
<code>数据结构</code>，可以存储所有潜在数据并促进多次自定义重新分析。我们对这一挑战的解决方案是使用代码属性图构建一个中间数据结构。</li>
</ol></li>
<li><p><code>RPC(Remote Procedure Call)</code>即远程过程调用,是一种进程间通信方式,允许客户机程序调用服务端程序的函数或者过程,具有以下主要特征:</p>
<ol type="1">
<li>客户机可以像调用本地函数一样调用服务器端的函数或过程,不需要了解底层通信细节。</li>
<li>RPC隐藏了底层的网络通信,数据序列化,使得分布式计算透明化。</li>
<li>服务器端通过Skelton(存根函数)接收函数调用,执行函数后将结果返回客户端。</li>
<li>常用的RPC框架有gRPC, Thrift, Dubbo等。</li>
<li>RPC需要解决网络通信,序列化,目标查找,权限等多个方面的问题。</li>
<li>RPC的主要优势是对分布式通信进行封装抽象,调用远程函数像调用本地函数一样简单。</li>
<li>但RPC也存在额外开销,不宜用于对性能要求极高的场景。</li>
</ol></li>
<li><p>数据结构中存在的<strong>问题</strong></p>
<ol type="1">
<li>The semantic information extracted during the analysis cannot be
reused.</li>
</ol>
<p><strong>解决</strong>：图数据库。The introduction of graph databases
splits the static program analysis process into two parts: semantic
information extraction and specific vulnerability pattern
identification</p></li>
</ol>
<hr />
<h5 id="tabbydesign-and-implementation">TABBYDESIGN AND
IMPLEMENTATION</h5>
<ol type="1">
<li>our work’s <strong>technical challenge</strong> is to create
intermediate data structures that store all potential data. To overcome
this, we propose a novel data structure based on
<code>Code Property Graph (CPG)</code>, which involves converting Java
code into graph nodes and edges and storing the results in Neo4j.</li>
<li>we developed a <code>controllability analysis algorithm</code>
(detailed in §III-C) to help construct the CPG.</li>
</ol>
<h4 id="总结-8">总结</h4>
<ol type="1">
<li><p>一图总结Tabby工作流程<img
src="https://s2.loli.net/2023/10/01/WroAZShb8iF9R5X.png"
alt="image-20231001151759302" /></p></li>
<li><p>设计思路</p>
<ol type="1">
<li><p>首先构建
<code>对象关系图（ORG）</code>、<code>方法调用图MCG、方法别名图（MAG）</code>,在此基础构建
<code>代码属性图（CPG）</code></p></li>
<li><p>在 <code>方法调用图（MCG）</code>中，使用
<code>可控性分析算法</code>,生成更精确的
<code>Precise Call Graph (PCG)</code></p>
<p>这个思路跟我之前想的一样：就是对数据结构进行合理化的调整，使得这个图提供更多我们需要的信息，移除不必要的信息</p></li>
<li><p>非常创新的一点在于它的三个算法,提高了寻找漏洞的
<code>精确性</code>：可控性算法，Expander算法，Evaluator算法</p>
<ol type="1">
<li><code>污染位置（Polluted Position）</code>：是CALL关系边的一个数组属性，用于表示方法调用者和方法参数的
<code>可控性权重</code>。这个属性用于衡量方法调用的
<code>污染程度</code>，即哪些部分可能受到不可信输入或变量污染的影响。在反序列化漏洞分析中，PP属性对于评估方法调用的风险和潜在漏洞非常重要。它帮助确定哪些参数或方法调用者需要受到额外的关注，以识别潜在的漏洞。</li>
<li><code>触发条件（Trigger Condition）</code>：是
<code>汇聚方法</code>的一个数组属性，<strong>表示必须可控的参数以达到攻击效果</strong>。触发条件属性定义了在攻击效果触发时，必须满足的参数条件。这些条件通常用于确定攻击是否能够成功执行，以及哪些参数的可控性对于攻击效果至关重要。触发条件属性在分析和查找漏洞时起到关键作用，帮助确定哪些参数需要特别关注和保护，以防止潜在的攻击。</li>
<li>为了充分以上两个属性，设计了两个算法：
<ol type="1">
<li><code>Expander</code>用于确定关系边的PP是否满足TC的要求，</li>
<li>而
<code>Evaluator</code>用于确定搜索深度是否超过了设置的限制或是否达到了目标节点</li>
</ol></li>
</ol></li>
<li><p>在soot（一个非常知名的开源静态分析工具）的基础上，使用三个算法结合实现了java反序列化的
<code>利用链</code>查询</p></li>
</ol></li>
</ol>
<h3 id="section-16">2023-09-23</h3>
<h4 id="记录">记录</h4>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/08/26/lab-static-analysis/#toc-heading-16">指针分析lab</a><img
src="https://s2.loli.net/2023/09/23/w9lRgQVFnWj4iBS.png"
alt="image-20230923215625766" />
<ol type="1">
<li>上下文敏感</li>
<li>非上下文敏感</li>
</ol></li>
</ol>
<h3 id="section-17">2023-09-16</h3>
<h4 id="笔记记录">笔记记录</h4>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/08/26/lab-static-analysis/#toc-heading-10">lab-4.
类层次结构分析和过程间常量传播</a> <img
src="https://s2.loli.net/2023/09/16/FpxkTd1DaoUW8vS.png"
alt="image-20230916204351902" /></li>
<li><a
href="https://jf710001011.github.io/2023/08/26/java/#toc-heading-28">Java
泛型和foreach陷阱</a><img
src="https://s2.loli.net/2023/09/16/Bgz5Al1CnUH6XWe.png"
alt="image-20230916204511941" /></li>
</ol>
<h4 id="总结-9">总结</h4>
<ol type="1">
<li>lab实现了三个算法<img
src="https://s2.loli.net/2023/09/16/UN7dHkaKs3tLgwp.png"
alt="image-20230916204617878" /></li>
<li>Java语法巩固</li>
</ol>
<h3 id="section-18">2023-09-09</h3>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/08/26/java/#toc-heading-26">Java
集合框架</a><img
src="https://s2.loli.net/2023/09/09/KejiH6983dm1g7c.png"
alt="image-20230909175945385" /></li>
<li><a
href="https://jf710001011.github.io/2023/08/26/lab-static-analysis/#toc-heading-8">lab-死代码检测</a><img
src="https://s2.loli.net/2023/09/09/wrn9tUIgCNHJxSP.png" /></li>
</ol>
<h3 id="section-19">2023-09-02</h3>
<ol type="1">
<li>Java<a
href="https://jf710001011.github.io/2023/08/26/java/#toc-heading-5">关键字学习</a></li>
<li><a
href="https://jf710001011.github.io/2023/08/26/lab-static-analysis/#toc-heading-5">lab-常量传播和
Worklist 求解器</a></li>
</ol>
<h3 id="section-20">2023-08-26</h3>
<ol type="1">
<li><a
href="https://jf710001011.github.io/2023/08/26/lab-static-analysis/">实验过程简单记录</a></li>
</ol>
<h4 id="总结-10">总结</h4>
<ol type="1">
<li>进行这些实验，一方面是回顾以往的分析方法，将这些分析技术串联起来；另一方面，静态分析的难点之一也是算法的实现，最终的研究结果都需要用代码实现</li>
<li>两周内结束这些实验后，尝试应用于分析反序列化漏洞</li>
</ol>
<h3 id="section-21">2023-08-19</h3>
<h4 id="论文1-3">论文1</h4>
<ol type="1">
<li><a
target="_blank" rel="noopener" href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains-wp.pdf">Automated
Discovery of Deserialization Gadget Chains</a>
（来自<strong>黑帽大会</strong>2018：Ian Haken Senior Security Software
Engineer, Netflix）</li>
</ol>
<hr />
<h4 id="正文-7">正文</h4>
<ol type="1">
<li>即使在从“<code>readObject()</code>”方法返回之前，反序列化库也会自动调用
<code>魔术方法</code>。</li>
<li><code>ysoserial</code> 工具不能发现新的利用链</li>
<li><code>Gadget Inspector</code> tool</li>
</ol>
<h4 id="符号执行">符号执行</h4>
<ol type="1">
<li><p>符号执行技术指的是通过程序分析的方法，确定哪些输入向量会对应导致程序的执行结果为某个向量的方法</p></li>
<li><p><strong>分析程序的执行路径</strong></p></li>
<li><p>例如</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> m<span class="token operator">=</span>M<span class="token punctuation">,</span> n<span class="token operator">=</span>N<span class="token punctuation">,</span> q<span class="token operator">=</span>Q<span class="token punctuation">;</span> 
<span class="token keyword">int</span> x1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>x2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>x3<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    x1<span class="token operator">=</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;</span><span class="token number">12</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>m <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        x2<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    x3<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">assert</span><span class="token punctuation">(</span>x1<span class="token operator">+</span>x2<span class="token operator">+</span>x3<span class="token operator">!=</span><span class="token number">3</span><span class="token punctuation">)</span></code></pre>
<ol type="1">
<li>它有以下执行路径<img
src="https://s2.loli.net/2023/08/19/w4bsB1xDZroVMKh.png"
alt="简单理解符号执行1" /></li>
<li>叶子节点显示的数值表示当前输入情况下，可以得到的数值。（比如，如果英雄出装是M<sup>(N&lt;12)，那么最终的属性值R=0）。其中M</sup>(N&lt;12)表达的是，M是非零值且N要小于12，Q为任意值的情况下，得到R=0。可以发现，当条件为~M<sup>(N&lt;5)</sup>Q时，得到了最终结果等于3.即，我们通过这种方式逆向发现了输入向量。<strong>如果把结果条件更改为漏洞条件，理论上也是能够进行漏洞挖掘了。</strong></li>
<li>符号执行的流程<img
src="https://s2.loli.net/2023/08/19/vO7x2QLpFA3yih1.png"
alt="image-20230819212728240" /></li>
</ol></li>
</ol>
<h4 id="总结-11">总结</h4>
<ol type="1">
<li>通过黑帽大会那篇论文了解了现存工具是如何就检测gadget
chain的，但目前大部分工具都是只能检测已经发现的工具利用链</li>
<li>符号执行也是一种非常适合静态分析的技术</li>
<li>下周开始 进行这8个静态分析实验<img
src="https://s2.loli.net/2023/08/19/GRIq68XMKLveDgw.png"
alt="image-20230819212534334" /></li>
</ol>
<h3 id="section-22">2023-08-12</h3>
<h4 id="论文1-4">论文1</h4>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/10172888">Improving
Java Deserialization Gadget Chain Mining via Overriding-Guided Object
Generation</a>（程序语言<strong>CCF-A</strong>:2023 IEEE/ACM 45th
International Conference on Software Engineering (ICSE)）</li>
</ol>
<hr />
<ol start="2" type="1">
<li><p>关注 <code>Gadget Inspector</code>工具：static taint
analysis</p></li>
<li><p>关注 <code>SerHybrid</code> ：hybrid analysis solution</p></li>
<li><p>SerHybrid has limited effectiveness due to <strong>two
reasons</strong>：</p>
<ol type="1">
<li>SerHybrid performs points-to analysis [16] to identify
source-to-sink method execution paths. However, due to the dynamic
features (e.g., runtime polymorphism [17]) of Java language, any
available overridden method (gadget) on the application’s classpath may
be exploited to construct gadget chains, resulting in <strong>high false
negatives</strong></li>
<li>due to the unawareness of hard constraints (requiring dynamically
modifying the properties of an injection object to trigger the target
gadget chain) introduced by certain gadgets, such generated injection
objects may be <strong>semantically invalid</strong></li>
</ol></li>
<li><p>Found:</p>
<ol type="1">
<li>Java deserialization gadgets are usually exploited by abusing
advanced <strong>language features</strong> (e.g., runtime
polymorphism), which enables attackers to reuse serializable overridden
methods on the application’s classpath;</li>
<li>attackers usually invoke exploitable overridden methods (gadgets)
via <code>dynamic binding</code> [19] to generate injection objects for
gadget chain construction.</li>
</ol></li>
<li><p>GCMiner performs static analysis to construct the
<code>Deserialization-Aware Call Graph</code> (DA-CG) to model both
explicit and implicit (method overriding) method calls to identify more
gadget chains.</p></li>
<li><p>GCMiner adopts an
<code>overriding-guided object generation approach</code> to generate
exploitable injection objects for fuzzing.</p></li>
<li><p>two state-of-the-art gadget chain mining tools,：</p>
<ol type="1">
<li>Gadget Inspector</li>
<li>Serhybrid</li>
</ol></li>
<li><p><code>magic method</code>：执行payload触发反序列化；last
gadget执行 <code>恶意命令</code></p></li>
<li><p>Property-Oriented Programming (POP)</p></li>
<li><p>示例分析:</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token number">1</span>  <span class="token comment">/*javax.naming.ldap.Rdn$RdnEntry.class*/</span>
<span class="token number">2</span>  <span class="token keyword">private</span> <span class="token class-name">Oject</span> value<span class="token punctuation">;</span>
<span class="token number">3</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">RdnEntry</span> that<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/*Source or Magic Method*/</span>
<span class="token number">4</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>

<span class="token number">5</span>  <span class="token comment">/*com.sun.org.apache.xpath.internal.objects.XString.class*/</span>
<span class="token number">6</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/*2nd gadget*/</span>
<span class="token number">7</span>    <span class="token keyword">return</span> <span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
<span class="token number">8</span>  <span class="token comment">/*javax.swing.MultiUIDefaults.class*/</span>
<span class="token number">9</span>  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/*3rd gadget*/</span>
<span class="token number">10</span>   <span class="token class-name">Enumeration</span> keys <span class="token operator">=</span> <span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">11</span>   <span class="token keyword">while</span> <span class="token punctuation">(</span>keys<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token number">12</span>     <span class="token class-name">Object</span> key <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">13</span>     buf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>
<span class="token number">14</span> <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/*4th gadget*/</span>
<span class="token number">15</span>    <span class="token class-name">Object</span> value <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>

<span class="token number">16</span> <span class="token comment">/*javax.swing.UIDefaults.class*/</span>
<span class="token number">17</span> <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/*5th gadget*/</span>
<span class="token number">18</span>   <span class="token class-name">Object</span> value <span class="token operator">=</span> <span class="token function">getFromHashtable</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>
<span class="token number">19</span> <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">getFromHashtable</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/*6th gadget*/</span>
<span class="token number">20</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">LazyValue</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token number">21</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
<span class="token number">22</span>      value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">LazyValue</span><span class="token punctuation">)</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
<span class="token number">23</span> <span class="token comment">/*sun.swing.SwingLazyValue.class*/</span>
<span class="token number">24</span> <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">createValue</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">UIDefaults</span> table<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/*7th gadget*/</span>
<span class="token number">25</span>   <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
<span class="token number">26</span>     <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> c <span class="token operator">=</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">27</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>methodName <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token number">28</span>       <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> types <span class="token operator">=</span> <span class="token function">getClassArray</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">29</span>       <span class="token class-name">Method</span> m <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>methodName<span class="token punctuation">,</span> types<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">30</span>       <span class="token function">makeAccessible</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">31</span>       <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*Sink or Security-Sensitive Call Site*/</span></code></pre>
<p>这段代码展示了一个Java反序列化漏洞的利用链:</p>
<ol type="1">
<li>RdnEntry的compareTo方法作为<strong>入口</strong>点被触发。</li>
<li>调用了XString的equals方法。</li>
<li>进而调用了MultiUIDefaults的toString方法。</li>
<li>toString遍历键值对并调用get方法。</li>
<li>get调用了父类UIDefaults的get。</li>
<li>最终调用了getFromHashtable。</li>
<li>在LazyValue的情况下会<strong>反射调用指定的方法</strong>。</li>
<li>攻击者可以构造恶意LazyValue,并注入任意方法。</li>
<li>这样就可以通过反序列化调用任意方法,实现RCE。</li>
</ol>
<p>分析:</p>
<ul>
<li>反序列化时compareTo被调用</li>
<li>多个类组成了完整的调用链</li>
<li>LazyValue反射调用点可被利用</li>
<li>攻击者可构造执行任意代码的payload</li>
</ul>
<p>这展示了Java反序列化漏洞的复杂利用链分析过程。</p></li>
<li><p>well-known vulnerability disclosure platforms such as National
Vulnerability Database (<code>NVD</code>), Common Vulnerabilities and
Exposures (<code>CVE</code>) , Exploit Database
(<code>Exploit-D</code>)</p></li>
<li><p>An exploitable gadget chain requires:</p>
<ol type="1">
<li>a <code>magic method</code> (source or the first gadget)
deserializing untrusted data that can be injected by attackers;</li>
<li>a <code>security-sensitive call site</code> (sink or the last
gadget) that ultimately executes a dangerous operation; and</li>
<li>a series of gadgets facilitating the
<code>propagation of injection objects</code> [33].</li>
</ol></li>
<li><p><code>Java runtime polymorphism</code></p></li>
<li><p>invoke <code>overridden methods</code></p></li>
<li><p><code>application’s classpath</code></p></li>
<li><p><code>Java reflection</code></p></li>
<li><p>modify the <code>properties of injection objects</code></p></li>
<li><p>known gadget
<code>chainCommonsCollections1 of ysoserial</code>：combine dynamic
proxy and dynamic binding</p></li>
<li><p>add <code>additional overriding relations</code> through Class
Hierarchy Analysis <code>(CHA)</code> [37] to construct a
Deserialization-Aware Call Graph (DACG) to identify implicit method
calls</p></li>
<li><p><strong>Framework of GCMiner</strong><img
src="https://s2.loli.net/2023/08/12/qk8GMreLyua5T21.png"
alt="image-20230812045329846" /></p></li>
<li><p><strong>Overview of gadget chain verification.</strong><img
src="https://s2.loli.net/2023/08/12/dMgqlI1UOXzw89F.png"
alt="image-20230812045122878" /></p></li>
<li><p><strong>Partial DA-CG</strong> for our motivating example.<img
src="https://s2.loli.net/2023/08/12/f14cFJqGPUODCh5.png"
alt="image-20230812045150441" /></p></li>
<li><p>a <code>declarative language</code> for graph data retrieval
[39], to design <code>query scripts</code> for suspicious gadget chain
identification.</p></li>
<li><p>A simple query <code>script</code> example.</p>
<pre class="language-cypher" data-language="cypher"><code class="language-cypher"><span class="token number">1</span>  <span class="token keyword">match</span> <span class="token punctuation">(</span>source<span class="token operator">:</span> <span class="token class-name">Method</span> <span class="token punctuation">&#123;</span>NAME<span class="token operator">:</span><span class="token string">"readObject"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token number">2</span>  <span class="token keyword">match</span> <span class="token punctuation">(</span>sink<span class="token operator">:</span> <span class="token class-name">Method</span> <span class="token punctuation">&#123;</span>NAME<span class="token operator">:</span><span class="token string">"invoke"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token number">3</span>  <span class="token keyword">call</span> apoc<span class="token punctuation">.</span>algo<span class="token punctuation">.</span><span class="token function">allSimplePaths</span><span class="token punctuation">(</span>sink<span class="token punctuation">,</span> source<span class="token punctuation">,</span> <span class="token string">"&lt;Call|Overriding>"</span><span class="token punctuation">)</span>
   <span class="token keyword">yield</span> path
<span class="token number">4</span>  <span class="token keyword">return</span> path</code></pre></li>
<li><p>然后，为了使生成的注入对象能够遵循目标gadget链的执行流程，GCMiner通过
<code>动态绑定</code>的方式<strong>修改</strong>注入对象的属性值</p></li>
<li><p>对于属性选择，我们通过
<code>Java反射</code>动态获取注入对象的每个属性类型[40]-[42]，这允许软件系统在
<code>运行时</code>检查和更改其类、接口、方法和字段的行为</p></li>
<li><p>当属性类型是
<code>类对象</code>时，该属性将被列为值赋值的候选属性。</p></li>
<li><p>GCMiner 利用 <code>JQF-Zest 算法</code> [44]
来生成新的输入，通过在位级别改变有趣的种子来更深入地进入目标 gadget
链。</p></li>
<li><p>实验的<strong>实现</strong>：</p>
<ol type="1">
<li>tabby: Java代码分析工具</li>
<li>Neo4j: 图数据库</li>
<li>JQF算法：注入对象生成策略</li>
</ol></li>
<li><p>实验<strong>评估指标</strong>：</p>
<ol type="1">
<li>Known Gadget Chains (KGC）</li>
<li>Reported Gadget Chains (Rep)</li>
<li>True Positives (TP)<img
src="https://s2.loli.net/2023/08/12/sfhPjOHJr9u6NIG.png"
alt="image-20230812055654282" /></li>
<li>Precision (P)<img
src="https://s2.loli.net/2023/08/12/VnpwuC1Fo4yORvB.png"
alt="image-20230812055702103" /></li>
</ol></li>
<li><p>从这篇论文中挑选的有用的参考文献：</p>
<ol type="1">
<li>J. C. S. Santos, R. A. Jones, C. Ashiogwu, and M. Mirakhorli,
“Serialization-aware call graph construction“</li>
<li>Y. Wei, X. Sun, L. Bo, S. Cao, X. Xia, and B. Li, “A comprehensive
study on security bug characteristics,”</li>
<li>J. Dahse, N. Krein, and T. Holz, “Code reuse attacks in PHP:
automated POP chain generation,”</li>
<li>I. Haken, “Automated discovery of deserialization gadget chains,” in
Proceedings of the Black Hat USA, 2018.</li>
<li>S. Rasheed and J. Dietrich, “A hybrid analysis to detect java
serialisation vulnerabilities,</li>
</ol>
<p>........</p></li>
</ol>
<h4 id="论文2-1">论文2</h4>
<ol type="1">
<li>论文：<code>A Composite Discover Method for Gadget Chains in Java Deserialization Vulnerability</code></li>
</ol>
<hr />
<ol type="1">
<li>该方法遵循Gadget Inspector的
<code>静态分析</code>来获取待验证的gadget链。在这项工作中，仍然使用
<code>符号执行</code>来生成调用图。</li>
<li>这种BFS没有考虑到多个gadget链可能
<code>共享节点</code>，这导致只会搜索经过同一节点的多个gadget链中的一个</li>
<li>提出了一种基于 <code>Java序列化协议</code>和
<code>反射机制</code>的匹配动态验证机制。</li>
<li><code>Java Deserialization Scanner</code>[16]可以证实该策略的有效性。它是著名渗透测试工具`<code>Burp Suite</code>的插件。</li>
<li><code>基于指纹的检测</code>只能检测程序中已知的gadget链的存在，而不能检测程序中未知的gadget链的存在。</li>
<li>A gadget chain can be abstracted as source-&gt;gadget
core-&gt;sink.</li>
<li>我们的 <code>静态分析</code>分为以下几个步骤：
<ol type="1">
<li>获取目标程序的类信息和方法信息。</li>
<li>通过符号执行生成调用图。</li>
<li>搜索所有边链。</li>
</ol></li>
<li><code>ASM库</code>[18]，一个优秀的Java字节流操作工具。</li>
<li>使用小工具检查器的
<code>符号执行</code>来获得每个方法的调用关系。这些调用关系组成了调用关系图，这个调用关系图被存储为
&lt; <code>call，callee array &gt;</code> 的集合</li>
</ol>
<h4 id="总结-12">总结</h4>
<ol type="1">
<li><strong>论文1总结</strong>：
<ol type="1">
<li>这篇文献主要是针对Java反序列化漏洞：
<ol type="1">
<li>分析了：gadge chain 原理</li>
<li>通过分析<strong>注入对象</strong>的有害数据从
<code>source</code>传播到 <code>sink</code>验证这条gadge
chain的有效性</li>
<li>自动化生成注入对象进行fuzzing测试</li>
</ol></li>
<li>实验仅粗略查看，总结如下：
<ol type="1">
<li>实验部分<strong>构成</strong>:
<ol type="1">
<li>确定实验研究问题（RQ）</li>
<li>实验实施需要的配置和工具</li>
<li>评估准则</li>
<li>实验方法的效率</li>
<li>与其他方法的全面对比</li>
</ol></li>
</ol></li>
</ol></li>
<li>理解source-sink这个传播路径对于安全研究非常关键</li>
<li>扩大了知识面：了解到了更多相关的漏洞工具、研究方法</li>
<li>没有足够多的论文品读，换个思路可以从<strong>工具源码</strong>、<strong>博客文章</strong>入手</li>
<li>作者在结论中提到:java反序列化漏洞在工业届造成了严重危害，但是学术界关注不多：<code>Java deserialization vulnerability receives little attention in the academic community despite its severe impact in practice.</code></li>
</ol>
<h3 id="section-23">2023-08-15</h3>
<h4 id="论文-2">论文</h4>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3554732">An In-depth Study
of <strong>Java Deserialization Remote-Code Execution</strong> Exploits
and Vulnerabilities.</a>(<strong>CCF-A</strong>:软件工程顶刊：ACM
Transactions on Software Engineering and Methodology, Volume 32)</li>
<li><a
target="_blank" rel="noopener" href="https://kns.cnki.net/kcms2/article/abstract?v=3uoqIhG8C475KOm_zrgu4sq25HxUBNNTmIbFx6y0bOQ0cH_CuEtpsBEA1ZchHvbBzXSfH-MI98eDZf0c0EzlXHEueUNCTYsU&amp;uniplatform=NZKPT">基于反向污点分析的反序列化漏洞挖掘技术研究</a></li>
</ol>
<h4 id="论文1-5">论文1</h4>
<h5 id="简介">简介</h5>
<ol type="1">
<li>反序列化漏洞非常关键，因此被OWASP列为web应用程序的<strong>十大安全风险之一</strong></li>
<li>Java、PHP和.
NET等几种主流编程语言中的反序列化漏洞，目前主要研究Java中的反序列化漏洞</li>
<li>Java<strong>序列化</strong>允许将类实例转换成字节流。因此，Java对象可以通过<strong>网络传输</strong>。<strong>反序列化</strong>包括读取序列化的字节流，以便通过加载它们的字段来重建<strong>原始实例</strong></li>
<li>当在远程主机上进行反序列化时，可以通过链接称为<strong>gadget的Java代码序列</strong>来控制Java代码的执行流</li>
<li>与其他漏洞相比-反序列化攻击能够<strong>完全控制</strong>受攻击的系统或让位于<strong>勒索软件攻击</strong></li>
<li>文中提到的这个工具我用过：<code>Ysosial</code>是一个提供概念验证工具的项目，并提供了34个在众所周知的反序列化攻击中利用的Java有效负载。</li>
</ol>
<h5 id="重要概念">重要概念</h5>
<ol type="1">
<li><strong>Gadget和Gadget链</strong>。在本文的上下文中，Gadget是一种使用可由攻击者控制的对象或字段的Java方法。小工具链是攻击者创建的一系列恶意方法(小工具)调用。易受攻击的应用程序的类路径中存在一组小工具是执行反序列化攻击所需的条件之一</li>
<li><strong>Java反序列化漏洞</strong>：(1)包含此方法的程序接受并反序列化来自攻击者可以控制的源的数据，以及(2)攻击者可以利用此漏洞。在实践中，(2)需要构建小工具链，因此要求所有必要的小工具都位于易受攻击应用程序的类路径中。</li>
</ol>
<h5 id="示例">示例</h5>
<ol type="1">
<li>著名的 <code>CommonsCollections1反序列化攻击</code></li>
<li><code>ysoserial</code>工具可以生成针对于Java反序列化漏洞的恶意代码</li>
</ol>
<h5 id="本文conclusion">本文conclusion</h5>
<ol type="1">
<li>本文是Java反序列化远程代码执行漏洞和漏洞的深入研究。它探讨了反序列化的危险性，以及它如何使应用程序容易受到远程代码执行等攻击的影响。该研究分析了Java库中存在的攻击工具和Java应用程序中的漏洞。它还提出了防止引入攻击工具的库开发人员的建议，并讨论了一些库的修补时间。此外，该研究分析了104个Mitre
CVE，这些CVE涉及Java应用程序中的反序列化漏洞，并得出结论，不是所有的补丁都能防止攻击并保护应用程序。</li>
<li>对于漏洞的修补部分，不做太多关注。而本文也不是关于该漏洞的检测方面的内容。仅仅是对漏洞原理的分析，便能成为该文的一创新点。可见Java反序列化漏洞研究甚少。</li>
</ol>
<h4 id="论文2-2">论文2</h4>
<ol type="1">
<li><p>检索的这篇中文论文：主要是改进污点分析在漏洞检测中的不足。常规污点分析是正向的，本文提出反向分析技术改进了遗漏问题和效率问题。</p></li>
<li><p>PHP反序列化漏洞挖掘流程与Java反序列化漏洞挖掘相似，主要分为四步：</p>
<ol type="1">
<li>使用PHP-Parser工具将PHP源码解析为AST树，并将有用的字节码数据保存进字节码数据库中</li>
<li>然后寻找可控动态函数调用，如所有函数对象和参数对象都可控的
<code>a(b)</code>函数调用</li>
<li>接着反向分析函数调用链，构造从危险函数到起点函数的反序列化漏洞链</li>
<li>最后输出所有检出反序列化漏洞链。</li>
</ol></li>
<li><p>基于 <code>CodeQL</code>等框架的自动化安全分析技术</p></li>
<li></li>
</ol>
<h4 id="总结-13">总结</h4>
<ol type="1">
<li>需要阅读两方面的论文，也可以说是研究的思路：
<ol type="1">
<li>针对各种漏洞的静态分析框架相关论文：改进静态分析技术本身的缺点（例如检测效率与检测速度之间的平恒问题）</li>
<li>研究反序列化，深入了解反序列化漏洞的特点，针对该特点，去设计相应的检测框架（一种新的检测方法）</li>
</ol></li>
</ol>
<h3 id="section-24">2023-07-29</h3>
<h4 id="学习内容">学习内容</h4>
<ul>
<li><a
href="https://jf710001011.github.io/2023/06/08/static-program-analysis/#toc-heading-58">结束静态分析</a></li>
<li><a
href="https://jf710001011.github.io/2023/07/12/101-ctf/#toc-heading-6">padding
oracle漏洞原理</a></li>
<li><a
href="https://jf710001011.github.io/2023/03/06/portswigger/#toc-heading-37">认证漏洞原理</a></li>
</ul>
<h4 id="总结-14">总结</h4>
<h5 id="静态分析">静态分析：</h5>
<ul>
<li><p>学习了<strong>数据流分析</strong></p>
<ul>
<li>变量可达分析</li>
<li>变量存活分析</li>
<li>表达式可用分析</li>
<li>常量传播</li>
</ul></li>
<li><p>学习了程序<strong>理论</strong></p>
<ul>
<li>主要是格（lattice）理论</li>
</ul></li>
<li><p>学习了<strong>过程间</strong>分析</p>
<ul>
<li>CHA</li>
<li>控制流图</li>
<li>数据流分析</li>
</ul></li>
<li><p>学习了<strong>指针分析</strong>：在面向对象程序中的作用尤为明显，体现在</p>
<ul>
<li><strong>方法调用</strong></li>
</ul></li>
<li><p>指针分析中的<strong>上下文敏感</strong>分析</p></li>
<li><p>静态分析如何应用<strong>安全研究</strong></p>
<ul>
<li>指针分析和<strong>污点分析</strong>结合</li>
</ul></li>
<li><p>Datalog-Based
程序分析：<strong>声明式语言</strong>在静态分析设计算法有很多优点</p></li>
<li><p>在整个学习过程中：<strong>体会</strong>到了一个完整的解决问题的过程</p>
<ol type="1">
<li>针对问题</li>
<li>设计符号和新的定义</li>
<li>设计规则</li>
<li>算法实现上述内容</li>
</ol></li>
<li><p>积累的算法对我后续的研究奠定了一个<strong>基础</strong></p></li>
</ul>
<h5 id="下一个目标">下一个目标</h5>
<ul>
<li>回到论文</li>
<li>目前打算着手Java中的反序列化漏洞，原因：
<ul>
<li>指针分析利于分析面向对象语言</li>
<li>此漏洞特点：对象之间方法调用复杂</li>
<li>构建相关的对象图、方法调用图、污点分析适合检测此种类型漏洞</li>
</ul></li>
</ul>
<h3 id="section-25">2023-07-22</h3>
<ul>
<li><a
href="https://jf710001011.github.io/2023/06/08/static-program-analysis/#toc-heading-38">静态分析：课程08（Pointer
Analysis） &amp; Pointer Analysis Foundations (I)</a></li>
<li><a
href="https://jf710001011.github.io/2023/03/06/portswigger/#toc-heading-43">漏洞：Cross-site
scripting(XSS)</a></li>
<li>感觉还要一周才能结束剩下的<strong>指针分析</strong>部分：<img
src="https://s2.loli.net/2023/07/22/PUSbpEzxl1sy8MN.png"
alt="image-20230722173813445" /></li>
</ul>
<h3 id="section-26">2023-07-15</h3>
<ul>
<li><a
href="https://jf710001011.github.io/2023/06/08/static-program-analysis/#toc-heading-33">静态分析：foundation2
&amp; Call Graph Construction (CHA)</a></li>
<li><a
href="https://jf710001011.github.io/2023/03/06/portswigger/#toc-heading-2">漏洞：sql
injection</a></li>
</ul>
<h3 id="section-27">2023-07-08</h3>
<ul>
<li><a
href="https://jf710001011.github.io/2023/06/08/static-program-analysis/#toc-heading-21">静态分析-Data
Flow Analysis - Foundations I</a></li>
<li><a
href="https://jf710001011.github.io/2023/03/06/portswigger/#toc-heading-33">漏洞分析-结束Java反序列化漏洞</a></li>
</ul>
<h5 id="总结-15">总结</h5>
<ul>
<li>这周的静态分析<strong>理论性</strong>很强，很多新概念，找到我在读论文时候的那个感觉了，论文正是以这种形式对漏洞检测建模</li>
<li><strong>反序列化漏洞</strong>由于本身的漏洞特性，非常符合我研究的静态分析技术特点，即需要分析源码。
<ul>
<li>果然我之前提到的<strong>advance
topic</strong>上的漏洞都很有研究价值<img
src="https://s2.loli.net/2023/07/08/s2C6cobMyN5wS3p.png"
alt="image-20230708203433921" /></li>
</ul></li>
<li>目前来说我所做的工作：并行学习静态分析和更多的前沿漏洞是<strong>正确的思路</strong>。
<ul>
<li>就差对静态分析的掌握与灵活应用了</li>
</ul></li>
<li><strong>下周</strong>：检索静态分析反序列化漏洞相关论文。</li>
</ul>
<h3 id="section-28">2023-07-01</h3>
<ul>
<li><a
href="https://jf710001011.github.io/2023/06/08/static-program-analysis/#toc-heading-15">学习了静态分析-数据流分析</a></li>
</ul>
<h4 id="总结-16">总结</h4>
<ul>
<li>数据流分析主要涉及程序的变量和表达式</li>
</ul>
<h3 id="section-29">2023-06-24</h3>
<ul>
<li><a
href="https://jf710001011.github.io/2023/06/08/static-program-analysis/#toc-heading-5">学习了静态分析-中间表示</a></li>
<li><a
href="https://jf710001011.github.io/2023/03/06/portswigger/#toc-heading-27">学习了反序列化漏洞</a></li>
</ul>
<h4 id="总结-17">总结</h4>
<ul>
<li>静态分析以及前沿漏洞的学习将持续一段时间，争取一个月内结束</li>
</ul>
<h3 id="section-30">2023-06-09</h3>
<ul>
<li><a
target="_blank" rel="noopener" href="https://dblp.uni-trier.de/search?q=Static%20Analysis%20%20Vulnerabilities">静态分析&amp;漏洞
论文检索</a></li>
</ul>
<h4 id="论文信息-1">论文信息</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://www.usenix.org/conference/14th-usenix-security-symposium/finding-security-vulnerabilities-java-applications-static">Finding
Security Vulnerabilities in Java Applications with Static Analysis</a>
<strong>CCF-A:</strong>USENIX Security Symposium 2005</li>
</ul>
<h4 id="正文-8">正文</h4>
<ul>
<li><p>字节码（Bytecode）是一种中间代码形式，它是在程序源代码经过编译但尚未被执行时生成的。字节码通常与特定的虚拟机（如Java虚拟机）相关联，它们是一种可被虚拟机解释或即时编译执行的指令集。字节码的好处之一是它具有跨平台的特性，因为不同的虚拟机可以解释执行相同的字节码。</p>
<p>在Java中，源代码首先经过编译器编译成字节码文件（以.class为扩展名），然后由Java虚拟机加载和执行这些字节码文件。字节码是一种中间形式，它包含了程序的指令、常量池、字段、方法等信息。通过解释或即时编译，Java虚拟机将字节码转换为机器码，并执行相应的操作。</p></li>
<li><p>污点对象传播问题：论文定义了源（source）、汇（sink）和派生（derivation）描述符来表示安全漏洞的特征。源描述符表示潜在的污点数据来源，汇描述符表示敏感操作的目标，派生描述符表示对象之间的传播关系。</p></li>
<li><p>指针分析：指针分析是静态分析中的关键问题，用于确定程序变量在程序执行期间可能指向的堆对象。论文介绍了基于二叉决策图（BDD）的上下文敏感指针分析算法，该算法在保持精确性的同时实现了可扩展性</p></li>
<li><p>静态安全违规检测：论文提出了使用PQL（Program Query
Language）来描述安全漏洞模式的方法。PQL是一种程序查询语言，通过声明变量、定义匹配模式和指定返回结果，可以方便地表达与程序执行相关的动态事件序列。</p></li>
</ul>
<h4 id="总结-18">总结</h4>
<h5 id="论文总结">论文总结</h5>
<p>作者的方法基于可扩展且精确的指针分析。指针分析是一种确定从给定对象可以访问到的对象集合的技术。这些信息可以用于发现安全漏洞，如SQL注入和跨站脚本攻击。</p>
<p>作者的方法使用上下文敏感的指针分析。这意味着分析考虑了变量的使用上下文。例如，如果一个变量在已知包含用户输入的上下文中使用，那么分析将考虑从该变量可以访问到的所有对象，即使这些对象不是直接从该变量可达的。</p>
<p>作者还使用了一种称为改进对象命名的技术。这种技术通过给对象赋予更有意义的名称来减少误报数量。例如，如果一个对象用于存储用户输入，那么该对象将被赋予反映这一事实的名称。这有助于分析区分可能包含用户输入的对象和不包含用户输入的对象</p>
<h3 id="section-31">2023-06-02</h3>
<h4 id="论文-3">论文</h4>
<h5 id="开篇">开篇</h5>
<ul>
<li><p><strong>论文信息</strong></p>
<p><a
target="_blank" rel="noopener" href="https://www.computer.org/csdl/proceedings-article/sp/2023/933600b059/1NrbYrQrQ2I">Scaling
JavaScript Abstract Interpretation to Detect and Exploit Node.js
Taint-style Vulnerability</a>: <strong>CCF-A</strong>会议：IEEE S&amp;P
2023</p></li>
<li><p><strong>keywords</strong></p></li>
</ul>
<h5 id="正文-9">正文</h5>
<ul>
<li><p>源点和汇点是软件程序中与数据流相关的概念。</p>
<p><code>源点</code>（source）是指程序中产生数据流的起点或来源。它可以是用户输入、传感器数据、文件读取等。源点提供了数据流的初始值或输入，它是数据流的生成者。</p>
<p><code>汇点</code>（sink）是指程序中接收数据流的终点或目标。它可以是数据库写入、网络传输、文件输出等。汇点接收和处理数据流，并对其进行操作或存储，它是数据流的消费者。</p>
<p>数据流从源点开始，通过程序的不同部分传递，最终到达汇点。在安全领域，源点和汇点之间的数据流可能存在安全风险。例如，源点可能包含恶意输入，汇点可能存在安全漏洞，导致恶意输入被利用或导致安全问题。</p></li>
<li><p><strong>现存问题</strong></p>
<ol type="1">
<li>准确性和可扩展性的权衡之</li>
<li>现有的JavaScript静态分析面临的另一个主要挑战是异步函数调用，特别是涉及Promise的函数调用。</li>
</ol></li>
<li><p>描述了一个新的系统，称为
<code>FAST</code>（可扩展性快速抽象解释）：FAST在这一步的<strong>创新之处</strong>在于采用函数作用域而不是调用序列（与之前的工作相比）进行抽象解释。这使得FAST能够高效地分析一个函数，而不是每次函数调用都要重复分析。此外，为了捕捉JavaScript函数调用解析的复杂性，FAST构建了一种新颖的函数依赖图（<code>FDG</code>），描述了函数如何创建、解析或触发其他函数的执行。</p>
<ul>
<li><code>自顶向下</code>的抽象解释修剪了程序，并只分析与可能的污点式汇点具有控制和数据依赖关系的语句
<ul>
<li>符号约束</li>
</ul></li>
</ul></li>
<li><p><strong>Contributions</strong></p>
<ul>
<li>提出了一种两阶段的抽象解释方法，第一阶段生成控制流图，以指导第二阶段的高效分析。</li>
<li>实现了一个名为FAST的原型开源静态工具，用于检测污点式漏洞。</li>
<li>评估结果显示，FAST在减少误报的方面显著优于最先进的漏洞检测工具。</li>
</ul></li>
<li><p>代码分析</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">1</span> <span class="token comment">// util.js</span>
<span class="token number">2</span> <span class="token keyword">const</span> childProcess <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"child_process"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">3</span> <span class="token keyword">const</span> logger <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./logger"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token keyword">function</span> <span class="token function">promisify</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
5return <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
6return <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">executor</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
<span class="token number">7</span><span class="token function">fn</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token number">8</span><span class="token function">if</span> <span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">9</span><span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">11</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token number">13</span> <span class="token punctuation">&#125;</span>
<span class="token number">14</span> <span class="token keyword">function</span> <span class="token function">execProcess</span><span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
15return <span class="token function">promisify</span><span class="token punctuation">(</span>childProcess<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">16</span> <span class="token punctuation">&#125;</span>
<span class="token number">17</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">deflate</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
18const <span class="token function-variable function">flush_pending</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">strm</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
19const s <span class="token operator">=</span> strm<span class="token punctuation">.</span>state<span class="token punctuation">;</span>
<span class="token number">20</span><span class="token comment">// let f(n) = 2*nˆ2,</span>
<span class="token punctuation">,</span>→after k iterations<span class="token punctuation">,</span> there are <span class="token function">fˆk</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> objects
21let len <span class="token operator">=</span> s<span class="token punctuation">.</span>pending<span class="token punctuation">;</span><span class="token comment">// n objs</span>
<span class="token number">22</span><span class="token function">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> strm<span class="token punctuation">.</span>avail_out<span class="token punctuation">)</span>
23len <span class="token operator">=</span> strm<span class="token punctuation">.</span>avail_out<span class="token punctuation">;</span><span class="token comment">// 2*n objs</span>
24strm<span class="token punctuation">.</span>avail_out <span class="token operator">-=</span> len<span class="token punctuation">;</span><span class="token comment">// 2*nˆ2 objs</span>
<span class="token number">25</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token number">26</span><span class="token function">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// ...k*k iterations</span>
<span class="token number">27</span><span class="token function">while</span> <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//...k iterations</span>
<span class="token number">28</span><span class="token function">flush_pending</span><span class="token punctuation">(</span>strm<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ...</span>
<span class="token number">29</span><span class="token punctuation">&#125;</span>
<span class="token number">30</span><span class="token punctuation">&#125;</span>
<span class="token number">31</span> <span class="token punctuation">&#125;</span>
<span class="token number">32</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">compress</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token number">33</span><span class="token function">switch</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>alg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
34case ’zip’<span class="token operator">:</span>
35return <span class="token keyword">await</span> <span class="token function">deflate</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
36case ’xz’<span class="token operator">:</span>
37var command <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"xz"</span><span class="token punctuation">,</span> <span class="token string">"--stdout"</span><span class="token punctuation">,</span> <span class="token string">"-k"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token number">38</span><span class="token function">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>path<span class="token punctuation">)</span>
39command<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
40else
41command<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
42command <span class="token operator">=</span> command<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>
43logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>‘xz<span class="token punctuation">,</span> $<span class="token punctuation">&#123;</span>command<span class="token punctuation">&#125;</span>‘<span class="token punctuation">)</span><span class="token punctuation">;</span>
44return <span class="token keyword">await</span> <span class="token function">execProcess</span><span class="token punctuation">(</span><span class="token string">"exec"</span><span class="token punctuation">)</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">45</span><span class="token punctuation">&#125;</span>
<span class="token number">46</span> <span class="token punctuation">&#125;</span>
<span class="token number">47</span> module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Util</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token number">48</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>compress <span class="token operator">=</span> compress<span class="token punctuation">;</span>
<span class="token number">49</span> <span class="token comment">// exploit code, under attacker control</span>
<span class="token number">50</span> <span class="token keyword">const</span> Util <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span>’util<span class="token punctuation">.</span>js’<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">51</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Util</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compress</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">’alg’</span><span class="token operator">:</span> ’xz’<span class="token punctuation">,</span> <span class="token literal-property property">’path’</span><span class="token operator">:</span> ’<span class="token punctuation">;</span> touch
<span class="token punctuation">,</span>→exploit #’ <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>漏洞原理：</strong></p>
<ol type="1">
<li>在第51行，通过 <code>const Util = require('util.js');</code>导入了
<code>util.js</code>模块，并创建了一个 <code>Util</code>的实例。</li>
<li>在第51行的代码
<code>(new Util()).compress(&#123; 'alg': 'xz', 'path': '; touch exploit #' &#125;);</code>中，调用了
<code>Util</code>实例的
<code>compress</code>方法，并传入了一个包含选项的对象作为参数。其中，<code>alg</code>选项的值为'xz'，<code>path</code>选项的值为';
touch exploit #'。</li>
<li>在 <code>compress</code>方法中，根据
<code>options.alg</code>的值进行条件判断。</li>
<li>当
<code>options.alg</code>的值为'xz'时，执行37-44行的代码块。这段代码构建一个命令，并将其作为字符串拼接到
<code>command</code>变量中。如果
<code>options.path</code>为空，则拼接的命令为"xz --stdout -k
data"；否则，拼接的命令为"xz --stdout -k"加上
<code>options.path</code>的值。最后，通过调用
<code>execProcess("exec")</code>方法，将命令作为参数传递给
<code>childProcess.exec</code>函数进行执行。</li>
<li>漏洞出现在拼接命令的过程中。由于未对
<code>options.path</code>进行适当的输入验证或过滤，攻击者可以在
<code>options.path</code>中注入恶意的操作系统命令。在这个例子中，注入的命令是";
touch exploit #"，它会尝试在操作系统中执行
<code>touch</code>命令创建一个名为"exploit"的文件。</li>
<li>漏洞的利用代码出现在49-51行，攻击者通过传入恶意的
<code>options.path</code>，即"; touch exploit
#"，来触发操作系统命令注入漏洞。当程序执行到这部分代码时，恶意命令将被执行，导致在操作系统中创建了一个名为"exploit"的文件。</li>
</ol>
<p>因此，这个操作系统命令注入漏洞使得攻击者能够在执行压缩操作时执行任意的操作系统命令，从而对系统造成潜在的安全风险。</p></li>
<li><p><strong>Vulnerability Detection Challenges</strong></p>
<ol type="1">
<li><p>accuracy-scalability trade-off</p>
<blockquote>
<ol type="1">
<li>首先，静态地解析fn是具有挑战性的，因为fn在promisify的闭包中被定义为函数参数。其次，childProcess[method]的解析取决于第14行的函数参数method，该参数作为字符串传递给第44行的函数。最后，尽管在第7行注册了回调函数cb，但是异步函数仅在第44行执行，当await等待所有的promise被解决时。事实上，经典的静态分析[4]无法解析fn（第7行）或childProcess[method]（第15行），导致控制流图中缺少调用边缘，从而导致漏报漏洞。</li>
<li>抽象解释常常面临对象爆炸的问题。也就是说，涉及的对象数量可能呈指数级增加，导致需要大量的存储空间来存储对象，并且需要过多的时间来确定每个对象。</li>
</ol>
</blockquote></li>
<li><p>vulnerability validation</p></li>
</ol></li>
<li><p>FAST包含<strong>三个阶段</strong>：</p>
<ul>
<li><ol type="i">
<li>控制流路径生成阶段，使用自底向上的抽象解释来构建控制流图，并找到从入口点到汇函数的路径；</li>
</ol></li>
<li><ol start="2" type="i">
<li>数据流路径生成阶段，使用自顶向下的抽象解释来根据第一阶段中的控制流路径生成准确和有信息量的数据流路径</li>
</ol></li>
<li><ol start="3" type="i">
<li>漏洞利用生成阶段，将数据流路径转换为约束，并解决这些约束以生成漏洞利用代码。</li>
</ol></li>
</ul></li>
<li><p><strong>可扩展性</strong>是指系统能够有效地处理大规模代码和复杂性的能力。在软件漏洞检测中，可扩展性是一项重要的挑战，因为现实世界中的代码规模庞大且复杂</p></li>
<li><p>提取控制流和数据流约束以供 <code>约束求解器</code>使用</p></li>
</ul>
<h4 id="总结-19">总结</h4>
<ul>
<li><p><strong>论文总结</strong>：</p>
<p>本文是一篇关于使用<strong>FAST</strong>（一种用于检测和利用Node.js污点风格漏洞的两阶段抽象解释方法）的论文。文章介绍了FAST的<strong>两个阶段</strong>：bottom-up
abstract interpretation和top-down abstract
interpretation，并详细描述了它们如何优化抽象解释过程以提高分析效率。文章还讨论了现有方法在检测taint-style漏洞时存在的问题，以及JavaScript语言中静态分析<strong>可扩展性和准确性之间的固有权衡</strong>。最后，作者通过实验验证了FAST在检测Node.js应用程序中污点风格漏洞方面的有效性和可扩展性。</p></li>
<li><p>本文还将作者之前提出的框架
<code>ODGen</code>（见之前原型污染相关文章）进行了对比，可以说本文是对之前自己所做研究成果的进一步完善</p></li>
</ul>
<hr />
<h4 id="补充">补充：</h4>
<ul>
<li>太难，留着以后回看</li>
</ul>
<h3 id="section-32">2023-05-19</h3>
<h4 id="学习笔记和漏洞研究记录">学习笔记和漏洞研究记录</h4>
<ul>
<li><p><a
href="https://jf710001011.github.io/2023/05/02/javascript/">web &amp;
js</a></p>
<p>其中<strong>重点内容</strong>是：</p>
<ul>
<li>表单的提交：这可能涉及用户提交的个人信息（如账号密码），此处是漏洞研究的主要目标。</li>
<li>Js程序在用户与浏览器交互 和
浏览器与服务器交互中扮演的重要作用。</li>
</ul></li>
<li><p><strong><a
href="https://jf710001011.github.io/2023/03/06/portswigger/">漏洞研究</a></strong>：</p>
<p>当涉及到
<code>AngularJS</code>时，XSS漏洞可能会在没有HTML的情况下发生，这是PortSwigger研究团队在其文章《<code>XSS without HTML: Client-Side Template Injection with AngularJS</code>》中提到的主题。<strong>总结</strong>如下：</p>
<ul>
<li>AngularJS是一种流行的JavaScript框架，用于创建单页应用程序。</li>
<li>AngularJS模板用于在客户端渲染HTML内容。</li>
<li>AngularJS模板可能会被注入恶意代码，从而利用XSS漏洞。</li>
<li>有多种方式可以将恶意代码注入到AngularJS模板中，包括：
<ul>
<li>使用未经过清理的用户输入。</li>
<li>使用第三方库。</li>
<li>使用AngularJS指令。</li>
<li>一旦将恶意代码注入到AngularJS模板中，就可以在受害者的浏览器上执行任意JavaScript代码。
<ol type="1">
<li>这可以用于窃取Cookie、会话令牌和其他敏感信息。</li>
<li>还可以用于劫持受害者的浏览器并执行其他恶意操作。</li>
</ol></li>
</ul></li>
<li>文章提供了一些预防AngularJS应用程序中XSS漏洞的建议。这些建议包括：
<ul>
<li>在将用户输入用于AngularJS模板之前对其进行清理。</li>
<li>仅使用可信任的第三方库。</li>
<li>在使用AngularJS指令之前仔细审查它们。</li>
<li>及时更新AngularJS以获取最新的安全补</li>
</ul></li>
</ul></li>
</ul>
<h4 id="总结-20">总结</h4>
<ul>
<li>最近都是以实验、实践的形式在研究发现漏洞的手法：主要是使用<strong>国外安全团队的Lab研究博客</strong>作为学习资料</li>
<li>学习过程中对其中的<strong>关键应用程序代码</strong>和<strong>注入的恶意代码</strong>进行了细致学习，学习了漏洞原理和发掘漏洞的思路。</li>
</ul>
<h3 id="section-33">2023-05-12</h3>
<h4 id="我的学习笔记">我的学习笔记</h4>
<ul>
<li><a
href="https://jf710001011.github.io/2023/05/02/javascript/">Web开发与JavaScript编程</a></li>
<li><a
href="https://jf710001011.github.io/2023/03/06/portswigger/">漏洞的学习</a></li>
</ul>
<h3 id="section-34">2023-05-05</h3>
<h4 id="paper">paper</h4>
<ul>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3468264.3468542">Detecting
Node.js prototype pollution vulnerabilities via object lookup
analysis</a>(<strong>CCF-A</strong>:ESEC/SIGSOFT FSE 2021)</li>
<li><strong>Author</strong>:Song Li</li>
</ul>
<h4 id="正文-10">正文</h4>
<ul>
<li><p>源对象和汇对象是在数据流分析中常用的两个术语。</p>
<p><strong>源对象</strong>是数据流分析中的输入，也就是程序中已经存在的数据，可以被使用或传递到其他地方。例如，一个函数的参数或者全局变量。</p>
<p><strong>汇对象</strong>则是分析结果的输出，也就是数据流分析发现的结果。通常来说，汇对象会根据分析的目的而有所不同。例如，在安全漏洞检测中，汇对象可能是程序中的一段危险代码，或者一处未经正确验证的用户输入。</p>
<p>在数据流分析过程中，源对象和汇对象都是需要被识别和跟踪的。数据流分析的目的通常就是为了找到源对象和汇对象之间的关系，并且确定其中潜在的漏洞或其他问题。</p></li>
<li><p><strong>CCS
CONCEPTS</strong>是ACM计算机协会提出的一种分类体系，用于分类和描述计算机科学领域中的概念和研究方向。其中涉及到的两个概念是“Security
and privacy”和“Software and its engineering”。</p>
<p>“<code>Security and privacy</code>”指的是关于计算机安全和隐私的研究方向，其中Web应用程序安全是一个子领域，主要研究如何保护Web应用程序免受各种威胁和攻击，例如跨站脚本攻击（XSS）、SQL注入、CSRF攻击等。</p>
<p>“<code>Software and its engineering</code>”指的是关于软件及其工程的研究方向，主要涉及软件开发、测试、部署、维护等方面。在软件工程领域，安全是一个非常重要的考虑因素，因为安全漏洞可能导致系统失效、用户信息泄露等严重后果。因此，在软件工程中，需要关注如何设计和实现安全的软件系统。</p></li>
<li><p><strong>KEYWORDS</strong> Abstract Interpretation,</p>
<p>Prototype Pollution,</p>
<p>Object Lookup Analysis,</p>
<p>JavaScript</p></li>
<li><p>Js<strong>动态重定义</strong>内置函数</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 定义一个自定义的log函数</span>
<span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Custom log: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>message<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 使用自定义的log函数替换掉内置的console.log函数</span>
console<span class="token punctuation">.</span>log <span class="token operator">=</span> log<span class="token punctuation">;</span>

<span class="token comment">// 测试一下，现在调用console.log实际上是调用我们定义的log函数了</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello, world!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></li>
<li><p>JavaScript 中，对象可以通过一个内部的属性 <code>__proto__</code>
来指向另一个对象，这个对象被称为原型对象。如果一个对象试图访问一个不存在的属性，JavaScript
引擎会在该对象的原型对象上继续查找这个属性，如果在原型对象上也找不到，就会在原型对象的原型对象上查找，直到找到该属性或者到达<strong>原型链的末尾</strong>（即
Object.prototype）</p></li>
<li><blockquote>
<p><strong>The major challenges</strong> come from the complexity of the
sink and source structures in prototype pollution detection using static
analysis.</p>
</blockquote></li>
<li><p>在软件安全领域中，<code>sink（漏洞点）</code>通常指代那些潜在的漏洞利用点或攻击目标，例如对输入数据的不当处理或未正确验证可能导致的注入攻击、XSS（跨站脚本）漏洞、CSRF（跨站请求伪造）漏洞等。在上下文敏感分析中，sink通常是程序中的一个<strong>函数调用</strong>，它从潜在的漏洞源中接收输入并进行进一步处理，因此可能受到恶意输入的影响。在ObjLupAnsys中，sink指的是<strong>系统内置函数</strong>，例如Object.prototype.toString，该函数可能被重新定义以实现攻击效果。</p></li>
<li><p>我们讲解的是原型污染漏洞中的
<code>源（source）对象</code>。通常，传统漏洞（如命令注入漏洞）的源对象是一个简单类型的<strong>用户输入，</strong>比如字符串。因此，可以简单地将这些输入标记为污点数据。但是，在原型污染漏洞中，源对象通常是一个包含<strong>复杂结构</strong>的对象，例如从
JSON
输入解析而来的对象。挑战在于，输入对象的结构通常是<strong>未知的、动态的</strong>，即由攻击者决定的。因此，简单地将对象标记为污点数据并不能反映其内部结构，以及该结构如何影响上述“sink”对象的查找。</p></li>
<li><p><code>污点分析</code>是一种静态或动态代码分析技术，用于检测和防范安全漏洞，特别是与输入验证和数据处理相关的漏洞。其核心思想是标记数据流中可能被污染（即潜在攻击数据）的变量或参数，并<strong>跟踪</strong>这些污点在程序中的流动，以检测可能的漏洞点。如果一个污点最终到达了一个<strong>敏感函数</strong>（如系统调用、SQL查询、文件操作等），就会被判定为漏洞，并触发警报或其他防御措施。污点分析可以通过<strong>数据流分析、控制流分析、符号执行</strong>等技术实现。它已经成为软件安全分析的重要工具之一，在漏洞挖掘、漏洞修复、软件测试等方面都有广泛应用。</p></li>
<li><p><code>符号执行</code>的基本思想是：将程序中的每个变量符号化，然后从程序的入口点开始执行程序，为每个条件语句创建一个分支，将每个分支上的每个符号变量的所有可能取值表示为约束条件，并对这些约束条件求解，以确定程序路径的所有可能走向。通过对程序的每个路径进行符号执行，可以查找程序中的漏洞或错误，并生成相应的测试用例，以验证程序的正确性。</p></li>
<li><p><strong>代码分析</strong></p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// (a) Vulnerable code:</span>
<span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> p <span class="token keyword">in</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                a<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                a<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            a<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>config<span class="token punctuation">.</span>userId<span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Config must have userId '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>config<span class="token punctuation">.</span>password<span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Config must have password '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">...</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>config <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>defaultConfig<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token operator">...</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Paypal<span class="token punctuation">;</span>

<span class="token comment">// (b) Exploit</span>
<span class="token keyword">var</span> PayPal <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'paypal -adaptive '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PayPal</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>
    <span class="token string">'&#123;" __proto__ ": &#123;" toString ": "polluted"&#125;, "userId ":"foo", "password ": "bar", "signature ": "abcd","appId ": "1234", "sandbox ": "1234"&#125; '</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toString<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ol type="a">
<li><p>这段代码定义了一个 <code>merge</code>
函数，用于合并两个对象。它的输入是两个对象 <code>a</code> 和
<code>b</code>，其中 <code>b</code> 对象的属性会覆盖 <code>a</code>
对象中同名属性的值。具体来说，它会递归地合并两个对象的属性，当某个属性的值是一个对象时，就递归调用
<code>merge</code>
函数，将该属性的值继续合并。如果某个属性的值不是对象，就直接用
<code>b</code> 对象中该属性的值覆盖 <code>a</code>
对象中的值。如果在合并过程中发生异常，则直接用 <code>b</code>
对象中该属性的值覆盖 <code>a</code> 对象中的值。最后返回合并后的
<code>a</code> 对象。</p></li>
<li><p>这段代码首先导入了一个名为 <code>paypal-adaptive</code>
的模块，然后创建了一个 <code>PayPal</code> 类的实例
<code>p</code>。在创建 <code>p</code> 的时候，它的构造函数接收一个 JSON
字符串作为参数，该字符串描述了一个具有 <code>__proto__</code>
属性的对象，该属性的值是一个对象，其中有一个名为 <code>toString</code>
的属性，值为字符串 <code>"polluted"</code>。该 JSON 字符串还描述了
<code>userId</code>、<code>password</code>、<code>signature</code>、<code>appId</code>
和 <code>sandbox</code> 等属性。由于该 JSON 对象具有
<code>__proto__</code> 属性，这可能导致 Prototype Pollution
漏洞。</p></li>
</ol>
<p>接下来，在输出日志信息时，该代码调用了一个空对象 <code>(&#123;&#125;)</code> 的
<code>toString</code>
方法，由于该空对象的原型链被污染，所以该代码实际上调用的是
<code>polluted</code> 字符串的 <code>toString</code>
方法，最终输出的是字符串 <code>"polluted"</code>。</p>
<p><strong>污染过程</strong>：</p>
<p>该空对象的原型链被污染是因为在第三行代码中，攻击者通过向构造函数的参数中传递一个具有特殊属性__proto__的JavaScript对象来污染了空对象的原型链。在第五行代码中，merge函数对对象b的属性进行遍历，将属性值复制到对象a中。由于b对象具有特殊属性__proto__，因此在第五行中，if条件为真，将a[p]的原型链设置为b[p]的原型链，从而将a[p]对象的原型链污染为攻击者控制的对象的原型链。这样，在第六行代码中，当检查空对象的原型链时，它将返回被污染的原型链。这是一个典型的原型污染攻击。</p></li>
<li><p><code>CVE-2020-7643</code>是一个影响Node.js的漏洞，属于Prototype
Pollution漏洞类型。该漏洞的影响版本为Node.js
12.x版本，利用该漏洞，攻击者可以通过构造恶意数据来污染JavaScript对象的原型链，从而导致代码执行漏洞。</p>
<p>具体来说，在Node.js中，有一些<strong>内置模块</strong>（比如querystring模块），会将查询字符串解析为JavaScript对象。攻击者可以在查询字符串中携带特殊构造的__proto__属性，这会导致在解析过程中创建的JavaScript对象的原型链被污染。如果攻击者能够控制该对象的原型链，则可以在目标系统上执行任意JavaScript代码，从而导致严重的安全问题。</p>
<p>该漏洞的修复包括在Node.js
v12.16.2、v10.19.0和v8.17.0版本中，Node.js官方已发布安全更新，建议用户及时升级到最新版本来修复该漏洞。</p></li>
<li><p><code>静态分析</code>可以找到所有的可能路径和条件，但可能会错过一些动态执行的情况。而
<code>动态分析</code>可以发现动态执行的情况，但无法保证所有的路径和条件都能够被触发。因此，在某些情况下，需要同时使用静态和动态分析来发现漏洞</p></li>
<li><p>本文提出了<strong>三个细粒度污染流</strong>，即对象污染流、函数污染流和属性污染流</p></li>
<li><p>JavaScript具有很强的<strong>动态特性</strong>，包括以下几个方面：</p>
<ol type="1">
<li>动态类型：JavaScript是一种动态类型语言，变量的类型是在运行时确定的，而不是在编译时。</li>
<li>动态解释执行：JavaScript代码不需要编译成二进制代码，而是在执行时解释执行。</li>
<li>动态对象：JavaScript中的对象是动态的，可以在运行时添加、删除和修改属性。</li>
<li>动态作用域：JavaScript中的作用域是基于函数的，而不是基于块的。因此，作用域链是在函数调用时动态生成的。</li>
<li>动态闭包：JavaScript中的闭包可以在运行时动态生成，通过闭包可以实现函数的嵌套和变量的私有化。</li>
<li>动态函数：JavaScript中的函数可以在运行时动态生成和修改，可以通过Function构造函数和eval函数实现。</li>
<li>动态模块加载：JavaScript中的模块可以在运行时动态加载，可以通过import函数和动态脚本标签实现。</li>
</ol>
<p>以上特性也是使得JS<strong>出现各种漏洞的原因</strong></p></li>
</ul>
<h4 id="总结-21">总结</h4>
<ul>
<li><p><strong>文献总结</strong></p>
<ul>
<li><strong>研究背景</strong>：原型污染是一种常见的安全漏洞，它可以导致恶意攻击者在应用程序中执行任意代码或获取敏感信息。目前已经有一些针对原型污染漏洞的检测和预防技术，但它们通常只能检测到一些简单的漏洞，并且存在误报率较高的问题。因此，本文旨在提出一种更准确和有效的原型污染检测和预防技术。</li>
<li><strong>创新之处</strong>：本文提出了一种基于对象查找分析（Object
Lookup
Analysis）的方法，用于检测和预防JavaScript应用程序中的原型污染漏洞。该方法利用Object
Property
Graph（OPG）模型来捕获JavaScript对象之间的相互作用关系，并设计了一个名为ObjLupAnsys的框架来进行对象查找分析和漏洞检测。</li>
</ul></li>
<li><p>Song Li <strong>三文对比</strong></p>
<ol type="1">
<li><a
target="_blank" rel="noopener" href="https://www.usenix.org/conference/usenixsecurity22/presentation/li-song">Mining
Node.js Vulnerabilities via Object Dependence Graph and
Query</a>(<strong>CCF-A</strong>:31st USENIX Security Symposium
2022)</li>
<li><a
target="_blank" rel="noopener" href="https://www.ndss-symposium.org/ndss-paper/auto-draft-207/">Probe
the Proto: Measuring Client-Side Prototype Pollution Vulnerabilities of
One Million Real-world Websites</a>(<strong>CCF-A</strong>会议：NDSS
2022)</li>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3468264.3468542">Detecting
Node.js prototype pollution vulnerabilities via object lookup
analysis</a>(<strong>CCF-A</strong>:ESEC/SIGSOFT FSE 2021)</li>
</ol>
<p>本文与Song
Li前两篇文献整体框架如出一辙，但是我是<strong>逆着</strong>作者文章发表顺序阅读的，更准确地说这篇更像是ODGen的雏形。本文提出的是OPG，相比于他后续提出的ODG，工作量明显是更小的。</p>
<p>总的来说，无论是OPG（对象属性图）还是ODG（对象依赖图），作者研究的都是<strong>对象层次</strong>（不是函数或者普通变量）；其无论是属性图还是依赖图，都是以往已经提出并写进大学教材的程序分析方式，作者都是基于这些内容，去研究JS对象中的原型污染问题。</p>
<p>三篇文献的<strong>框架</strong>都类似：提出一种数据结构（分析程序的方法），做出基于此方法的自动化工具（系统框架）。评估标准也是类似。</p>
<p>我感觉第二篇是最难读懂的，这一篇也还是有挺多疑问的地方</p></li>
</ul>
<h3 id="section-35">2023-04-28</h3>
<h4 id="paper信息">paper信息</h4>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://www.ndss-symposium.org/ndss-paper/auto-draft-207/">Probe
the Proto: Measuring Client-Side Prototype Pollution Vulnerabilities of
One Million Real-world Websites</a>(<strong>CCF-A</strong>会议：NDSS
2022,Song Li)</p></li>
<li><p><strong>keywords</strong>:</p>
<p>Prototype Pollution</p>
<p>Joint Taint Flow Analysis</p>
<p>Dynamic Taint Analysis</p></li>
</ul>
<h4 id="正文-11">正文</h4>
<ul>
<li><p>从<strong>title</strong>上看注意到，作者这次研究的客户端上的
<code>JS</code></p></li>
<li><p><strong>原型污染</strong>的出处：文献[6]</p></li>
<li><p>讨论了原型污染的后果，除了污染原型对象本身之外，原型污染还可能导致<strong>其他安全问题</strong>。</p>
<p><strong>举例</strong>：<code>如果另一段JavaScript代码与原型污染漏洞位于同一位置，并循环遍历对象下的所有具有常量值的属性以生成HTML代码，则该原型污染将允许攻击者注入任意JavaScript代码，从而导致跨站脚本攻击（XSS）的发生</code></p>
<p>假设存在以下JavaScript代码段：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 此处省略了获取input的代码</span>
<span class="token keyword">var</span> input <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> input<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">" = "</span> <span class="token operator">+</span> input<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"&lt;br>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>该代码段遍历了一个名为input的对象的所有属性，并生成相应的HTML代码。
如果input对象被受到原型污染漏洞的影响，攻击者可以注入任意JavaScript代码，并因此导致跨站脚本攻击。</p>
<p>例如，攻击者可以将 <code>Object.prototype</code>修改为：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">someEvilFunction</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'gotcha'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>在这种情况下，JavaScript代码段将被修改为：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> input <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token function-variable function">someEvilFunction</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'gotcha'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> input<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">" = "</span> <span class="token operator">+</span> input<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"&lt;br>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>在运行这段代码时，会执行被注入的
<code>someEvilFunction</code>函数，导致一个弹窗出现，从而执行了跨站脚本攻击。</p>
<p><code>Object.prototype</code> 是所有 JavaScript 对象的原型对象。它是
JavaScript
中最顶层的原型对象，所有的内置对象都继承自它，包括数组、函数、日期、正则表达式等。在
JavaScript
中，每个对象都有一个原型对象，它会自动继承原型对象的属性和方法。通过
<code>Object.prototype</code>，我们可以为所有的对象添加共享的属性和方法。</p></li>
<li><p>关于原型污染引起的
<code>Xss</code>漏洞研究，可以关注的<strong>博客</strong>和<strong>github
repository</strong>：文献[9] [10] [6] [24] [29]</p></li>
<li><p>在测量客户端原型污染和后续影响方面，有<strong>两个主要挑战</strong>：</p>
<ol type="1">
<li><p>原型污染和后续影响通常包括两个或更多个链接在一起的属性查找。因此，
PROBETHEPROTO
通过动态污点分析跟踪这些联合污点流来检测原型污染，并引导对象查找传播污点到最终的后果相关的终端接收器（例如
innerHTML）。</p>
<p>假设有一个网站使用了一个第三方 JavaScript
库，其中存在一个漏洞导致原型污染。攻击者可以利用此漏洞在该网站上执行任意代码。攻击者可以将恶意代码注入到网站上，以窃取用户的登录凭据或将用户重定向到其他恶意网站上。攻击者使用以下代码来执行原型污染攻击：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>polluted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre>
<p>这段代码将污染 Object 类型的原型，因此所有基于 Object 的 JavaScript
对象都将受到影响。例如，攻击者可以在以下位置注入恶意代码：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> user_input <span class="token operator">=</span> document<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> user_input<span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>div<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>在这个例子中，攻击者可以通过 user_input 参数注入一个包含恶意脚本的
URL，该脚本会被注入到 div 元素的 innerHTML 属性中。由于 innerHTML
属性具有副作用，攻击者的恶意代码将被执行，导致进一步的攻击。</p>
<p>PROBETHEPROTO 通过动态污点分析追踪了用户输入到 innerHTML
属性的数据流。当 innerHTML
属性被污染时，它被标记为受到攻击的污点，并且跟踪整个数据流直到最终的影响。通过这种方式，PROBETHEPROTO
可以检测出潜在的原型污染漏洞以及它们的后续影响。</p></li>
<li><p>原型污染后续影响的最终接收器可能无法直接到达。因此，
PROBETHEPROTO
采用输入/利用程序生成模块，根据属性查找和接收器函数主动创建对象属性。PROBETHEPROTO执行多个动态污点分析运行。一次运行将记录缺失的属性查找和中间接收器，然后
PROBETHEPROTO
将在后续运行中包括这些缺失属性，以达到与后续影响相关的最终接收器。</p>
<p>举个例子，假设有一个网站上的代码如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> prop <span class="token operator">=</span> <span class="token string">"userInput"</span><span class="token punctuation">;</span>
obj<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"safe value"</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> inputValue <span class="token operator">=</span> <span class="token function">getQueryStringValue</span><span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>inputValue<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  obj<span class="token punctuation">[</span>inputValue<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"evil value"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> obj<span class="token punctuation">.</span>userInput<span class="token punctuation">;</span></code></pre>
<p>在这个例子中，如果攻击者控制了输入值
<code>inputValue</code>，并将其设置为 <code>__proto__</code>，则可以在
<code>obj</code> 对象的原型链上污染 <code>userInput</code>
属性，使其指向一个恶意值。由于 <code>innerHTML</code> 函数的输出将包含
<code>userInput</code>
属性的值，因此攻击者可以利用这种原型污染漏洞，将任意恶意代码注入到网站页面中，从而实现
XSS 攻击。</p>
<p>为了检测这种原型污染漏洞和其后续影响，PROBETHEPROTO将跟踪
<code>obj</code>
对象的属性查找，并在发现原型污染时引入污点值。然后，PROBETHEPROTO将使用动态污点分析生成一个利用程序，将
<code>inputValue</code> 设置为
<code>__proto__</code>，以演示攻击者如何利用此漏洞。最终，PROBETHEPROTO将观察到
<code>innerHTML</code>
函数作为最终接收器，以检测任何潜在的后续影响。</p></li>
</ol></li>
<li><p><strong>漏洞原理</strong></p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/* Exploit: https://www.boulderboats.com/default.asp?
__proto__[k]=&lt;script>alert(1)&lt;/script>&amp;
page=xAllInventory&amp;make=chaparral */</span>
<span class="token comment">// Step 1: polluting the prototype</span>
<span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">Q</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//Q="__proto__[k]=&lt;script>alert(1)&lt;/script>"</span>
    <span class="token keyword">var</span> <span class="token constant">H</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// 创建空对象 H</span>
        <span class="token constant">K</span> <span class="token operator">=</span> <span class="token constant">Q</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"="</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 将传入参数按照等号分割为数组 K</span>
        <span class="token comment">/* 例如：Q="__proto__[k]=&lt;script>alert(1)&lt;/script>"
        则 K = ["__proto__[k]", "&lt;script>alert(1)&lt;/script>"] */</span>
        <span class="token constant">P</span> <span class="token operator">=</span> <span class="token function">decodeURIComponent</span><span class="token punctuation">(</span><span class="token constant">K</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 将 K 中的第一个元素进行 URL 解码，得到 P</span>
        <span class="token comment">// P = "__proto__[k]"</span>
        <span class="token constant">J</span><span class="token punctuation">,</span> <span class="token comment">// 声明变量 J</span>
        <span class="token constant">O</span> <span class="token operator">=</span> <span class="token constant">H</span><span class="token punctuation">,</span> <span class="token comment">// 将对象 H 赋值给 O</span>
        <span class="token constant">M</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// 声明变量 M，初始化为 0</span>
        <span class="token constant">R</span> <span class="token operator">=</span> <span class="token constant">P</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"]["</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 P 按照中括号分割为数组 R</span>
    <span class="token comment">// 例如：R = ["__proto__[k]"];</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\[</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token constant">R</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\]$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token constant">R</span><span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 判断 R 中的第一个和最后一个元素是否以中括号开头和结尾</span>
        <span class="token constant">R</span><span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\]$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 R 中的最后一个元素的结尾中括号去掉</span>
        <span class="token constant">R</span> <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"["</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token constant">R</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 R 中的第一个元素通过 shift() 方法移除，并按照中括号再次分割，与剩下的元素合并为新的数组</span>
        <span class="token comment">/* 例如：R = ["__proto__", "k"] */</span>
        <span class="token constant">N</span> <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 记录 R 数组的长度减一</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">K</span><span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token constant">J</span> <span class="token operator">=</span> <span class="token function">decodeURIComponent</span><span class="token punctuation">(</span><span class="token constant">K</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* J = "&lt;script>alert
(1)&lt;/script>" */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">N</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token constant">M</span> <span class="token operator">&lt;=</span> <span class="token constant">N</span><span class="token punctuation">;</span> <span class="token constant">M</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token constant">P</span> <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">[</span><span class="token constant">M</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">""</span> <span class="token operator">?</span> <span class="token constant">O</span><span class="token punctuation">.</span>length <span class="token operator">:</span> <span class="token constant">R</span><span class="token punctuation">[</span><span class="token constant">M</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token comment">// P = "__proto__" (when M=0); P = "k" (when M=1)</span>
                <span class="token constant">O</span> <span class="token operator">=</span> <span class="token constant">O</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">M</span> <span class="token operator">&lt;</span> <span class="token constant">N</span> <span class="token operator">?</span> <span class="token constant">O</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token constant">R</span><span class="token punctuation">[</span><span class="token constant">M</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token constant">R</span><span class="token punctuation">[</span><span class="token constant">M</span> <span class="token operator">+</span>
                    <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token constant">J</span>
                <span class="token comment">// O=O["__proto__"]=Object.prototype (when M=0)</span>
                <span class="token comment">// O=O["k"]="&lt;script>alert(1)&lt;/script>" (when M=1)</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// Step 2: injecting third-party code</span>
<span class="token keyword">var</span> $unitSpecs <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"&lt;ul/>"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addClass</span><span class="token punctuation">(</span><span class="token string">"unitSpecs"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">//$unitSpecs is a DOM element</span>
    data <span class="token operator">=</span> <span class="token punctuation">&#123;</span> ’<span class="token number">123</span><span class="token literal-property property">’</span><span class="token operator">:</span> ’abc’ <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> field <span class="token keyword">in</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// field = "k"</span>
    $unitSpecs<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"&lt;li>&lt;span class=’"</span> <span class="token operator">+</span> field <span class="token operator">+</span> <span class="token string">"’>"</span> <span class="token operator">+</span>
        data<span class="token punctuation">[</span>field<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"&lt;/span>&lt;/li>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// data["k"]="&lt;script>alert(1)&lt;/script>"</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>假设传入的参数为：Q =
"<strong>proto</strong>[k]=<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>&amp;page=xAllInventory&amp;make=chaparral"</p>
<p><strong>Step 1:</strong></p>
<ol type="1">
<li>函数定义了一个变量 H，创建一个空对象。</li>
<li>将传入参数按照等号分割为数组 K，K[0] 为
"<strong>proto</strong>[k]"，K[1] 为
"<code>&lt;script&gt;alert(1)&lt;/script&gt;&amp;page=xAllInventory&amp;make=chaparral</code>"。</li>
<li>对 K[0] 进行 URL 解码，得到变量 P，P 的值为
"<strong>proto</strong>[k]"。</li>
<li>将 P 按照中括号分割为数组 R，R 的值为 ["<strong>proto</strong>",
"k"]。</li>
<li>判断 R
中的第一个和最后一个元素是否以中括号开头和结尾，发现符合条件，去掉 R
中最后一个元素的结尾中括号，并将 R 中的第一个元素通过 shift()
方法移除，再次按照中括号分割，得到新的 R 数组，R 的值为
["<strong>proto</strong>", "k"]。</li>
<li>声明变量 J。</li>
<li>声明变量 O，将对象 H 赋值给 O。</li>
<li>声明变量 M，初始化为 0。</li>
<li>如果 K 数组的长度为 2，则将 K[1] 进行 URL 解码，得到变量 J，J 的值为
"<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>"。</li>
<li>如果 R 数组的长度大于 0，则循环处理 R
数组的元素，将当前元素赋值给变量 P，如果当前元素为 ""，则将 O
数组的长度赋值给
P。如果当前元素对应的值不存在，则创建一个空对象或空数组，并将其赋值给 O
数组中当前元素对应的属性。如果当前元素不是最后一个元素，则将 O
数组中当前元素对应的属性的值赋值给 O
变量，用于处理下一个元素。如果当前元素是最后一个元素，则将变量 J
的值赋值给 O 数组中当前元素对应的属性。</li>
</ol>
<p><strong>Step 2:</strong></p>
<ol type="1">
<li>创建一个变量 $unitSpecs，用 $("<code>&lt;ul/&gt;</code>") 创建一个
ul 元素，并添加一个 class 为 "unitSpecs"。</li>
<li>创建一个变量 data，该对象有一个键值对 { '123': 'abc' }。</li>
<li>循环处理 data 对象中的键值对，将键和值分别存储到变量 field 和
data[field] 中。</li>
<li>将 data["k"] 的值设置为
<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>。</li>
<li>将 "<code>&lt;li&gt;&lt;span class='k'&gt;</code>" + data["k"] +
"<code>&lt;/li&gt;</code>" 添加到 $unitSpecs 元素中。最终的 $unitSpecs
元素为：&lt;ul
<code>class="unitSpecs"&gt;&lt;li&gt;&lt;span class='k'&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;</code>。</li>
</ol></li>
<li><p><strong>作者的定义</strong>：对象污点和值污点</p></li>
<li><p><strong>汇函数</strong>（sink
function）是指在程序中，可以接收并处理来自外部输入的数据的函数。这些函数通常用于处理敏感数据，如用户输入、网络请求等。如果这些数据未经过适当的验证和过滤，就可能导致安全漏洞</p></li>
<li><p><strong>原型污染的三种攻击后果</strong>：</p></li>
</ul>
<ol type="1">
<li>XSS</li>
<li>Storage(Cookie)Manipulation.</li>
<li>URL Manipulation</li>
</ol>
<ul>
<li><code>PROBETHEPROTO</code> has two major parts:
<ol type="1">
<li>joint taint flow analysis,</li>
<li>result validation.</li>
</ol></li>
<li>在信息安全领域，<strong>源和汇</strong>（source和sink）是两个重要的概念。源是指可以产生潜在危害的安全威胁的输入数据，而汇是指在程序执行过程中可以被攻击者利用的漏洞点，攻击者可以将恶意数据输入到汇中来触发漏洞。通常情况下，源和汇之间存在一条或多条数据流路径，攻击者可以通过控制源的数据流来达到攻击汇的目的。</li>
<li>PROBETHEPROTO系统通过<strong>两种方式生成属性输入</strong>：sink-based和lookup-based</li>
</ul>
<h4 id="总结-22">总结：</h4>
<ul>
<li><p><strong>文献总结</strong></p>
<p>本文的研究背景是<strong>客户端原型污染漏洞</strong>。这是一种相对较新的JavaScript漏洞类型，可能导致跨站脚本攻击（XSS）和cookie篡改等安全问题。在过去的几年中，已经有一些研究关注这个问题，但大多数都是基于手动分析或小规模实验室测试。</p></li>
<li><p>本文的主要<strong>Contributions</strong></p>
<p>提出了
<code>PROBETHEPROTO</code>系统，这是第一个针对客户端原型污染漏洞进行大规模测量研究的系统。该系统使用动态污点分析和漏洞利用生成来跟踪联合污点流并自动化整个过程来检测客户端原型污染漏洞。此外，该研究还提供了一个全球范围内的网站列表，并对这些网站进行了测试，以揭示客户端原型污染漏洞的普遍性和潜在后果。这些创新点为网站开发人员和安全专业人员提供了有用的建议和指导，以帮助他们更好地保护网站免受客户端原型污染漏洞的攻击。</p></li>
<li><p>阅读本文比较<strong>费时间</strong>：在看懂他方法的过程中，几乎没几个熟悉的概念。</p></li>
<li><p>本文与一个月前的<strong>Node.js原型污染</strong>论文是同一作者<strong>song
li</strong></p>
<p><strong>对比：</strong></p>
<ol type="1">
<li>node.js
针对的是<strong>服务端</strong>的原型污染；本文针对的是<strong>客户端</strong>的原型污染，并且研究了在原型污染漏洞影响下造成的其他漏洞Consequence（如XSS漏洞和CSRF漏洞）</li>
<li>这两篇文献的发表时间都是在2022年，前一篇被Usenix收录，这篇被NDSS收录</li>
<li>本文的创新点基于的<strong>背景</strong>很简单：就是没有前人客户端原型污染上进行大规模的实证研究,因此该研究开创了这一领域的先河；而node.js那篇是基于前人的漏洞检测模型检测漏洞单一、且误报率较高的背景下</li>
</ol></li>
</ul>
<h3 id="section-36">2023-04-21</h3>
<h4 id="paper-1">Paper</h4>
<ul>
<li><p><strong>Paper信息</strong></p>
<p><a
target="_blank" rel="noopener" href="https://www.ndss-symposium.org/ndss-paper/fuzzilli-fuzzing-for-javascript-jit-compiler-vulnerabilities/">FUZZILLI:
Fuzzing for JavaScript JIT Compiler
Vulnerabilities</a>(<strong>CCF-A</strong>会议：NDSS 2023)</p></li>
<li><p><strong>keywords</strong></p>
<p>JIT Compiler</p>
<p>Vulnerbility Dection</p>
<p>Fuzzing</p></li>
</ul>
<h4 id="正文-12">正文</h4>
<ul>
<li><p><strong>之前的研究存在的问题</strong>：<code>Previous work on discovering software faults in JavaScript engines found many vulnerabilities, often using fuzz testing. Unfortunately, these fuzzing approaches are not designed to generate source code that actually triggers JIT semantics.</code></p></li>
<li><p><strong>chrome浏览器沙箱逃逸</strong></p>
<p>浏览器沙箱是一种安全机制，通过将JavaScript代码限制在一定的安全边界内，来防止恶意代码对计算机系统的攻击和损害。但是，在某些情况下，攻击者可能会成功地逃脱浏览器沙箱，进而攻击计算机系统。</p>
<p>浏览器沙箱逃逸通常是通过利用浏览器中的漏洞实现的。攻击者会利用这些漏洞，使自己的代码可以在沙箱之外运行，进而获取更高的权限，并对系统进行攻击。例如，攻击者可能会利用浏览器中的内存漏洞，通过缓冲区溢出等技术，将恶意代码注入到系统中，并在特权模式下执行这些代码。</p>
<p>为了防止浏览器沙箱逃逸，可以采取以下措施：</p>
<ol type="1">
<li>及时更新浏览器和操作系统，修补已知的漏洞。</li>
<li>禁用不必要的浏览器插件和扩展程序，尽可能减少攻击面。</li>
<li>使用最小权限原则，限制JavaScript代码的权限，避免给恶意代码留下可乘之机。</li>
<li>使用沙箱技术，将不可信的代码隔离在一个安全的环境中。</li>
<li>部署安全策略，限制JavaScript代码的访问范围，避免数据泄露和其他安全问题。</li>
</ol></li>
<li><p><strong>WebKit</strong></p>
<p>WebKit 是一种用于呈现 Web
内容的开源引擎，主要用于浏览器和移动设备中的应用程序。WebKit
最初是苹果公司为其 Safari
浏览器开发的，现在已被许多其他浏览器和应用程序采用。WebKit
引擎的优势之一是它能够在多个操作系统和平台上运行，包括
macOS、Windows、Linux 和 iOS 等。</p>
<p>WebKit 引擎包含许多模块，例如解析 HTML 和 CSS、渲染布局、管理
JavaScript 执行和处理网络请求等。由于其广泛的应用，WebKit
引擎经常成为攻击者利用的目标之一。常见的攻击方式包括使用恶意网站或文件触发
WebKit 引擎中的漏洞来执行恶意代码或者绕过沙箱保护等。因此，WebKit
引擎的安全性备受关注，并且经常会发布更新来修复已知的漏洞。</p></li>
<li><p><strong>以前的模糊测试</strong>方法针对的是 JavaScript
引擎，而不关注特定组件或仅关注运行时
API。这种方法可以发现范围广泛的漏洞，但很少发现需要同时存在多个先决条件的更复杂的漏洞。特别是JIT编译漏洞，恰恰就是这样一类漏洞</p></li>
<li><p><strong>JIT 编译器优化的条件</strong>。JIT (Just-In-Time)
编译器是一种在运行时将高级语言编译为本地机器代码的技术，这种技术可以提高程序的执行速度。</p>
<p>这段话中提到，为了 JIT 优化能够发生，需要满足一些特殊的条件。首先，JS
引擎必须频繁地执行特定的代码，其次，这段代码的行为必须在执行过程中保持一致和可预测，只有这样，JIT
编译器才会开始对这段代码进行优化。此外，为了让 JS
引擎发现错误，这段代码必须被执行多次，并以不可预测的方式改变其行为。</p>
<p>因此，如果要利用 JIT
编译器漏洞，攻击者需要构造特殊的代码，并确保它能够被频繁执行，同时在一定条件下改变其行为，从而让
JS 引擎产生错误并执行恶意代码。</p></li>
<li><p>本文的一个<strong>特点</strong>：针对特定组件的模糊测试器</p></li>
<li><p>关注<strong>模糊测试</strong>和<strong>灰盒模糊测试</strong></p>
<p>模糊测试是个热点问题，能检索到太多fuzzing的CCF评级文章</p></li>
<li><p><strong>模糊测试分类</strong></p>
<p><strong>生成式模糊测试</strong>（Generative
Fuzzing）是一种自动化软件测试技术，它通过创建模型和生成测试用例来发现软件程序中的漏洞。与传统的模糊测试不同，生成式模糊测试使用输入模型生成测试用例，而不是基于手动构造的输入。它通过学习输入空间的结构和语法来创建输入模型，并从该模型中生成随机输入数据。生成式模糊测试通常使用机器学习算法来生成输入模型，例如生成式对抗网络（GAN）或变分自动编码器（VAE）。这种技术在发现复杂程序的漏洞方面具有很高的效率和准确性</p>
<p><strong>基于突变的模糊测试</strong></p>
<p><strong>引导式模糊测试</strong></p>
<p><strong>结构感知模糊测试</strong></p>
<p>以上类别都不好理解</p></li>
<li><p>本文多次提到
<code>中间表示</code>这个术语，这应该是本文的一个创新之处</p>
<p>在之前看的多篇文献中几乎不出意外都是使用了
<code>AST</code>这一中间表示</p>
<p>而本文创造了一个<strong>新的中间表示</strong></p></li>
<li><p><strong>猜测优化</strong>
"猜测优化"指的是在运行时推断代码的使用模式，从而对代码进行优化的一种技术。在
JavaScript
引擎中，如果一个操作符只被用于一种特定的类型，那么引擎会猜测该操作符只会接收该特定类型的值，并进行优化编译。这种优化编译通常被称为
"内联缓存"，它可以大幅提高代码的执行速度。当然，如果猜测错误，就会产生性能上的损失，因为需要回到解释执行的方式。因此，在猜测优化中，通常会使用一些保护机制，如类型监视器等，来确保猜测是正确的。</p>
<p>因为是对JS编译器的漏洞检测，因此本文多次提到对<strong>JS代码的优化原理</strong></p></li>
<li><p><strong>CVE-2018-4233</strong></p>
<p>在 JIT 编译器生成的代码中，为了确保运行时的类型假设都成立，会使用
guards（守卫）来进行检查。但在某些代码中，guards
可能会变得多余。为了进一步优化代码，JIT 编译器可以删除冗余的
guards。为了确保 guards 确实是多余的，JIT 编译器会分析 guards
之间的代码，以确定是否存在潜在的副作用。但这个分析可能是有误的，因为在某些情况下，看似没有副作用的函数调用可能会触发用户定义的
JavaScript 回调函数，进而改变变量的类型。这就是 CVE-2018-4233
中的漏洞利用方式</p>
<p><strong>原理</strong>：可以举一个简单的<strong>例子</strong>来说明这个漏洞的原理。</p>
<p>假设有一个 JavaScript 程序，其中有一个函数 <code>sum</code>
用于计算两个数的和，如下所示：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>这个函数很简单，但在 JIT
编译时，由于使用频率较高，可能会被进行优化。在优化时，JIT
编译器可能会根据使用情况猜测输入参数的类型，并针对这些类型进行优化。比如，如果
JIT 编译器猜测输入参数 <code>a</code> 和 <code>b</code>
都是整数类型，那么它就会生成针对整数类型的优化代码。</p>
<p>然而，如果在调用 <code>sum</code>
函数时，传入的是字符串类型的参数，由于 JIT
编译器没有对这种类型进行优化，就会导致代码出现错误。</p>
<p>这种漏洞的危害在于它可能会被恶意利用。攻击者可以构造恶意的输入，来触发
JIT
编译器的类型猜测和优化过程，并利用优化后的代码来执行任意的恶意代码。因此，这种漏洞被称为
JIT-spray 攻击。</p></li>
<li><p><strong>JavaScript引擎</strong>是一种软件程序，用于解释和执行JavaScript代码。而<strong>JIT（Just-In-Time）编译器</strong>则是一种优化技术，可以在程序运行时将解释执行的代码转换为本地机器代码，以提高代码的执行速度。</p>
<p>在JavaScript引擎中，通常包含解析器、抽象语法树（AST）、字节码生成器、字节码解释器以及<strong>JIT编译器等组件</strong>。当解释器解析JavaScript代码时，会将代码转换为AST并生成字节码。如果发现某些代码块被频繁执行，就会启动JIT编译器，将其转换为本地机器代码以提高执行速度。</p>
<p>JIT编译器可以根据代码使用模式推断出类型等信息，然后对代码进行“猜测优化”，生成更高效的本地机器代码。同时，为了保证程序的正确性，JIT编译器还会插入类型检查和边界检查等代码。</p>
<p>总之，JIT编译器是JavaScript引擎中重要的组成部分，可以大大提高JavaScript代码的执行速度。</p></li>
<li><p>保证<strong>代码语义的正确性</strong>是让JIT产生优化的必要条件，作者通过对比验证了这一点</p></li>
<li><p><strong>语义代码变异</strong></p>
<p>语义代码变异技术（Semantic Code
Mutations）是一种基于程序的语义信息进行变异的技术。与传统的基于语法的变异技术不同，语义代码变异技术关注程序的语义信息，如控制流和数据流等。在这种技术中，变异器会通过分析程序的语义结构，针对性地进行代码变异，从而生成具有不同语义行为的程序。</p>
<p>语义代码变异技术通常用于<strong>指导模糊测试</strong>，提高测试的效率和准确性。在进行变异之前，语义分析器会对程序进行静态分析，确定代码的语义结构和变异点，以便更好地进行变异。在执行变异后，语义分析器会对变异后的程序进行检查，确保变异后程序的语义正确性。</p>
<p>语义代码变异技术是一种高级的代码变异技术，需要深入理解程序的语义结构和执行过程。这种技术在实际应用中可以提高程序的可靠性和安全性，是程序分析和测试领域的重要研究方向之一。</p></li>
<li><p><code>Consequently,solely semantic mutations are more challenging to implement as immediate mutations could result merely in syntacticchanges to the program and not semantic ones.</code></p></li>
<li><p>在AST层面的突变，很多是无意义的，为了解决这一问题，作者提出在AST基础上再加一层中间表示（IR）,在<strong>IR层面进行突变</strong>以改善这种情况。</p></li>
<li><p><strong>SSA</strong>（Static Single
Assignment）是一种中间代码表示形式，其中每个变量只能被赋值一次。在SSA中，每次对变量的赋值都会创建一个新的版本（也称为“phi节点”），从而确保每个变量只有一个定义点。这种形式使得编译器更容易进行各种优化，因为可以准确地知道变量在程序中的位置，并且可以避免复杂的别名分析。</p>
<p>SSA形式还可以方便地进行控制流分析，因为它使用显式的控制流分割点（也称为“基本块”），这些分割点定义了程序的基本结构，并帮助编译器进行更准确的分析和转换。在SSA中，每个基本块都只能从一个前驱块到达，这简化了许多优化算法，例如值编号、死代码删除和传播优化等。</p>
<p>许多编译器和静态分析工具都使用SSA作为其中间表示形式，因为它具有良好的性质和可扩展性。</p></li>
<li><p>通过不同的突变方式实现四个突变目标</p></li>
<li><p>三个<strong>改善语义正确性的措施</strong></p>
<ul>
<li>Allowing only a valid corpus</li>
<li>Only performing small changes</li>
<li>A lightweight type system</li>
</ul></li>
<li><p>JIT Compiler中的静态类型推理</p></li>
<li><p>当前被认为是<strong>最先进的三个 JavaScript 引擎</strong>是：</p>
<ol type="1">
<li><strong>V8</strong>：由 Google 开发，用于 Chrome 浏览器和 Node.js
等应用程序。它使用了 JIT（即时编译）技术，可以在运行时将 JavaScript
代码编译成本地机器代码，以提高性能。</li>
<li><strong>SpiderMonkey</strong>：由 Mozilla 开发，是 Firefox
浏览器的默认 JavaScript 引擎。它也使用了 JIT 技术，并且在性能上与 V8
不相上下。</li>
<li><strong>JavaScriptCore</strong>：由苹果公司开发，是 Safari
浏览器的默认 JavaScript 引擎。它采用了一种名为“中间表示”的技术，可以将
JavaScript 代码编译成字节码，然后在运行时进行解释执行。</li>
</ol></li>
<li><p>在进行代码模糊测试时<strong>启用断言</strong>可以帮助发现潜在的漏洞。断言是在代码中插入的用于判断某些<strong>前置条件或后置条件</strong>的检查语句，如果条件不满足则断言会触发并中止程序的执行。在这里，作者指出开启断言可以帮助发现一些不容易被直接发现的安全缺陷。例如，<strong>CVE-2019-8622</strong>这个安全漏洞就是因为断言失败而被发现的。在
JIT
编译器中，存在<strong>一种假设</strong>，即某个操作不会导致垃圾回收，但实际上这个操作确实会触发一些可能引起垃圾回收的
API，而这就为攻击者制造了可乘之机。通过在代码中加入断言可以帮助及早发现此类漏洞。</p></li>
<li><p>作者给出的<strong>建议</strong>：未来的fuzzing研究必须提供任何初始语料库以便进行复制，并且应该更加重视使用不同的、可能是新的语料库来重现以前的fuzzing结果，以估计fuzzer在不同语料库上的泛化能力。</p></li>
<li></li>
</ul>
<h3 id="section-37">2023-04-14</h3>
<h4 id="paper1">Paper1</h4>
<ul>
<li><p><strong>paper信息：</strong></p>
<p><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3488932.3497769">On Measuring
Vulnerable JavaScript Functions in the
Wild</a>(<strong>CCF-C:</strong>17th AsiaCCS 2022: Nagasaki, Japan)</p>
<blockquote>
<p>Published:30 May 2022</p>
</blockquote></li>
<li><p><strong>keywords</strong>:</p>
<p>JavaScript security;</p>
<p>vulnerability detection;</p>
<p>vulnerable functions</p></li>
<li><p><strong>正文</strong></p>
<ul>
<li><p><code>As evident from the results,our approach can shift JavaScript vulnerability detection from the coarse package/library level to function level</code>
如何理解包级别和函数级别的关系</p></li>
<li><p><strong>文本相似性方法</strong>和<strong>语义相似性方法</strong>是自然语言处理领域中两个不同的概念。</p>
<p>文本相似性方法（Textual similarity
methods）是指通过比较文本之间的语法、词汇和结构等方面的相似性来度量它们之间的相似性。文本相似性方法通常采用基于词袋模型、TF-IDF、余弦相似度等技术进行计算，常用于文本分类、信息检索和问答系统等领域。</p>
<p>而语义相似性方法（Semantic similarity
methods）则更加注重比较文本之间的意义和语义方面的相似性。语义相似性方法可以采用词嵌入技术（如Word2Vec、GloVe等）来捕捉词汇的语义信息，或者使用深度学习模型（如Siamese网络、BERT等）来学习文本之间的语义表示，从而计算它们之间的相似度。语义相似性方法可以应用于文本匹配、句子相似性计算、知识图谱等领域。</p>
<p>总的来说，文本相似性方法侧重于<strong>文本的形式和结构</strong>方面的相似性，而语义相似性方法更注重<strong>文本的语义和含义</strong>方面的相似性</p></li>
<li><p><strong>元信息</strong></p></li>
<li><p>文本相似性检测方法:内容敏感模糊散列和加密散列</p>
<p><strong>内容敏感模糊散列</strong>（Content-sensitive fuzzy
hashing，CSFH）和加密散列是文本相似性检测中常用的两种方法。</p>
<p><strong>内容敏感模糊散列</strong>是通过对文本进行模糊化处理，提取文本的特征信息，然后计算散列值来判断文本相似性。在处理过程中，可以将一些特定的信息（如时间戳、IP地址等）进行屏蔽，以提高散列算法的鲁棒性和抗干扰能力。</p>
<p>加密散列是将文本通过一个不可逆的加密算法进行加密，得到一段固定长度的散列值，常用的加密算法包括MD5、SHA等。对于两个文本，如果它们的散列值相同，则可以认为它们内容相同或者非常相似。</p>
<p>这两种方法在文本相似性检测中都有广泛的应用，但是内容敏感模糊散列相对于加密散列而言，在抗抄袭能力和相似性检测的精度方面具有一定的优</p></li>
<li><p><strong>Regular Expression Denial of Service</strong></p>
<p>正则表达式拒绝服务攻击（Regular Expression Denial of
Service，简称ReDoS）是一种针对使用正则表达式的应用程序的攻击。攻击者通过构造恶意的输入数据，使得正则表达式匹配过程变得异常耗时，导致服务器资源被耗尽，从而导致服务不可用。</p>
<p>ReDoS攻击的实现方式通常是利用正则表达式中的回溯机制，通过构造特定的字符串使得正则表达式需要反复回溯匹配，从而占用大量CPU时间和内存资源。这种攻击方式不需要大量的网络流量或计算资源，只需要发送一个恶意字符串即可引发攻击。</p>
<p>为了防止ReDoS攻击，可以采取以下措施：</p>
<ul>
<li>使用正则表达式引擎的超时机制，限制匹配时间。</li>
<li>限制正则表达式的复杂度，例如限制正则表达式中的重复次数或递归深度。</li>
<li>对输入数据进行合理的验证和过滤，避免输入中包含可导致ReDoS攻击的字符或模式。</li>
<li>使用更加高效的正则表达式引擎，避免使用容易被攻击的引擎。</li>
</ul></li>
<li><p><strong>两个漏洞数据库</strong>：</p>
<p>Snyk vulnerability database</p>
<p>Google VulnCode-DB project</p></li>
</ul>
<p>----<strong>补充</strong>----</p>
<ul>
<li><p><strong>文本标记化</strong>（Tokenization）是一种将文本转换为标记序列（token
sequence）的自然语言处理（NLP）技术。在文本标记化过程中，将文本分割成词（word）、词组、符号或其他有意义的元素，这些元素被称为标记。标记化通常是文本处理的第一步，是构建自然语言处理系统的基础。</p>
<p>标记化的主要目的是将文本转换为可供计算机处理的数据结构，例如词袋（bag
of
words）或向量。在自然语言处理任务中，标记化是非常关键的，因为文本中的单词顺序和单词之间的关系对于最终结果的影响非常重要。</p></li>
<li><p><code>ML/DL algorithms have to rely on a large dataset of vulnerable and patched functions with clear ground truth which, to the extent of our knowledge, does not exist for JavaScript.</code></p></li>
<li><p>漏洞检测有不同的<strong>粒度级别</strong>：行级、函数级、文件级和包级</p>
<p>是的，漏洞检测可以在不同的粒度级别进行，如下所示：</p>
<ol type="1">
<li>行级：在代码的每一行进行检测，以寻找可能存在的漏洞。</li>
<li>函数级：对每个函数进行检测，以查找可能存在的漏洞。</li>
<li>文件级：对每个文件进行检测，以查找可能存在的漏洞。</li>
<li>包级：对每个软件包或库进行检测，以查找可能存在的漏洞。</li>
</ol>
<p>选择何种粒度级别取决于具体的应用场景和目标，不同的级别有其优缺点。例如，行级检测可以找到最细粒度的漏洞，但可能会产生较高的误报率；文件级检测可以提供更全面的检测结果，但可能会忽略一些局部漏洞；包级检测可以快速检测大量代码，但可能会产生较多的漏洞遗漏。因此，在实际应用中需要根据具体情况进行选择和权衡。</p></li>
</ul></li>
</ul>
<h4 id="总结-23">总结</h4>
<ul>
<li><p><strong>一图总结全文</strong><img
src="https://s2.loli.net/2023/04/15/5C4tyFpMDhT1PqO.png"
alt="image-20230415015912950" /></p>
<p>非常显而易见的是：作者在对<strong>数据的处理</strong>下了很大功夫</p>
<p><strong>具体来说，</strong>基于两个原始的漏洞数据库和github上的链接，使用半自动化函数验证方法和静态分析工具Semgrep使用半自动化过滤步骤来区分真正易受攻击的函数，提取出了更为有有效的数据。</p>
<p>该框架主要用于检测<strong>两种类型的漏洞</strong>：原型污染（在两周前的paper中已经提到）和正则表达式拒绝服务（ReDoS）</p>
<p>检测漏洞的方法：文本相似性方法和语义相似性方法</p>
<p><strong>贡献</strong>和<strong>创新之处</strong>：本文的创新之处在于，它提出了一种结合文本相似性和模式匹配的方法来检测JavaScript函数中的易受攻击漏洞。该方法使用静态分析工具Semgrep来执行高级语义搜索，以理解变量和结构，并在代码中检测模式。此外，作者还开发了一个Web应用程序，使手动验证更快、更容易。他们将收集的数据上传到Web界面，这使得他们可以轻松地在条目、文件和函数之间导航。最后，作者还对一些易受攻击函数进行了案例研究，以了解这些漏洞如何影响包含它们的项目，以及它们对用户构成什么威胁。</p>
<p><strong>本文跟两周前的paper</strong>有一定相似之处，都没引入任何的神经网络模型。</p>
<ol type="1">
<li>两者检测的漏洞有一些不同</li>
<li>本文对数据的收集和处理上花了更多功夫</li>
</ol></li>
<li><p>总的来说：给我的感觉恰恰是没有引入任何神经网络模型的paper更加难以阅读。</p></li>
</ul>
<h3 id="section-38">2023-04-07</h3>
<h4 id="paper1-1">Paper1</h4>
<p><a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0167404822004072?via%3Dihub">MFXSS:
An effective XSS vulnerability detection method in JavaScript based on
multi-feature model</a>(<strong>CCF-B</strong>:Computers &amp;
Security)</p>
<ul>
<li><p><strong>Paper信息：</strong></p>
<p>Article history:Received 15 September 2022Revised 1 November
2022Accepted 14 November 2022Available online 20 November 2022</p></li>
<li><p><strong>keywords:</strong></p>
<p>Cross-site scriptingMulti-feature fusionGraph convolutional
networkWeighted aggregationVulnerability detection</p></li>
<li><p><strong>前置知识</strong></p>
<ul>
<li><p><strong>加权聚合：</strong></p>
<p>加权聚合是一种多指标决策方法，用于将多个指标或评估准则的结果进行汇总和综合评估。该方法将各个指标或评估准则进行加权，将它们的结果按照其权重进行加总，并将得到的总分作为最终评估结果。</p>
<p>在加权聚合中，每个指标或评估准则都有一个权重，这个权重表示了其在最终评估结果中的相对重要性。这些权重通常是根据专家判断或基于历史数据进行确定的。</p>
<p>加权聚合的优点是可以将多个指标或评估准则进行统一的量化，从而更加客观地进行综合评估。缺点是需要对各个指标或评估准则的权重进行准确的确定，否则可能会导致最终评估结果的不准确性</p></li>
<li><p><strong>平均聚合和求和聚合</strong>:</p>
<p>在机器学习中，聚合是将多个模型预测结果合并为单个结果的过程。平均聚合和求和聚合是常见的两种聚合方法。</p>
<p>平均聚合（Mean
Aggregation）是将所有模型的预测结果取平均值的过程。在这种方法中，每个模型的权重都是相等的。例如，如果有5个模型，每个模型的预测结果分别是[0.8,
0.9, 0.7, 0.6, 0.85]，则这些结果的平均值为0.78。</p>
<p>求和聚合（Sum
Aggregation）是将所有模型的预测结果相加的过程。在这种方法中，每个模型的权重也是相等的。例如，如果有5个模型，每个模型的预测结果分别是[0.8,
0.9, 0.7, 0.6, 0.85]，则这些结果的总和为3.85。</p>
<p>需要注意的是，平均聚合和求和聚合都假设每个模型的预测结果具有相同的重要性。在实际情况中，这种假设可能不成立。因此，一些高级聚合方法使用权重来调整每个模型的预测结果的重要性。</p></li>
<li><p><strong>领域自适应</strong></p>
<p>领域自适应（Domain Adaptation）是指将在源领域（Source
Domain）上学习到的知识应用到目标领域（Target
Domain）中的过程。在机器学习领域中，源领域和目标领域通常具有相同的输入特征空间，但是有不同的输出空间。领域自适应的目的是利用源领域的知识来提高目标领域的学习性能。</p>
<p>在实际应用中，由于源领域和目标领域之间的差异，导致在目标领域上使用源领域的模型会导致性能下降。例如，在计算机视觉领域中，源领域可能是一个特定类型的图像数据集，例如人脸图像，而目标领域可能是其他类型的图像数据集，例如动物图像。由于人脸和动物图像之间的视觉特征存在较大差异，因此在人脸数据集上训练的模型在动物图像数据集上的性能可能会下降。</p>
<p>为了解决这个问题，领域自适应方法被提出来了。其基本思路是在源领域和目标领域之间建立联系，通过对源领域的数据进行适当的变换，使得源领域和目标领域的差异最小化，从而提高在目标领域上的性能。常用的领域自适应方法包括最大均值差异（Maximum
Mean Discrepancy，MMD）、核对齐（Kernel Alignment，KA）等</p></li>
</ul></li>
<li><p><strong>Paper正文</strong></p>
<ul>
<li><p>multi-type features</p></li>
<li><p><strong>Bi-LSTM</strong></p>
<p>Bi-LSTM是一种双向长短期记忆神经网络（Bidirectional Long Short-Term
Memory Network）的缩写。它是在LSTM的基础上发展而来的。</p>
<p>LSTM是一种适用于序列数据的神经网络，可以处理长期依赖性问题。但是LSTM只能单向地处理序列，即只能利用历史信息。而Bi-LSTM能够同时利用历史信息和未来信息，因此在处理序列数据时更为有效。Bi-LSTM通过在序列数据的前后分别运行两个LSTM网络，然后将它们的输出合并起来，实现了双向处理。</p>
<p>Bi-LSTM的应用非常广泛，特别是在自然语言处理（NLP）领域中。例如，Bi-LSTM可以用于语音识别、文本分类、命名实体识别、情感分析等任务。</p></li>
<li><p><strong>Dropout</strong>是一种常见的正则化技术，常用于深度学习中，旨在减少过拟合</p></li>
<li><p><strong>多层感知机(MLP)模型</strong></p>
<p>多层感知机（Multi-Layer
Perceptron，MLP）是一种常见的前馈神经网络模型。它由输入层、若干个隐层和输出层组成，每个层之间都有全连接的权重。在训练过程中，输入信号从输入层开始依次传递到隐层和输出层，最终得到模型的预测结果。</p>
<p>MLP模型可以通过反向传播算法进行训练，该算法通过计算模型输出值和真实标签之间的误差，然后逆向传播误差，并根据误差调整权重，从而最小化误差。</p>
<p>MLP模型广泛应用于各种机器学习任务，如分类、回归、聚类等。在实践中，可以通过调整隐层的数量和大小，以及不同的激活函数和优化算法来改善模型性能</p></li>
<li><p><strong>激活函数</strong></p>
<p>激活函数（activation
function）是一种数学函数，通常用于神经网络中的每个神经元，用于将输入信号的加权和转换为输出信号。激活函数的作用是为神经网络引入非线性性，从而使得神经网络可以学习更加复杂的关系。</p>
<p>常见的激活函数包括：</p>
<ol type="1">
<li>sigmoid函数：将输入值压缩到0和1之间，可以用于二分类问题。</li>
<li>ReLU函数：将负数部分置为0，保留正数部分，能够快速计算和解决梯度消失问题。</li>
<li>tanh函数：类似于sigmoid函数，但输出值在-1和1之间，常用于多分类问题。</li>
<li>softmax函数：用于多分类问题，将输出转换为概率分布。</li>
</ol>
<p>选择激活函数的主要考虑因素是其是否具有非线性性质、是否易于计算和是否可以避免梯度消失等问题。不同的神经网络层可能需要不同的激活函数。</p></li>
<li><p>这里给出了<strong>评估分类模型性能的三个重要指标</strong>，以及一个综合这些指标的
F1 score。</p>
<ul>
<li>Accuracy：模型分类正确的样本数占总样本数的比例。</li>
<li>Recall（召回率）：真实正例中被模型正确分类的比例，衡量模型找到正例的能力。</li>
<li>Precision（精度）：模型分类为正例的样本中，真实正例的比例，衡量模型分类为正例的准确性。</li>
<li>F1 score：综合考虑 Precision 和 Recall，是 Precision 和 Recall
的调和平均数，可用于评估分类不平衡问题中的模型性能。</li>
</ul></li>
<li><p><strong>十倍交叉验证</strong></p>
<p>十倍交叉验证是一种常用的机器学习模型评估方法，也叫做十折交叉验证。它将数据集划分为10个部分，每次将其中9个部分作为训练集，剩下的一个部分作为验证集，共进行10次训练和验证。最终，将这10次训练和验证的结果进行平均，得到模型的评估结果。</p>
<p>这种方法的优点是能够更好地评估模型的泛化能力，即模型在未见过的数据上的表现。缺点是需要进行多次训练和验证，计算时间相对较长</p></li>
<li><p><strong>多特征融合</strong></p>
<p>多特征融合指的是将多种不同类型的特征进行整合，用于提高机器学习模型的性能和准确度。在实际应用中，一个问题通常需要从多个方面考虑，因此需要用多种不同类型的特征来描述该问题。比如，在计算机视觉领域中，可以使用图像特征、语义特征和位置特征来描述一个物体；在自然语言处理领域中，可以使用词频、词向量和词性等多种不同类型的特征来描述一段文本。</p>
<p>多特征融合的目的是将这些不同类型的特征融合在一起，以获取更全面的信息，提高模型的性能和准确度。具体来说，多特征融合可以采用以下几种方法：</p>
<ol type="1">
<li>特征拼接：将不同类型的特征按照一定的顺序拼接在一起，形成一个更大的特征向量。</li>
<li>特征加权：给不同类型的特征赋予不同的权重，使得模型更关注某些特定类型的特征。</li>
<li>特征交叉：将不同类型的特征进行交叉组合，产生新的特征，从而扩展特征空间。</li>
<li>特征选择：选择最具代表性的特征，将其用于模型训练和测试，减少噪声和冗余信息。</li>
</ol>
<p>多特征融合可以有效地提高模型的性能和准确度，但也需要注意特征之间的相关性和影响，避免引入噪声和过度拟合的情况。同时，不同的特征融合方法适用于不同的问题和数据集，需要根据具体情况进行选择和调整。</p></li>
<li><p><strong>自注意力机制</strong>（Self-Attention
Mechanism）是一种可以通过对输入序列中各元素进行不同权重的加权，来计算其输出表示的方法。它最早是在2017年提出的，被应用于神经机器翻译中，但其后被证明在众多自然语言处理和计算机视觉任务中都有很好的表现。</p>
<p>自注意力机制主要包含以下几个步骤：</p>
<ol type="1">
<li>将输入序列中的每个元素进行线性变换，得到其对应的查询（Query）、键（Key）和值（Value）向量。</li>
<li>计算每个查询向量与所有键向量的相似度，使用softmax函数将相似度转化为权重系数，得到与该查询向量对应的值向量。</li>
<li>将所有值向量加权求和，得到该查询向量对应的输出表示。</li>
</ol>
<p>自注意力机制的优点是能够动态地计算不同输入元素之间的关系，并且不会受到固定窗口大小的限制，能够处理变长序列。在自然语言处理中，自注意力机制可以被用来构建强大的语言模型，如Transformer，BERT等。</p></li>
<li><p><strong>NLTK</strong></p>
<p>NLTK是一个开源的自然语言处理（NLP）库，全称为Natural Language
Toolkit。它是用Python编写的，并且包含了各种用于处理自然语言的工具、资源和数据集。NLTK可以用于文本分类、标记化、分块、分析、语义推理、语料库管理等任务。NLTK提供了大量的教程和实践，使得学习和使用NLP变得更加容易和有趣。</p></li>
<li><p><strong>Word2Vec</strong></p>
<p>Word2Vec
是一种将单词转换为向量表示的算法，它将单词映射到高维空间中的向量，使得具有相似含义的单词在空间中靠近彼此。该算法基于分布式假设，即单词的含义可以通过它们周围的单词来确定。Word2Vec
算法主要有两种模型：连续词袋模型（Continuous Bag of Words,
CBOW）和跳跃式模型（Skip-gram）。CBOW
模型基于上下文单词的平均值来预测当前单词，而 Skip-gram
则是基于当前单词来预测上下文单词。</p>
<p>Word2Vec
的主要优点是可以将高维稀疏的离散单词转换为低维稠密的连续向量，从而提高了计算效率，并使得语义相似的单词在向量空间中具有相似的几何结构。Word2Vec
可以应用于多种自然语言处理任务，例如情感分析、词性标注、命名实体识别等</p></li>
<li><p><strong>Readout</strong></p>
<p>在机器学习中，readout是指从神经网络的隐藏状态中提取输出的过程。在图神经网络中，readout通常是一个将所有节点或边的隐藏状态聚合成一个图级别表示的函数。例如，可以使用加和或平均值来获得整个图的表示。readout是图神经网络中的一个重要组件，它通常用于将节点和边的表示组合成整个图的表示，以便进行图级别的分类或回归任务。</p></li>
</ul></li>
</ul>
<h4 id="总结-24">总结</h4>
<ul>
<li><p>本文与上周阅读paper有较多联系：同样研究的是JavaScript代码的漏洞</p>
<p><strong>区别在于：</strong></p>
<p>上周paper讨论的是在JS在后端的漏洞(原型链中的内部属性篡改、原型污染和命令注入漏洞)，本文讨论的是前端产生的漏洞（如XSS）</p>
<p>XSS漏洞也正是是我当前研究的漏洞之一</p>
<ul>
<li><p><strong>研究前存在的问题</strong>：</p>
<ol type="1">
<li>特征提取不全面：现有的XSS漏洞检测方法通常只考虑了代码中的部分特征，如字符串、变量等，而忽略了控制流和数据依赖关系等重要特征。</li>
<li>特征维度不够：现有的XSS漏洞检测方法提取的特征维度较低，无法充分捕获JavaScript代码中复杂的语义信息。</li>
<li>缺乏上下文信息：现有的XSS漏洞检测方法通常只考虑单个代码片段中的特征，而忽略了与其相关联的上下文信息。</li>
</ol></li>
<li><p>一图总结本文<strong>贡献</strong><img
src="https://s2.loli.net/2023/04/07/tbBzdP34cRrGHE9.png"
alt="image-20230407204812757" /></p>
<p>总的来说：作者围绕<strong>多特征融合</strong>这个方法，将图结构的特征和代码字符串特征（针对敏感的属性和方法）融合在一起，使用<strong>多层感知模型</strong>对代码中是否存在XSS漏洞做出预测和分类。</p>
<p>其中使用优化加权聚合方法和递归神经网络来<strong>提取图形结构特征</strong>，使用Bi-LSTM模型来提取<strong>代码字符串特征</strong>，使用<strong>自注意力机制</strong>加强两种特征的交互，提升XSS漏洞检测性能</p></li>
<li><p>本文所做的研究工作，引入了神经网络以及NLP技术，正是我之前计划研究的一部分内容，非常贴近我的研究工作。</p></li>
</ul></li>
</ul>
<h3 id="section-39">2023-03-31</h3>
<h4 id="程序设计">程序设计</h4>
<ul>
<li>AST: 例如程序
<code>const team = '大转转FE'</code>的AST如下：是一个JSON对象</li>
</ul>
<pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>
    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Program"</span><span class="token punctuation">,</span>
    <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
    <span class="token property">"body"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">&#123;</span>
        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"VariableDeclaration"</span><span class="token punctuation">,</span>
        <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
        <span class="token property">"declarations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
          <span class="token punctuation">&#123;</span>
            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"VariableDeclarator"</span><span class="token punctuation">,</span>
            <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>
            <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
            <span class="token property">"id"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
              <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Identifier"</span><span class="token punctuation">,</span>
              <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>
              <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">,</span>
              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"team"</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
            <span class="token property">"init"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
              <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Literal"</span><span class="token punctuation">,</span>
              <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
              <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
              <span class="token property">"value"</span><span class="token operator">:</span> <span class="token string">"大转转FE"</span><span class="token punctuation">,</span>
              <span class="token property">"raw"</span><span class="token operator">:</span> <span class="token string">"'大转转FE'"</span>
            <span class="token punctuation">&#125;</span>
          <span class="token punctuation">&#125;</span>
        <span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"const"</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token property">"sourceType"</span><span class="token operator">:</span> <span class="token string">"module"</span>
  <span class="token punctuation">&#125;</span></code></pre>
<ul>
<li><p><strong>Node.js</strong></p>
<p>是一个基于Chrome V8
JavaScript引擎构建的JavaScript运行时环境。它可以在服务器端运行JavaScript代码，使得JavaScript不仅可以用于前端开发，还可以用于后端开发。Node.js采用事件驱动、非阻塞I/O模型，使得它能够处理高并发、高吞吐量的应用程序。</p>
<p>Node.js有以下特点：</p>
<ol type="1">
<li><strong>轻量级</strong>：Node.js的核心只包含几个模块，可以根据需要安装其他模块，使得Node.js非常轻量级，启动和运行速度很快。</li>
<li><strong>高效性</strong>：Node.js采用事件驱动、非阻塞I/O模型，使得它可以高效地处理大量并发请求。此外，Node.js还支持异步编程，可以更好地利用系统资源。</li>
<li>跨平台性：Node.js可以运行在多种操作系统上，如Windows、Linux、MacOS等。</li>
<li><strong>社区活跃</strong>：Node.js拥有一个庞大的开发者社区，可以方便地获取各种模块、框架和工具，可以快速开发高质量的应用程序。</li>
</ol>
<p>Node.js可以用于构建各种类型的应用程序，如Web应用程序、命令行工具、网络服务、物联网应用程序等。它可以使用JavaScript进行全栈开发，使得开发人员可以使用同一种语言进行前后端开发，提高了开发效率和代码可维护性。</p></li>
<li><p>Node.js 相关漏洞</p>
<p><strong>命令注入</strong>（Command
Injection）是指攻击者利用应用程序没有对用户输入数据进行正确处理的漏洞，将恶意命令注入到应用程序中，从而达到控制系统、窃取敏感信息等目的的攻击行为。</p>
<p><strong>原型污染</strong>（Prototype
Pollution）是指攻击者能够修改JavaScript对象的原型（prototype）属性，从而影响到所有从该原型继承而来的对象。这种攻击方式可能导致应用程序中的数据被篡改、敏感信息泄露等安全问题。</p>
<p><strong>路径穿越</strong>（Path
Traversal）是指攻击者利用应用程序没有对用户输入数据进行正确处理的漏洞，访问应用程序之外的文件或目录。这种攻击方式可能导致攻击者能够读取、修改、删除或上传应用程序之外的文件，从而达到窃取敏感信息或者破坏系统的目的。</p>
<p><strong>内部属性篡改</strong>（Internal Property
Tampering）是指攻击者利用JavaScript的一些高级特性，如Object.defineProperty()方法等，对对象的内部属性进行篡改，从而导致应用程序出现安全漏洞。这种攻击方式可能导致应用程序中的数据被篡改、敏感信息泄露等安全问题。</p></li>
<li><p><strong>原型对象</strong></p>
<p>每个函数都有一个名为“prototype”的属性，它指向一个对象。这个对象被称为函数的原型对象（prototype
object）。原型对象是一个普通对象，它具有自己的属性和方法。</p></li>
</ul>
<h4 id="论文正文">论文正文</h4>
<h5 id="论文1-6">论文1</h5>
<ul>
<li><p><strong>文献信息</strong></p>
<p><a
target="_blank" rel="noopener" href="https://www.usenix.org/conference/usenixsecurity22/presentation/li-song">Mining
Node.js Vulnerabilities via Object Dependence Graph and
Query</a>(<strong>CCF-A</strong>:31st USENIX Security Symposium
2022)</p></li>
<li><p><strong>Node.js 常见漏洞：</strong></p>
<p>命令注入、原型污染、路径穿越和内部属性篡改</p></li>
<li><p><strong>for example</strong></p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token class-name">Func</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span>
myFunc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Func</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>source1<span class="token punctuation">)</span>
    myFunc<span class="token punctuation">[</span>source2<span class="token punctuation">]</span> <span class="token operator">=</span> myFunc<span class="token punctuation">.</span>x <span class="token operator">+</span> source1<span class="token punctuation">;</span> <span class="token comment">// internal property tampering</span>
<span class="token function">sink</span><span class="token punctuation">(</span>myFunc<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// taint -style vulnerability like command injection</span></code></pre>
<ul>
<li><p><code>Func()</code> 这个函数有一个原型对象
<code>Func.prototype</code>，<strong>myFunc</strong> 这个函数将会继承
<code>Func</code>的原型对象，所以<strong>myFunc.x</strong>操纵的是
<code>Func.prototype.x</code></p></li>
<li><p><strong>内部属性篡改</strong>：source2可由敌手控制</p>
<ol type="1">
<li>如设置为Func.prototype.x；</li>
<li>设置为 <code>__proto__</code> 将会更改原型Func.prototype</li>
</ol></li>
<li><p><strong>污点式漏洞</strong></p>
<ol type="1">
<li>由内部属性篡改知，myFunc.x可被修改为敌手想要的任意值，执行特殊命令</li>
</ol></li>
<li><p><strong>Query</strong></p>
<p>是一个用于查找代码库中<strong>特定模式</strong>的语言，可以用于检查代码中的潜在漏洞、复杂的代码路径、不安全的代码模式等。它并不是专门用于检测
Node.js
程序中漏洞的查询语言，而是可以应用于不同编程语言和平台的代码库。在
Node.js 中，通常使用 ESLint 插件来运行 Query 查询。</p>
<blockquote>
<p><strong>特定模式：</strong>在程序分析中，特定模式是指一组代码结构、逻辑或者特定的数据流关系，用于表示程序中的某种行为或漏洞类型。通过定义这些模式，可以用于检测程序中是否存在该行为或漏洞类型，并提示开发人员进行相应的修复。例如，用于检测
SQL 注入漏洞的特定模式可能包括输入的数据被直接拼接到 SQL
语句中、缺乏输入数据的验证和转义等。特定模式可以作为一种规则库，用于静态分析工具或代码审查工具来扫描代码并发现潜在的安全漏洞</p>
<p><strong>数据流</strong>是指在程序执行过程中，数据的传递和变换的过程。数据流分析是一种静态分析方法，它用于在程序的执行过程中跟踪数据流的路径，以便确定程序中潜在的错误和漏洞。数据流分析可以帮助我们检测出程序中的一些常见问题，如空指针引用、未初始化变量、数组下标越界、内存泄漏等问题。</p>
</blockquote></li>
</ul></li>
<li><p><strong>Application-level Vulnerabilities</strong></p>
<ul>
<li>Adversary-controlled network request to a vulnerable server.</li>
<li>Adversary-controlled network response to a vulnerable client</li>
</ul></li>
<li><p><strong>Package-level Vulnerabilities</strong></p>
<ul>
<li>包漏洞会导致本身没有漏洞的应用程序出现漏洞</li>
</ul></li>
<li><p><strong>抽象解释</strong>（Abstract
Interpretation）是一种程序分析技术，旨在推导出程序的语义信息，例如变量的类型、取值范围、可能的程序路径等，从而检测程序中的错误和漏洞。抽象解释通过对程序状态的抽象和近似来实现对程序的静态分析，以便能够处理大型程序和更复杂的语言特性。</p>
<p>在抽象解释中，程序状态通常由抽象域（Abstract
Domain）中的元素表示。抽象域是程序状态空间的一个子集，其中每个元素都是原始状态的抽象。例如，可以使用整数区间作为抽象域来表示数值变量的取值范围，使用布尔代数作为抽象域来表示布尔变量的取值。抽象解释使用抽象函数来操作抽象域中的元素，这些函数应该是可定向的，并应该确保抽象状态保持足够精度</p></li>
<li><p><strong>代码属性图（CPG</strong>）是一种综合了抽象语法树（AST）、控制流图（CFG）和程序依赖图（PDG）的数据结构，它可以帮助分析人员更好地理解代码的结构和行为。CPG可以通过将AST、CFG和PDG结合起来，从而捕获代码中的更多细节和复杂性，提供更全面的代码分析和理解</p></li>
<li><p><strong>程序依赖图（Program Dependence
Graph，PDG）</strong>是一种表示程序执行流程和数据依赖关系的图形化表示方法。在PDG中，程序的每个语句表示为节点，每个节点之间通过边连接表示语句间的依赖关系，包括数据依赖、控制依赖和输出依赖。</p>
<p><strong>数据依赖</strong>：如果一个语句使用了另一个语句的输出，那么它们之间存在数据依赖。例如，赋值语句的右侧使用了变量，那么它们之间就存在数据依赖。</p>
<p><strong>控制依赖</strong>：如果一个语句的执行受另一个语句的控制结构影响，那么它们之间存在控制依赖。例如，if语句和while语句的条件语句控制了其内部语句的执行。</p>
<p><strong>输出依赖</strong>：如果一个语句的输出被另一个语句使用，那么它们之间存在输出依赖。例如，函数调用的返回值被另一个语句使用。</p></li>
<li><p><strong>Sanitization
Functions（清洗函数）</strong>是一类函数，用于过滤和转义输入数据，以确保输入数据不包含任何恶意内容。这些函数通常用于防止跨站脚本攻击（XSS）和SQL注入攻击等安全威胁。</p>
<p>例如，如果一个 Web
应用程序需要从用户输入中接收一个字符串，该字符串将被传递给数据库进行查询，那么必须使用一个清洗函数对该字符串进行处理，以防止
SQL
注入攻击。常用的清洗函数包括转义单引号、双引号、反斜杠等特殊字符。</p>
<p>在 Node.js
中，可以使用各种模块和库来实现输入数据的清洗。例如，可以使用
<code>sanitize-html</code> 模块过滤 HTML 标签，或者使用
<code>mysql</code> 模块的 <code>mysql.escape()</code> 函数来转义 SQL
查询中的特殊字符。</p></li>
</ul>
<h4 id="总结-25">总结</h4>
<ul>
<li>关于<strong>代码分析方法设计的图结构</strong>总结
<ul>
<li>抽象语法树（AST）</li>
<li>控制流图（CFG）</li>
<li>代码属性图（CPG）</li>
<li>程序依赖图（Program Dependence Graph，PDG）
<ol type="1">
<li>数据依赖</li>
<li>控制依赖</li>
<li>输出依赖</li>
</ol></li>
</ul></li>
<li><strong>收获：</strong>这篇论文令我意外：因为本文的研究并没有设计人工智能模型
<ol type="1">
<li>如果不加入人工智能模型，我感觉很难做出创新</li>
<li>我对本文的理解就是：在前人做出的基于图的代码分析方法基础上，针对JavaScript这种语言的特性（主要是原型链），提出了对对象（面向对象编程中的一种数据类型，在这种语言中，函数也是对象）建模的一种方法并将前几种图结构结合，作者定义为ODG。</li>
</ol></li>
</ul>
<h3 id="section-40">2023-03-24</h3>
<h4 id="期刊">期刊</h4>
<blockquote>
<ul>
<li><a
target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/xpl/conhome/9842455/proceeding">2022
IEEE 46th Annual Computers, Software, and Applications Conference
(COMPSAC)</a>
<ul>
<li><strong>CCF-C</strong> (软件工程/系统软件/程序设计语言)</li>
</ul></li>
</ul>
</blockquote>
<h4 id="论文1-7">论文1</h4>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9842744">Can Deep
Learning Models Learn the Vulnerable Patterns for Vulnerability
Detection?</a> [<strong>CCF-C</strong>: 2022 IEEE 46th Annual Computers,
Software, and Applications Conference (COMPSAC)]</li>
<li><strong>Date of Conference</strong>: 27 June 2022 - 01 July
2022</li>
</ul>
</blockquote>
<ul>
<li><p><strong>研究问题</strong>：</p>
<ul>
<li>深度学习能否在漏洞检测上有所作为</li>
<li>探索上述问题的可解释性</li>
</ul></li>
<li><p><strong>关键词：</strong>Vulnerability detection, Deep learning,
Atten-tion, Model interpretability</p></li>
<li><p><strong>ML和DL</strong></p>
<blockquote>
<p><strong>机器学习</strong>是人工智能的一个分支，它是一种使用算法和统计模型让计算机自动地从数据中学习规律，并用于预测或分类的方法。它可以分为有监督学习、无监督学习、半监督学习和强化学习等不同类型。</p>
<p><strong>深度学习</strong>是机器学习的一种特定形式，它是一种建立在人工神经网络基础上的机器学习技术。它的主要特点是可以通过构建多层非线性变换的神经网络来提取和学习数据的高阶特征表示，从而实现对复杂模式和规律的识别和预测。深度学习可以应用于图像识别、语音识别、自然语言处理等领域，已经成为人工智能领域的重要分支之一。</p>
<ul>
<li><strong>有监督学习</strong>：在有监督学习中，我们提供带标签的数据集作为输入，并让算法从数据中学习规律，以便将新的数据进行分类或预测。例如，根据房屋的面积、位置、卧室数等特征，预测房价。</li>
<li><strong>无监督学习</strong>：在无监督学习中，我们提供未标记的数据集作为输入，让算法自己发现其中的规律和结构。例如，聚类分析可以将相似的数据点分为一组，从而发现数据中的类别。</li>
<li><strong>半监督学习</strong>：在半监督学习中，我们同时使用带标签和未标记的数据集进行训练，以提高算法的准确性。这种方法通常可以在数据集较小的情况下获得更好的结果。</li>
<li><strong>强化学习</strong>：在强化学习中，算法通过与环境的交互来学习最优行为策略。它与其他机器学习方法不同，因为它是一种试错学习方法，通过反馈机制不断调整策略以实现最优结果。例如，训练机器人在环境中移动和完成任务。</li>
<li><strong>迁移学习</strong>：迁移学习是指将已经学习到的知识迁移到新的任务或领域中。通过利用已经学习到的知识，可以加快新任务的学习速度和提高学习的效果。</li>
<li><strong>增强学习</strong>：增强学习是指在强化学习的基础上，为了实现更好的性能，通过不断改进学习过程和策略来提高算法的表现。</li>
<li><strong>深度学习</strong>：深度学习是一种建立在神经网络上的机器学习技术，可以自动提取和学习数据的高阶特征表示。深度学习广泛应用于计算机视觉、自然语言处理和语音识别等领域。</li>
<li><strong>概率图模型</strong>：概率图模型是一种用于建模复杂数据关系的方法，包括贝叶斯网络和马尔科夫随机场等。它们通常用于无监督学习和半监督学习中，可以对数据进行建模和分析。</li>
</ul>
</blockquote></li>
<li><p><strong>注意力机制</strong></p>
<blockquote>
<p>是一种人工智能中常用的技术，它可以使神经网络更好地处理序列数据，并将重点放在最相关的部分上。</p>
<p>在注意力机制中，网络可以根据输入数据中的不同部分分配不同的注意力权重，以便更好地识别和利用有用的信息。例如，在文本分类中，网络可以根据文本中每个单词的重要性分配不同的注意力权重，以便更好地判断文本的类别。</p>
<p>注意力机制可以用于各种任务，如自然语言处理、语音识别、图像识别等。它已经成为深度学习中的一种常用技术，并在很多实际应用中取得了很好的效果</p>
<ul>
<li><p>序列数据</p>
<blockquote>
<p>序列数据是指按照时间顺序排列的一系列数据，通常用于描述某个事件或过程的演变。序列数据可以是文本、语音、图像等，它们都具有一定的时序性和相关性。</p>
<p>在人工智能中，序列数据经常用于各种任务，如语音识别、自然语言处理、时间序列预测等。为了处理序列数据，通常需要使用一些特殊的技术和模型，例如循环神经网络（RNN）、长短时记忆网络（LSTM）、卷积神经网络（CNN）等。</p>
<p>序列数据的处理和建模是人工智能研究中的重要方向之一，它们可以帮助我们更好地理解和分析各种事件和过程，提高各种任务的准确性和效率。</p>
</blockquote></li>
</ul>
</blockquote></li>
<li><p><strong>模型可解释性</strong></p>
<blockquote>
<p>是指在人工智能和机器学习中，对于一个训练好的模型，我们能够清晰地理解和解释其预测结果的过程和原因。具有良好的可解释性的模型可以帮助我们更好地理解和掌握数据的本质规律，提高对数据的信任和理解度。</p>
<p>在实际应用中，模型的可解释性非常重要。例如，在医疗诊断中，对于一个预测结果，我们需要知道该结果是由哪些因素决定的，以便更好地了解患者的病情和制定治疗方案。在金融风控中，我们需要知道一个信用评估模型如何得出其评估结果，以便更好地预测风险和做出决策。</p>
<p>提高模型的可解释性是一个研究热点和难点，研究人员们正在不断尝试各种方法和技术来实现这个目标。例如，利用可视化技术、特征重要性分析、局部可解释性等方法来提高模型的可解释性。</p>
</blockquote></li>
<li><p><strong>论文正文</strong></p>
<ul>
<li><p><code>Chakraborty et al. [5] claim that DL models learn certain irrelevant features which are harmful to improve the performance of vulnerability detection</code></p></li>
<li><p><strong>基于代码相似性的漏洞检测方法</strong>：</p>
<p>是指通过比较源代码的相似性，发现潜在的漏洞。该方法可以分为静态和动态两种。</p>
<p><strong>静态方法</strong>主要是通过对源代码进行静态分析，找出潜在的漏洞点。其中，代码相似度计算是静态方法中的关键步骤。代码相似度计算方法包括文本相似度、语法树相似度和程序切片等。</p>
<p><strong>动态方法</strong>主要是通过对程序的执行过程进行分析，找出漏洞点。其中，基于程序执行过程的代码相似度计算方法是动态方法的关键步骤。这种方法需要对程序进行插桩，然后记录程序执行的信息，比较程序执行过程中的相似度，最终找出漏洞点。</p></li>
<li><p>基于<strong>代码相似性</strong>的漏洞检测方法和基于<strong>代码模式</strong>的漏洞检测方法都是常见的<strong>自动化</strong>漏洞检测方法。</p>
<blockquote>
<p><strong>模式：</strong>经常出现的一些结构或者行为</p>
<ul>
<li><p><strong>语法分析</strong>：识别代码中的各个元素（如变量、函数、关键字等）以及它们之间的关系</p></li>
<li><p><strong>语义分析</strong>：对代码中的各个元素进行语义解释和推理</p>
<blockquote>
<p>例如，我们需要确定代码中变量的<strong>数据类型、函数的返回值以及各个语句的执行顺序</strong>等信息。</p>
</blockquote></li>
</ul>
<p><strong>比如</strong>缓冲区溢出中的内存访问越界、格式化字符串中的格式化输入等等。模式是由专家手工定义或者通过机器学习从源代码中自动学习得到的。模式匹配的过程通常使用<strong>正则表达式</strong>或者其他<strong>模式匹配算法</strong>，如<strong>图匹配算法</strong>等</p>
<p><strong>相似度：</strong></p>
</blockquote>
<p>基于<strong>代码相似性</strong>的漏洞检测方法主要是通过对源代码进行<strong>语法和语义分析</strong>，比较代码之间的相似度，从而检测潜在的漏洞。该方法的优点是能够准确地检测出源代码中的漏洞，并且能够自动地识别<strong>不同类型</strong>的漏洞。同时，该方法也存在一些问题，比如需要大量的计算资源和时间，还容易出现误报和漏报的情况。</p>
<p>基于<strong>代码模式</strong>的漏洞检测方法主要是通过学习代码中的模式来检测潜在的漏洞。该方法的优点是能够有效地检测出<strong>特定类型</strong>的漏洞，比如缓冲区溢出、代码注入等等。同时，该方法也存在一些问题，比如检测效果受限于训练数据，无法检测出新型漏洞等。</p></li>
<li><p><strong>三种类型的漏洞数据集</strong>：真实世界、半合成和合成</p></li>
<li><p><strong>两类漏洞模型</strong>用于漏洞检测</p>
<ul>
<li>基于序列的模型</li>
<li>基于GNN的模型</li>
</ul></li>
<li><p>方法论</p>
<ul>
<li><p><strong>数据预处理</strong>：数据依赖图（DDG）:数据依赖图是指用图形化的方式展示程序中各个变量之间的依赖关系</p>
<blockquote>
<ol type="1">
<li><p>数据（代码）的预处理：其中涉及较多的编译原理知识：我们分析代码的过程正是模仿了编译器对代码的处理模式。主要理解了以下几点</p>
<p>Ast（抽象语法树）、CFG（控制流图）和DDG（数据依赖图）是程序分析中常用的三种表示程序结构和行为的图形模型。</p>
<blockquote>
<ol type="1">
<li>Ast是基础：
Ast是程序代码的语法表示，是从程序代码中提取出的最基本的语法元素。</li>
<li>CFG基于Ast：CFG是基于Ast构建的，它利用Ast的语法元素作为节点，并使用Ast中的控制语句来构建图形模型。</li>
<li>DDG基于Ast和CFG：DDG是基于Ast和CFG构建的，它既包含Ast中的语法元素，也包含CFG中的控制结构，同时还包含变量和数据之间的依赖关系。</li>
</ol>
</blockquote></li>
</ol>
</blockquote>
<ul>
<li><strong>JavaParser</strong>是一个Java语法树分析器，它可以将Java代码解析成语法树，方便程序员进行各种静态代码分析、重构和优化</li>
<li><code>Labeling the vulnerability-related code lines.</code>难以理解这部分内容</li>
<li><strong>抽象语法树</strong>通常是在源代码经过词法分析和语法分析后生成的，它描述了程序的结构和语义。</li>
<li>通常我们将样本以<strong>向量</strong>的形式作为模型的输入</li>
</ul></li>
<li><p><strong>模型生成</strong>：</p>
<ul>
<li>图节点嵌入：指DDG</li>
<li>高层特征的生成和分类:不同于初始特征</li>
</ul></li>
<li><p><strong>模型测试</strong>：模型的可解释性，制定评估标准，本文为DDG节点的注意力得分</p></li>
</ul>
<figure>
<img src="https://s2.loli.net/2023/03/25/H2XGapiwEJjgt3P.png"
alt="image-20230325005007803" />
<figcaption aria-hidden="true">image-20230325005007803</figcaption>
</figure></li>
</ul></li>
<li><p>**</p></li>
</ul>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><code>&lt;br&gt;&lt;br&gt;</code></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Jf71o0x1o1l</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://Jf710001011.github.io/2022/09/26/academic-progress/">https://Jf710001011.github.io/2022/09/26/academic-progress/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="/about" target="_blank">Jf71o0x1o1l</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Academic/">
                                    <span class="chip bg-color">Academic</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'U2qj9LBn7UhJFyVyb1bYDa9w-gzGzoHsz',
        appKey: 'Tg6wRvRlIfODtULeHu4P96zh',
        notify: 'true' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'en',
        placeholder: 'just go go'
    });
</script>

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2022/09/26/python-kai-fa-xss-sao-miao-qi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="python开发xss扫描器">
                        
                        <span class="card-title">python开发xss扫描器</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            xss扫描器、xss
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-09-26
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Cybersecurity/" class="post-category">
                                    Cybersecurity
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Web/">
                        <span class="chip bg-color">Web</span>
                    </a>
                    
                    <a href="/tags/Python/">
                        <span class="chip bg-color">Python</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/08/24/shen-tou-ce-shi-xia/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="渗透测试基础（下）">
                        
                        <span class="card-title">渗透测试基础（下）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            penetration
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-08-24
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Cybersecurity/" class="post-category">
                                    Cybersecurity
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Web/">
                        <span class="chip bg-color">Web</span>
                    </a>
                    
                    <a href="/tags/Xss/">
                        <span class="chip bg-color">Xss</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




                            <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023-2024</span>
            
            <span id="year">2023</span>
            <a href="/about" target="_blank">Jf71o0x1o1l</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">226.1k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2023";
                    var startMonth = "2";
                    var startDate = "16";
                    var startHour = "24";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
            <span id="icp"><img src="/medias/icp.png" style="vertical-align: text-bottom;" />
                <a href="/null" target="_blank">津ICP备Jf710001011号</a>
            </span>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Jf710001011" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:lhhyp2333@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


                                <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

                                    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


                                        <script
                                            src="/libs/materialize/materialize.min.js"></script>
                                        <script
                                            src="/libs/masonry/masonry.pkgd.min.js"></script>
                                        <script
                                            src="/libs/aos/aos.js"></script>
                                        <script
                                            src="/libs/scrollprogress/scrollProgress.min.js"></script>
                                        <script
                                            src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
                                        <script
                                            src="/js/matery.js"></script>

                                        <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

                                            <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

                                                
                                                    <script
                                                        src="/libs/others/clicklove.js"
                                                        async="async"></script>
                                                    
                                                        
                                                            <script async
                                                                src="/libs/others/busuanzi.pure.mini.js"></script>
                                                            

                                                                

                                                                        

                                                                                
                                                                                        
                                                                                            <script
                                                                                                type="text/javascript"
                                                                                                color="0,0,255"
                                                                                                pointColor="0,0,255"
                                                                                                opacity='0.7'
                                                                                                zIndex="-1"
                                                                                                count="99"
                                                                                                src="/libs/background/canvas-nest.js"></script>
                                                                                            

                                                                                                

                                                                                                            
                                                                                                                <script
                                                                                                                    type="text/javascript"
                                                                                                                    src="/libs/background/ribbon-dynamic.js"
                                                                                                                    async="async"></script>
                                                                                                                

                                                                                                                    
                                                                                                                        <script
                                                                                                                            src="/libs/instantpage/instantpage.js"
                                                                                                                            type="module"></script>
                                                                                                                        
                                                                                                                            <script
                                                                                                                                type="text/javascript">
                                                                                                                                    //只在桌面版网页启用特效
                                                                                                                                    var windowWidth = $(window).width();
                                                                                                                                    if (windowWidth > 768) {
                                                                                                                                        document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>');
                                                                                                                                    }
                                                                                                                                </script>
                </body>

</html>